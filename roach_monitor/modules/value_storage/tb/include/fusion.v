`ifndef FUSION_V
`define FUSION_V
//-----------------------------------------------------------------
//       Actel Verilog Library
//       NAME: fusion.v
//       DATE: 12/1/2006
//-----------------------------------------------------------------


//----------------------------------------------------------------------
//---             VERILOG LIBRRAY PRIMITIVE SECTION                     
//----------------------------------------------------------------------

//---- PRIMITIVE Dffpr ----
 //---------------------------------------------------------------------
 // primitibe module (Dffpr) state table definition
 // FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
 //            ASYNCHRONOUS SET AND CLEAR. CLR PRIORITY WHEN BOTH
 //            SET AND CLEAR ARE LOW ( Q OUTPUT UDP ).
 //            Enable active low.

 //----------------------------------------------------------------------
primitive Dffpr (Q, D, CLK, CLR, PRE, E, NOTIFIER_REG);
  output Q;
  input  NOTIFIER_REG;
  input  D, CLK, E, CLR, PRE;
  reg Q;

	table

	//  D   CLK   CLR  PRE   E  NOTIFIER_REG  :   Qt  :  Qt+1

	    1   (01)    1   1    0      ?         :   ?   :   1;  // clocked data
	    0   (01)    1   1    0      ?         :   ?   :   0;  // clocked data
	    1   (01)    1   1    x      ?         :   1   :   1;  // clocked data
	    0   (01)    1   1    x      ?         :   0   :   0; 
	    0   (01)    1   1    x      ?         :   1   :   x;
	    1   (01)    1   1    x      ?         :   0   :   x;
	    0   (01)    x   1    0      ?         :   ?   :   0;  // pessimism
	    1   (01)    1   x    0      ?         :   ?   :   1;  // pessimism
	    ?    ?      1   x    ?      ?         :   1   :   1;  // pessimism
	    0    ?      1   x    ?      ?         :   x   :   x;  // pessimism
	    ?    ?      1   x    ?      ?         :   0   :   x;
	    ?    ?      x   x    ?      ?         :   ?   :   x;
	    ?    ?      x   0    ?      ?         :   ?   :   x;
	    ?    ?      x   1    ?      ?         :   0   :   0;
	    ?    ?      x   1    ?      ?         :   1   :   x;
	    ?    ?      0   ?    ?      ?         :   ?   :   0;
	    ?    ?      1   0    ?      ?         :   ?   :   1;
	    1   (x1)    1   1    0      ?         :   1   :   1;  // reducing pessimism
	    0   (x1)    1   1    0      ?         :   0   :   0;
	    1   (0x)    1   1    0      ?         :   1   :   1;
     0   (0x)    1   1    0      ?         :   0   :   0;
	    1   (x1)    1   1    x      ?         :   1   :   1;  // reducing pessimism
	    0   (x1)    1   1    x      ?         :   0   :   0;
	    1   (0x)    1   1    x      ?         :   1   :   1;
	    0   (0x)    1   1    x      ?         :   0   :   0;
	    ?  (?1)     1   1    1      ?         :   ?   :   -;  //no action for CE = 1
	    ?  (0x)     1   1    1      ?         :   ?   :   -;  //no action for CE = 1
	    ?   ?       ?   ?    *      ?         :   ?   :   -;
	    ?   (?0)    ?   ?    ?      ?         :   ?   :   -;  // ignore falling clock
	    ?   (1x)    ?   ?    ?      ?         :   ?   :   -;  // ignore falling clock
	    *    ?      ?   ?    ?      ?         :   ?   :   -;  // ignore data edges
	    ?   ?     (?1)  ?    ?      ?         :   ?   :   -;  // ignore the edges on
	    ?   ?       ?  (?1)  ?      ?         :   ?   :   -;  //       set and clear
	    ?   ?       ?   ?    ?      *         :   ?   :   x;

	endtable
 endprimitive
//---- END PRIMITIVE Dffpr ----

//---- PRIMITIVE Dffpf ----
 //---------------------------------------------------------------------
 // primitibe module (Dffpf) logic table definition
 // FUNCTION : NEGATIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
 //            ASYNCHRONOUS SET AND CLEAR. CLR PRIORITY WHEN BOTH
 //            SET AND CLEAR ARE LOW ( Q OUTPUT UDP ).
 //            Enable active low.

 //----------------------------------------------------------------------
primitive Dffpf (Q, D, CLK, CLR, PRE, E, NOTIFIER_REG);
  output Q;
  input  NOTIFIER_REG;
  input  D, CLK, E, CLR, PRE;
  reg Q;

 table

//    D   CLK     CLR PRE  E  NOTIFIER_REG  :   Qt  :  Qt+1	
	     1   (10)    1   1    0      ?         :   ?   :   1;  // clocked data
	     0   (10)    1   1    0      ?         :   ?   :   0;  // clocked data
	     1   (10)    1   1    x      ?         :   1   :   1;  // clocked data
	     0   (10)    1   1    x      ?         :   0   :   0;
	     0   (10)    1   x    x      ?         :   1   :   1;
	     0   (10)    1   1    x      ?         :   1   :   x;
	     1   (10)    1   1    x      ?         :   0   :   x;
	     0   (10)    1   x    0      ?         :   1   :   1;
	     0   (10)    x   1    0      ?         :   ?   :   0;
	     1   (10)    1   ?    0      ?         :   ?   :   1;  // pessimism
	     1    ?      1   x    0      ?         :   1   :   1;  // pessimism
	     ?    ?      1   x    ?      ?         :   0   :   x;
	     0    1      1   x    0      ?         :   1   :   1;  // pessimism
	     0    x      1 (?x)   0      ?         :   1   :   1;  // pessimism
	     0    ?      1 (?x)   0      ?         :   1   :   1;  // baoxian
	     0    ?      x   1    ?      ?         :   0   :   0;
	     0    ?      x   0    ?      ?         :   ?   :   x;
	     0    ?      x   1    ?      ?         :   1   :   x;
	     x    1      1   x    0      ?         :   1   :   1;  // pessimism
	     x    x      1 (?x)   0      ?         :   1   :   1;  // pessimism
	     x    0      1   x    0      ?         :   1   :   1;  // pessimism
	     1    ?      1   x    x      ?         :   1   :   1;  // pessimism
	     0    1      1   x    x      ?         :   1   :   1;  // pessimism
	     0    x      1 (?x)   x      ?         :   1   :   1;  // pessimism
	     0    0      1 (?x)   x      ?         :   1   :   1;  // pessimism
	     x    1      1   x    x      ?         :   1   :   1;  // pessimism
	     x    ?      1   x    x      ?         :   1   :   1;  // pessimism
	     1    0      x   1    0      ?         :   0   :   0;  // pessimism
	     1    x    (?x)  1    0      ?         :   0   :   0;  // pessimism
	     1    1    (?x)  1    0      ?         :   0   :   0;  // pessimism
	     x    0      x   1    0      ?         :   0   :   0;  // pessimism
	     x    x    (?x)  1    0      ?         :   0   :   0;  // pessimism
	     x    1    (?x)  1    0      ?         :   0   :   0;  // pessimism
	     1    0      x   1    x      ?         :   0   :   0;  // pessimism
	     1    x    (?x)  1    x      ?         :   0   :   0;  // pessimism
	     1    1    (?x)  1    x      ?         :   0   :   0;  // pessimism
	     x    0      x   1    x      ?         :   0   :   0;  // pessimism
	     x    x    (?x)  1    x      ?         :   0   :   0;  // pessimism
	     x    1    (?x)  1    x      ?         :   0   :   0;  // pessimism
	     1   (1x)    1   1    0      ?         :   1   :   1;  // reducing pessimism
	     0   (1x)    1   1    0      ?         :   0   :   0;
	     1   (x0)    1   1    0      ?         :   1   :   1;
	     0   (x0)    1   1    0      ?         :   0   :   0;
	     1   (1x)    1   1    x      ?         :   1   :   1;  // reducing pessimism
	     0   (1x)    1   1    x      ?         :   0   :   0;
	     1   (x0)    1   1    x      ?         :   1   :   1;
	     0   (x0)    1   1    x      ?         :   0   :   0;
	     ?   ?       0   1    ?      ?         :   ?   :   0;  // asynchronous clear
	     ?   ?       1   0    ?      ?         :   ?   :   1;  // asynchronous set
	     ?  (?0)     1   1    1      ?         :   ?   :   -;  //no action for CE = 1
	     ?  (1x)     1   1    1      ?         :   ?   :   -;  //no action for CE = 1
	     ?   (?0)    x   1    1      ?         :   0   :   0;  // chip is not enabled pessimism with reset
	     ?   (1x)    x   1    1      ?         :   0   :   0;  // chip is not enabled pessimism with reset
	     ?    ?    (?x)  1    1      ?         :   0   :   0;  // chip is not enabled pessimism with reset
	     ?   (?0)    1   x    1      ?         :   1   :   1;  // chip is not enabled pessimism with reset
	     ?   (1x)    1   x    1      ?         :   1   :   1;  // chip is not enabled pessimism with reset
	     ?    ?      1  (?x)  1      ?         :   1   :   1;  // chip is not enabled pessimism with reset
	     ?   ?       ?   ?    *      ?         :   ?   :   -;
	     ?   (?1)    ?   ?    ?      ?         :   ?   :   -;  // ignore falling clock
	     ?   (0x)    ?   ?    ?      ?         :   ?   :   -;  // ignore falling clock
	     *    ?      ?   ?    ?      ?         :   ?   :   -;  // ignore data edges
	     ?   ?     (?1)  ?    ?      ?         :   ?   :   -;  // ignore the edges on
	     ?   ?       ?  (?1)  ?      ?         :   ?   :   -;  //       set and clear
	     ?   ?       0   0    ?      ?         :   ?   :   0; // CLR Priority (added 0n 11/12/97)
	     ?   ?       0   x    ?      ?         :   ?   :   0; // CLR Priority (added 0n 11/12/97)
	     ?   ?       ?   ?    ?      *         :   ?   :   x;
	endtable
 endprimitive
//---- END PRIMITIVE Dffpf ----

//---- PRIMITIVE UFPRB ----
//--------------------------------------------------------------------
//-                    cell  UFPRB.v                                  -
//--------------------------------------------------------------------

primitive UFPRB (Q, D, CP, RB, NOTIFIER_REG);

    output Q;
    input  NOTIFIER_REG,
           D, CP, RB;
    reg    Q;

// FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS CLEAR ( Q OUTPUT UDP ).

    table
    //  D   CP      RB     NOTIFIER_REG  :   Qt  :   Qt+1

        1   (01)    1         ?          :   ?   :   1;  // clocked data
        0   (01)    1         ?          :   ?   :   0;

        0   (01)    x         ?          :   ?   :   0;  // pessimism
        0    ?      x         ?          :   0   :   0;  // pessimism

        1    0      x         ?          :   0   :   0;  // pessimism
        1    x    (?x)        ?          :   0   :   0;  // pessimism
        1    1    (?x)        ?          :   0   :   0;  // pessimism
        x    0      x         ?          :   0   :   0;  // pessimism
        x    x    (?x)        ?          :   0   :   0;  // pessimism
        x    1    (?x)        ?          :   0   :   0;  // pessimism
        1   (x1)    1         ?          :   1   :   1;  // reducing pessimism
        0   (x1)    1         ?          :   0   :   0;
        1   (0x)    1         ?          :   1   :   1;
        0   (0x)    1         ?          :   0   :   0;
        ?   ?       0         ?          :   ?   :   0;  // asynchronous clear
        ?   (?0)    ?         ?          :   ?   :   -;  // ignore falling clock
        ?   (1x)    ?         ?          :   ?   :   -;  // ignore falling clock
        *    ?      ?         ?          :   ?   :   -;  // ignore the edges on data
        ?    ?    (?1)        ?          :   ?   :   -;  // ignore the edges on clear
        ?    ?      ?         *          :   ?   :   x;
    endtable
endprimitive
//---- END PRIMITIVE UFPRB ----

//---- PRIMITIVE UFNRB ----
//--------------------------------------------------------------------
//-                    cell  UFNRB.v                                  -
//--------------------------------------------------------------------
primitive UFNRB (Q, D, CP, RB, NOTIFIER_REG);
    output Q;
    input  NOTIFIER_REG,
           D, CP, RB;
    reg    Q;
// FUNCTION : NEGATIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS CLEAR ( Q OUTPUT UDP ).
    table
    //  D   CP      RB     NOTIFIER_REG  :   Qt  :   Qt+1
        1   (10)    1         ?          :   ?   :   1;  // clocked data
        0   (10)    1         ?          :   ?   :   0;
        0   (10)    x         ?          :   ?   :   0;  // pessimism
        0    ?      x         ?          :   0   :   0;  // pessimism
        1    1      x         ?          :   0   :   0;  // pessimism
        1    x    (?x)        ?          :   0   :   0;  // pessimism
        1    0    (?x)        ?          :   0   :   0;  // pessimism
        x    1      x         ?          :   0   :   0;  // pessimism
        x    x    (?x)        ?          :   0   :   0;  // pessimism
        x    0    (?x)        ?          :   0   :   0;  // pessimism
        1   (1x)    1         ?          :   1   :   1;  // reducing pessimism
        0   (1x)    1         ?          :   0   :   0;
        1   (x0)    1         ?          :   1   :   1;
        0   (x0)    1         ?          :   0   :   0;
        ?   ?       0         ?          :   ?   :   0;  // asynchronous clear
        ?   (?1)    ?         ?          :   ?   :   -;  // ignore falling clock
        ?   (0x)    ?         ?          :   ?   :   -;  // ignore falling clock
        *    ?      ?         ?          :   ?   :   -;  // ignore the edges on data
        ?    ?    (?1)        ?          :   ?   :   -;  // ignore the edges on clear
        ?    ?      ?         *          :   ?   :   x;
    endtable
endprimitive
//---- END PRIMITIVE UFNRB ----

//---- PRIMITIVE DL2C_UDP ----
//------------------------------------------------------------------------
// primitive DL2C_UDP functional description
// FUNCTION : NEGATIVE LEVEL SENSITIVE D-TYPE LATCH WITH ACTIVE HIGH
//            ASYNCHRONOUS SET AND RESET.
//-------------------------------------------------------------------------


primitive DL2C_UDP (q, d, g, c, p, NOTIFIER_REG);

 output q;
 input  d,              // DATA
        g,              // CLOCK
        c,              // CLEAR ACTIVE HIGH
        p,              // SET ACTIVE HIGH
        NOTIFIER_REG;

 reg q;

    table
    //  D     G     C     P  NOTIFIER_REG  :   Qt  :   Qt+1
        ?     ?     1     ?     ?          :   ?   :   0;  // active low clear
        ?     ?     0     1     ?          :   ?   :   1;  // active high preset

        ?     1     0     0     ?          :   ?   :   -;  // latch
        0     0     0     0     ?          :   ?   :   0;  // transparent

        0     0     x     0     ?          :   ?   :   0;  // CLR==x
        ?     1     x     0     ?          :   0   :   0;  // CLR==x
        0     x     ?     0     ?          :   0   :   0;  // CLR,G==x

        1     x     0     ?     ?          :   1   :   1;  // PRE==x/?,G==x
        1     0     0     ?     ?          :   ?   :   1;  // PRE==x/?
        ?     1     0     x     ?          :   1   :   1;  // PRE==x
    endtable


endprimitive
//---- END PRIMITIVE DL2C_UDP ----

//---- PRIMITIVE DLE3B_UDP ----
//--------------------------------------------------------------------------
// primitive DLE3B_UDP
// FUNCTION : D LATCH WITH DUAL CLOCK INPUTS ACTIVE HIGH ASYNCHRONOUS PRESET.
//            TWO CLOCKS: E G
//-------------------------------------------------------------------------

primitive DLE3B_UDP (q, d, g, e, p, NOTIFIER_REG);

 output q;
 input  d,              // DATA
        g,              // CLOCK
        e,              // CLEAR ACTIVE HIGH
        p,              // SET ACTIVE HIGH
        NOTIFIER_REG;

 reg    q;

    table
    //  D     G     E     P  NOTIFIER_REG  :   Qt  :   Qt+1
        ?     ?     ?     1     ?          :   ?   :   1;  // active high preset

        ?     1     ?     0     ?          :   ?   :   -;  // latch
        ?     ?     1     0     ?          :   ?   :   -;  // latch

        1     0     0     0     ?          :   ?   :   1;  // transparent
        0     0     0     0     ?          :   ?   :   0;  // transparent

        1     x     ?     0     ?          :   1   :   1;  // o/p mux pessimism
        1     ?     x     0     ?          :   1   :   1;  // o/p mux pessimism
        0     x     ?     0     ?          :   0   :   0;  // o/p mux pessimism
        0     ?     x     0     ?          :   0   :   0;  // o/p mux pessimism

        1     0     0     x     ?          :   ?   :   1;  // PRE==x
        ?     1     ?     x     ?          :   1   :   1;  // PRE==x
        ?     ?     1     x     ?          :   1   :   1;  // PRE==x
        1     0     x     x     ?          :   1   :   1;  // PRE==x
        1     x     0     x     ?          :   1   :   1;  // PRE==x
        1     x     x     x     ?          :   1   :   1;  // PRE==x
    endtable

endprimitive
//---- END PRIMITIVE DLE3B_UDP ----

//---- PRIMITIVE DLE2B_UDP ----
//--------------------------------------------------------------------------
// primitive DLE2B_UDP
// FUNCTION : D LATCH WITH DUAL CLOCK INPUTS ACTIVE HIGH ASYNCHRONOUS CLEAR.
//            TWO CLOCKS: E G
//-------------------------------------------------------------------------

primitive DLE2B_UDP (q, d, e, g, c, NOTIFIER_REG);

 output q;
 input  d,              // DATA
        e,              // CLOCK
        g,              // CLOCK
        c,              // CLEAR ACTIVE HIGH
        NOTIFIER_REG;

 reg    q;

    table
    //  D     E     G     C  NOTIFIER_REG  :   Qt  :   Qt+1
        ?     ?     ?     0     ?          :   ?   :   0;  // active low clear

        ?     ?     1     1     ?          :   ?   :   -;  // latch
        ?     1     ?     1     ?          :   ?   :   -;  // latch

        1     0     0     1     ?          :   ?   :   1;  // transparent
        0     0     0     1     ?          :   ?   :   0;  // transparent

        0     ?     ?     1     ?          :   0   :   0;  // o/p mux pessimism
        1     ?     ?     1     ?          :   1   :   1;  // o/p mux pessimism

        0     ?     ?     x     ?          :   0   :   0;  // CLR==x, o/p mux pessimism
        ?     ?     1     x     ?          :   0   :   0;  // PRE==x, o/p mux pessimism, latch
        ?     1     ?     x     ?          :   0   :   0;  // PRE==x, o/p mux pessimism, latch
        0     0     0     x     ?          :   ?   :   0;  // PRE==x, o/p mux pessimism
    endtable

endprimitive
//---- END PRIMITIVE DLE2B_UDP ----

//---- PRIMITIVE JKFFF ----
//--------------------------------------------------------------------
//-                 primitive  JKFFF  -- falling edge                -
//--------------------------------------------------------------------

primitive JKFFF (Q, J, K, CP, RB, SB, NOTIFIER_REG);
    output Q;
    reg    Q; 
    input  NOTIFIER_REG,
           J,K,
            CP,                                  // Clock.
            RB,                                  // Clear input
            SB;                                  // Set input
// FUNCTION :NEGATIVE EDGE TRIGGERED JK FLIP FLOP, WITH ACTIVE LOW
//           ASYNCHRONOUS CLEAR AND  SET
//           OUTPUT GOES TO X WHEN BOTH CLEAR AND SET ARE ACTIVE
    table
      // J   K   CP  RB   SB       NOTIFIER_REG  : Qtn : Qtn+1
         0   1  (10) 1    1           ?          :  ?  :   - ;    // Output retains the
         0   0  (10) 1    1           ?          :  ?  :   0 ;    // Clocked J and K.
         0   0  (10) x    1           ?          :  ?  :   0 ;    // pessimism
         ?   ?   ?   x    1           ?          :  0  :   0 ;    // pessimism
         1   1  (10) 1    1           ?          :  ?  :   1 ;
         1   1  (10) 1    x           ?          :  ?  :   1 ;    // pessimism
         ?   ?   ?   1    x           ?          :  1  :   1 ;    // pessimis
         1   0  (10) 1    1           ?          :  0  :   1 ;    // Clocked toggle.
         1   0  (10) 1    1           ?          :  1  :   0 ;
         ?   0  (10) x    1           ?          :  1  :   0 ;    //pessimism
         1   ?  (10) 1    x           ?          :  0  :   1 ;
         0   1  (1x) 1    1           ?          :  ?  :   - ;    //possible clocked JK
         0   0  (1x) 1    1           ?          :  0  :   0 ;
         1   1  (1x) 1    1           ?          :  1  :   1 ;
         0   1  (x0) 1    1           ?          :  ?  :   - ;
         0   0  (x0) 1    1           ?          :  0  :   0 ;
         1   1  (x0) 1    1           ?          :  1  :   1 ;
         *   ?   ?   1    1           ?          :  ?  :   - ;    // Insensitive to
         ?   *   ?   1    1           ?          :  ?  :   - ;    // transitions on J and K
         ?   ?   ?   0    1           ?          :  ?  :   0 ;    // Clear
         ?   ?   ?   1    0           ?          :  ?  :   1 ;    // Set.
         ?   ?   ?   0    0           ?          :  ?  :   x ;    // ILLEGAL
         x   1   f   1    1           ?          :  1  :   1 ;
         x   0   f   1    1           ?          :  1  :   0 ;
         0   x   f   1    1           ?          :  0  :   0 ;
         1   x   f   1    1           ?          :  0  :   1 ;
         x   1 (1x)  1    1           ?          :  1  :   1 ;    //possible clocked with
         0   x (1x)  1    1           ?          :  0  :   0 ;    //possible J & K
         x   1 (x0)  1    1           ?          :  1  :   1 ;
         0   x (x0)  1    1           ?          :  0  :   0 ;
         ?   ? (?1)  ?    ?           ?          :  ?  :   - ;
         ?   ? (0x)  ?    ?           ?          :  ?  :   - ;
         ?   ?   ? (?1)   1           ?          :  ?  :   - ;    //ignore changes on set and
         ?   ?   ?   1  (?1)          ?          :  ?  :   - ;    //reset.
         ?   ?   ?   ?    ?           *          :  ?  :   x ;
    endtable
endprimitive
//---- END PRIMITIVE JKFFF ----

//---- PRIMITIVE JKFFR ----
//--------------------------------------------------------------------
//-                   primitive  JKFFR                                -
//--------------------------------------------------------------------
primitive JKFFR (Q, J, K, CP, RB, SB, NOTIFIER_REG);
    output Q;
    reg    Q; 
    input  NOTIFIER_REG,
           J,K,
           CP,                                  // Clock.
           RB,                                  // Clear input
           SB;                                  // Set input
// FUNCTION :POSITIVE EDGE TRIGGERED JK FLIP FLOP, WITH ACTIVE LOW
//           ASYNCHRONOUS CLEAR AND  SET
//           OUTPUT GOES TO x WHEN BOTH CLEAR AND SET ARE ACTIVE
    table
      // J   K  CP  RB   SB        NOTIFIER_REG  : Qtn : Qtn+1
         0   1  (01) 1    1           ?          :  ?  :   - ;    // Output retains the
         0   0  (01) 1    1           ?          :  ?  :   0 ;    // Clocked J and K.
         0   0  (01) x    1           ?          :  ?  :   0 ;    // pessimism
         ?   ?   ?   x    1           ?          :  0  :   0 ;    // pessimism
         1   1  (01) 1    1           ?          :  ?  :   1 ;
         1   1  (01) 1    x           ?          :  ?  :   1 ;    // pessimism
         ?   ?   ?   1    x           ?          :  1  :   1 ;    // pessimism
         1   0  (01) 1    1           ?          :  0  :   1 ;    // Clocked toggle.
         1   0  (01) 1    1           ?          :  1  :   0 ;
         ?   0  (01) x    1           ?          :  1  :   0 ;     //pessimism
         1   ?  (01) 1    x           ?          :  0  :   1 ;
         0   1  (x1) 1    1           ?          :  ?  :   - ;   //possible clocked JK
         0   0  (x1) 1    1           ?          :  0  :   0 ;
         1   1  (x1) 1    1           ?          :  1  :   1 ;
         0   1  (0x) 1    1           ?          :  ?  :   - ;
         0   0  (0x) 1    1           ?          :  0  :   0 ;
         1   1  (0x) 1    1           ?          :  1  :   1 ;
         *   ?   ?   1    1           ?          :  ?  :   - ;    // Insensitive to
         ?   *   ?   1    1           ?          :  ?  :   - ;    // transitions on J and K
         ?   ?   ?   0    1           ?          :  ?  :   0 ;    // Clear
         ?   ?   ?   1    0           ?          :  ?  :   1 ;    // Set.
         ?   ?   ?   0    0           ?          :  ?  :   x ;    // ILLEGAL
         x   1   r   1    1           ?          :  1  :   1 ;
         x   0   r   1    1           ?          :  1  :   0 ;
         0   x   r   1    1           ?          :  0  :   0 ;
         1   x   r   1    1           ?          :  0  :   1 ;
         x   1 (x1)  1    1           ?          :  1  :   1 ;        //possible clocked with
         0   x (x1)  1    1           ?          :  0  :   0 ;        //possible J & K
         x   1 (0x)  1    1           ?          :  1  :   1 ;
         0   x (0x)  1    1           ?          :  0  :   0 ;
         ?   ? (?0)  1    1           ?          :  ?  :   - ;    //ignore falling clock.
         ?   ? (1x)  1    1           ?          :  ?  :   - ;
         ?   ?   ? (?1)   1           ?          :  ?  :   - ;    //ignore changes on set and
         ?   ?   ?   1  (?1)          ?          :  ?  :   - ;    //reset.
         ?   ?   ?   ?    ?           *          :  ?  :   x ;
    endtable
endprimitive
//---- END PRIMITIVE JKFFR ----

//---- PRIMITIVE UDP_MUX2 ----
 // --------------------------------------------------------------------
 // 2-1 MUX  primitive   
 // FUNCTION : when select signal S= 1, A will be selected, S= 0, B will 
 //            be selected; when S=X, if A=B, A will be selected, if A!=B,
 //            X will be the output!
 // --------------------------------------------------------------------
primitive UDP_MUX2 (Q, A, B, SL);
output Q;
input A, B, SL;

// FUNCTION :  TWO TO ONE MULTIPLEXER

    table
    //  A   B   SL  :   Q
        0   0   ?   :   0 ;
        1   1   ?   :   1 ;

        0   ?   1   :   0 ;
        1   ?   1   :   1 ;

        ?   0   0   :   0 ;
        ?   1   0   :   1 ;

    endtable
endprimitive
//---- END PRIMITIVE UDP_MUX2 ----

//---- PRIMITIVE UDPN_MUX2 ----
primitive UDPN_MUX2 (Q, A, B, SL);
output Q;
input A, B, SL;

// FUNCTION :  TWO TO ONE MULTIPLEXER

    table
    //  A   B   SL  :   Q
        0   0   ?   :   1 ;
        1   1   ?   :   0 ;

        0   ?   1   :   1 ;
        1   ?   1   :   0 ;

        ?   0   0   :   1 ;
        ?   1   0   :   0 ;

    endtable
endprimitive
//---- END PRIMITIVE UDPN_MUX2 ----

//---- PRIMITIVE CMA9_primitive ----
//---------------  END OF VERILOG PRIMITIVE SECTION --------------------

primitive CMA9_primitive (Y, D0,DB, D3,S01,S11);
output Y;
input D0,DB, D3,S01,S11;


	table
	// D0   DB   D3   S01  S11 :       Y
	   ?    0    ?    0    ?  :       1;
	   ?    1    ?    ?    1  :       0;
	   ?    0    0    1    ?  :       0;
	   1    1    ?    ?    0  :       1;
	   1    ?    1    ?    0  :       1;
	   ?    0    1    ?    ?  :       1;
	   0    1    ?    ?    ?  :       0;
	   0    ?    0    1    ?  :       0;
	   1    ?    ?    0    0  :       1;
	   ?    ?    0    1    1  :       0;

	endtable
endprimitive
//---- END PRIMITIVE CMA9_primitive ----

//---- PRIMITIVE CMAF_primitive ----
primitive CMAF_primitive (Y, D0, D2,  D3, DB, S01, S11);
output Y;
input D0, D2,  D3, DB, S01, S11;


	table
	// D0   D2   D3   DB   S01  S11       Y
	   0    0    0     ?    ?    ? :    0;
	   1    1    1     ?    ?    ? :    1;
	   0    0    ?     ?    0    0 :    0;
	   1    1    ?     ?    0    0 :    1;
	   0    0    ?     1    ?    ? :    0;
	   1    1    ?     1    ?    ? :    1;
	   0    0    ?     ?    0    ? :    0;
	   1    1    ?     ?    0    ? :    1;
	   ?    0    0     ?    1    1 :    0;
	   ?    1    1     ?    1    1 :    1;
	   ?    0    0     0    ?    ? :    0;
	   ?    1    1     0    ?    ? :    1;
	   ?    0    0     ?    ?    1 :    0;
	   ?    1    1     ?    ?    1 :    1;
	   0    ?    0     ?    1    0 :    0;
	   1    ?    1     ?    1    0 :    1;
	   ?    0    ?     0    0    ? :    0;
	   ?    1    ?     0    0    ? :    1;
	   ?    0    ?     1    ?    1 :    0;
	   ?    1    ?     1    ?    1 :    1;
	   ?    0    ?     ?    0    1 :    0;
	   ?    1    ?     ?    0    1 :    1;
	   ?    ?    0     0    1    ? :    0;
	   ?    ?    1     0    1    ? :    1;
	   0    ?    ?     1    ?    0 :    0;
	   1    ?    ?     1    ?    0 :     1;

	endtable
endprimitive
//---- END PRIMITIVE CMAF_primitive ----

//---- PRIMITIVE CMB7_primitive ----
primitive CMB7_primitive (Y, D0, D1, D2, DB, S00, S01, S11);
output Y;
input D0, D1, D2, DB, S00, S01, S11;


   table
	//D0   D1   D2   DB   S00  S01  S11          Y
	  0    0    0    1    ?    ?    ?  :       0;
	  ?    ?    1    0    ?    ?    ?  :      1;
	  ?    0    ?    1    1    1    0  :      0;
	  ?    1    ?    ?    1    1    0  :      1;
	  0    ?    ?    1    0    ?    0  :      0;
	  0    ?    ?    1    ?    0    0  :      0;
	  1    ?    ?    1    0    ?    0  :      1;
	  1    ?    ?    1    ?    0    0  :      1;
	  ?    ?    ?    1    1    1    1  :      0;
	  ?    ?    ?    0    1    1    ?  :      1;
	  ?    ?    0    0    0    ?    ?  :      0;
	  ?    ?    0    0    ?    0    ?  :      0;
	  ?    ?    0    ?    0    ?    1  :      0;
	  ?    ?    0    ?    ?    0    1  :      0;
	  0    ?    0    ?    0    ?    ?  :      0;
	  0    ?    0    ?    ?    0    ?  :      0;
	  1    ?    1    ?    0    ?    ?  :      1;
	  1    ?    1    ?    ?    0    ?  :      1;
	  ?    ?    1    ?    0    ?    1  :      1;
	  ?    ?    1    ?    ?    0    1  :      1;
	  ?    0    ?    1    1    1    ?  :      0;
	  0    0    ?    1    ?    ?    0  :      0;
	  1    1    ?    1    ?    ?    0  :      1;
	  ?    ?    0    1    ?    ?    1  :      0;
	  1    1    1    ?    ?    ?    0  :      1;

	endtable
endprimitive
//---- END PRIMITIVE CMB7_primitive ----

//---- PRIMITIVE CMBB_primitive ----
primitive CMBB_primitive (Y, D0,D1,DB,D3,S00,S01,S11);
output Y;
input D0,D1,DB,D3,S00,S01,S11;


	table
// D0   D1   DB   D3   S00  S01  S11          Y
	0    0    1    0    ?    ?    ? :        0;
	?    ?    0    1    ?    ?    ? :       1;
	?    ?    0    ?    ?    0    ? :       1;
	?    ?    1    ?    ?    0    1 :       0;
	?    ?    0    ?    0    ?    ? :       1;
	?    ?    1    ?    0    ?    1 :       0;
	0    ?    1    ?    ?    0    0 :       0;
	1    ?    ?    ?    ?    0    0 :       1;
	0    ?    1    ?    0    ?    0 :       0;
	1    ?    ?    ?    0    ?    0 :       1;
	?    0    1    ?    1    1    0 :       0;
	?    1    1    ?    1    1    0 :       1;
	?    ?    ?    0    1    1    1 :       0;
	?    ?    ?    1    1    1    1 :       1;
	?    ?    0    0    1    1    ? :       0;
	?    ?    1    0    ?    ?    1 :       0;
	?    0    ?    0    1    1    ? :       0;
	?    1    ?    1    1    1    ? :       1;
	0    ?    1    ?    0    ?    ? :       0;
	0    0    1    ?    ?    ?    0 :       0;
	1    1    1    ?    ?    ?    0 :       1;
	0    ?    1    ?    ?    0    ? :       0;
	1    1    ?    1    ?    ?    0 :       1;

	endtable
endprimitive
//---- END PRIMITIVE CMBB_primitive ----

//---- PRIMITIVE CMEA_primitive ----
primitive CMEA_primitive (Y, DB,D1,D3,S01,S10,S11);
output Y;
input DB,D1,D3,S01,S10,S11;


	table
// DB   D1   D3   S01  S10  S11          Y
	1     ?    ?    ?   ?    ? :       0;
	0     1    1    ?   ?    ? :       1;
	0     0    ?    1   0    0 :       0;
	0     1    ?    ?   0    0 :       1;
	0     ?    0    1   1    ? :       0;
	0     ?    0    1   ?    1 :       0;
	0     ?    ?    0   ?    ? :       1;
	?     0    0    1   ?    ? :       0;
	0     ?    1    ?   1    ? :       1;
	0     ?    1    ?   ?    1 :       1;

   endtable
endprimitive
//---- END PRIMITIVE CMEA_primitive ----

//---- PRIMITIVE CMEB_primitive ----
primitive CMEB_primitive (Y,D0,D1,DB,D3,S01,S10,S11);
output Y;
input D0,D1,DB,D3,S01,S10,S11;


   table
	// D0   D1   DB   D3   S01  S10  S11          Y
	0   0   1   0   ?   ?   ? :        0;
	1   1   0   1   ?   ?   ? :       1;
	0   ?   ?   ?   0   0   0 :       0;
	1   ?   ?   ?   0   0   0 :       1;
	0   ?   1   ?   ?   0   0 :       0;
	1   ?   1   ?   ?   0   0 :       1;
	?   ?   0   1   1   1   ? :       1;
	?   ?   0   1   1   ?   1 :       1;
	?   0   0   ?   1   0   0 :       0;
	?   1   0   ?   1   0   0 :       1;
	?   ?   ?   0   1   1   ? :       0;
	?   ?   ?   0   1   ?   1 :       0;
	?   ?   1   ?   ?   1   ? :       0;
	?   ?   1   ?   ?   ?   1 :       0;
	?   ?   0   ?   0   1   ? :       1;
	?   0   0   0   1   ?   ? :       0;
	?   1   0   1   1   ?   ? :       1;
	0   0   ?   ?   ?   0   0 :       0;
	1   1   ?   ?   ?   0   0 :       1;
	0   ?   1   ?   ?   ?   ? :       0;
	1   ?   0   ?   0   ?   ? :       1;
	?   ?   0   1   ?   1   ? :       1;
	?   ?   0   1   ?   ?   1 :       1;
	?   ?   0   ?   0   ?   1 :       1;
	0   0   ?   0   1   ?   ? :       0;

	endtable
endprimitive
//---- END PRIMITIVE CMEB_primitive ----

//---- PRIMITIVE CMEE_primitive ----
primitive CMEE_primitive (Y,DB, D1, D2, D3, S01,S10, S11);
output Y;
input DB, D1, D2, D3, S01,S10, S11;


   table
	//DB   D1   D2   D3   S01  S10  S11          Y
	1 0 0 0 ? ? ? :       0;
	0 1 1 1 ? ? ? :       1;
	? 0 ? ? 1 0 0 :       0;
	0 1 ? ? 1 0 0 :       1;
	0 ? ? 0 1 1 ? :       0;
	0 ? ? 1 1 1 ? :       1;
	0 ? ? 0 1 ? 1 :       0;
	0 ? ? 1 1 ? 1 :       1;
	1 ? ? ? ? 0 0 :       0;
	0 ? ? ? 0 0 0 :       1;
	? ? 0 ? 0 ? 1 :       0;
	? ? 1 ? 0 ? 1 :       1;
	? ? 0 ? 0 1 ? :       0;
	? ? 1 ? 0 1 ? :       1;
	1 ? 0 ? ? ? 1 :       0;
	1 ? 1 ? ? ? 1 :       1;
	1 ? 0 ? ? 1 ? :       0;
	1 ? 1 ? ? 1 ? :       1;
	1 ? 0 ? ? ? ? :       0;
	0 ? 1 ? 0 ? ? :       1;
	? ? 0 0 ? 1 ? :       0;
	? ? 1 1 ? 1 ? :       1;
	? ? 0 0 ? ? 1 :       0;
	0 0 ? 0 1 ? ? :       0;
	0 1 ? 1 1 ? ? :       1;
	? ? 1 1 ? ? 1 :       1;
	0 1 ? ? ? 0 0 :       1;
	? 0 0 0 1 ? ? :       0;

   endtable
endprimitive
//---- END PRIMITIVE CMEE_primitive ----

//---- MODULE drive_analog_input ----
/*--------------------------------------------------------------------
 CELL NAME : drive_analog_input
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module drive_analog_input ( parallel_in, serial_out );

  input  [63:0]  parallel_in;
  output         serial_out;

  reg            serial_out=1'bz;
  integer        i;

  always @ ( parallel_in )
  begin
    #0;
    for ( i=0; i<=63; i=i+1 ) begin
      serial_out = parallel_in[i];
      #0;
      serial_out = 1'bx;
      #0;
      if ( i == 63 )
        serial_out = 1'bz;
    end
  end

endmodule
//---- END MODULE drive_analog_input ----

//---- MODULE drive_current_inputs ----
/*--------------------------------------------------------------------
 CELL NAME : drive_current_inputs
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module drive_current_inputs ( volt_vect, resistor_vect, current_vect, av, ac );

  input  [63:0]  volt_vect;
  input  [63:0]  resistor_vect;
  input  [63:0]  current_vect;
  output         av;
  output         ac;

  reg            av = 1'bz;
  reg            ac = 1'bz;

  integer        i, j;
  wire   [63:0]  ac_vect;

  assign ac_vect = ( ( $bitstoreal( resistor_vect ) < 0.01 ) || ( $bitstoreal( resistor_vect ) > 10 ) ) ?
                       64'b0000000000000000000000000000000000000000000000000000000000000000 :
                       $realtobits( $bitstoreal( volt_vect ) - ( $bitstoreal( resistor_vect ) * $bitstoreal( current_vect ) ) );

  always @( ac_vect )
  begin
    #0;
    for ( i = 0; i < 64; i = i+1 ) begin
      ac = ac_vect[i];
      #0;
      ac = 1'bx;
      #0;
    end
    ac = 1'bz;
  end

  always @( volt_vect )
  begin
    #0;
    for ( j = 0; j < 64; j = j+1 ) begin
      av = volt_vect[j];
      #0;
      av = 1'bx;
      #0;
    end
    av = 1'bz;
  end

endmodule
//---- END MODULE drive_current_inputs ----

//---- MODULE drive_differential_inputs ----
/*--------------------------------------------------------------------
 CELL NAME : drive_differential_inputs
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module drive_differential_inputs ( volt_vect, delta_vect, av, ac );

  input  [63:0]  volt_vect;
  input  [63:0]  delta_vect;
  output         av;
  output         ac;

  reg            av = 1'bz;
  reg            ac = 1'bz;

  integer        i, j;
  wire   [63:0]  ac_vect;

  assign ac_vect = $realtobits( $bitstoreal( volt_vect ) - ( $bitstoreal( delta_vect ) ) );

  always @( ac_vect )
  begin
    #0;
    for ( i = 0; i < 64; i = i+1 ) begin
      ac = ac_vect[i];
      #0;
      ac = 1'bx;
      #0;
    end
    ac = 1'bz;
  end

  always @( volt_vect )
  begin
    #0;
    for ( j = 0; j < 64; j = j+1 ) begin
      av = volt_vect[j];
      #0;
      av = 1'bx;
      #0;
    end
    av = 1'bz;
  end

endmodule
//---- END MODULE drive_differential_inputs ----

//---- MODULE drive_varef_out ----
/*--------------------------------------------------------------------
 CELL NAME : drive_varef_out
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module drive_varef_out ( parallel_in, en_out, serial_out );

  input  [63:0]  parallel_in;
  input          en_out;
  output         serial_out;

  reg            serial_out=1'bz;
  integer        i;

  always @ ( parallel_in )
  begin
    if ( en_out == 1'b1 ) begin
      #0;
      for ( i=0; i<=63; i=i+1 ) begin
        serial_out = parallel_in[i];
        #0;
        serial_out = 1'bx;
        #0;
        if ( i == 63 )
          serial_out = 1'bz;
      end
    end
  end

endmodule
//---- END MODULE drive_varef_out ----

//---- MODULE drive_analog_io ----
/*--------------------------------------------------------------------
 CELL NAME : drive_analog_io
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module drive_analog_io ( parallel_in, serial_out );

  input  [63:0]  parallel_in;
  output         serial_out;

  reg            serial_out=1'bz;
  integer        i;

  always @ ( parallel_in )
  begin
    #0;
    for ( i=0; i<=63; i=i+1 ) begin
      serial_out = parallel_in[i];
      #0;
      serial_out = 1'bx;
      #0;
      if ( i == 63 )
        serial_out = 1'bz;
    end
  end

endmodule
//---- END MODULE drive_analog_io ----

//---- MODULE drive_current_monitor ----
/*--------------------------------------------------------------------
 CELL NAME : drive_current_monitor
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module drive_current_monitor ( volt_vect, resistor_vect, current_vect, serial_out );

  input  [63:0]  volt_vect;
  input  [63:0]  resistor_vect;
  input  [63:0]  current_vect;
  output         serial_out;

  reg            serial_out=1'bz;
  integer        i;
  wire   [63:0]  parallel_in;

  assign parallel_in = ( ( $bitstoreal(resistor_vect) < 0.01 ) || ( $bitstoreal(resistor_vect) > 10 ) ) ?
                       64'b0000000000000000000000000000000000000000000000000000000000000000 :
                       $realtobits( $bitstoreal(volt_vect) - ( $bitstoreal(resistor_vect) * $bitstoreal(current_vect) ) );

  always @ ( parallel_in )
  begin
    #0;
    for ( i=0; i<=63; i=i+1 ) begin
      serial_out = parallel_in[i];
      #0;
      serial_out = 1'bx;
      #0;
      if ( i == 63 )
        serial_out = 1'bz;
    end
  end

endmodule
//---- END MODULE drive_current_monitor ----

//---- MODULE drive_temperature_quad ----
/*--------------------------------------------------------------------
 CELL NAME : drive_temperature_quad
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module drive_temperature_quad ( temp_celsius, serial_out );

  input  [63:0]  temp_celsius;
  output         serial_out;

  reg            serial_out=1'bz;
  integer        i;
  wire   [63:0]  parallel_in;

  assign parallel_in = $realtobits( ( $bitstoreal(temp_celsius) + 273.15 ) * ( 2.30258 * 0.000087248 ) );

  always @ ( parallel_in )
  begin
    #0;
    for ( i=0; i<=63; i=i+1 ) begin
      serial_out = parallel_in[i];
      #0;
      serial_out = 1'bx;
      #0;
      if ( i == 63 )
        serial_out = 1'bz;
    end
  end

endmodule
//---- END MODULE drive_temperature_quad ----

//---- MODULE read_analog_input ----
/*--------------------------------------------------------------------
 CELL NAME : read_analog_input
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module read_analog_input ( serial_in, read_enb, parallel_out );

  input          serial_in;
  input          read_enb;
  output [63:0]  parallel_out;

  // instantiate read_analog_io module that is already defined 

  read_analog_io read_analog_io_inst ( .serial_in    ( serial_in    ),
                                       .read_enb     ( read_enb     ),
                                       .parallel_out ( parallel_out )
                                     ); 

endmodule
//---- END MODULE read_analog_input ----

//---- MODULE read_analog_io ----
/*--------------------------------------------------------------------
 CELL NAME : read_analog_io
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module read_analog_io ( serial_in, read_enb, parallel_out );

  input          serial_in;
  input          read_enb;
  output [63:0]  parallel_out;

  reg    [63:0]  parallel_out;
  integer        i=0;
  
  always @ ( serial_in )
  begin
    if ( read_enb == 1'b0 ) begin
      if ( serial_in !== 1'bz && serial_in !== 1'bx && i < 64 ) begin
        parallel_out [i] = serial_in;  
        i = i + 1;
        if ( i == 64 )
          i = 0;
        if (i==0 && (parallel_out[0] === 1'b0 || parallel_out[0] === 1'b1)) begin
        `ifdef WARNING_MSGS_ON
          $display("FUSION: got sampled value %h",parallel_out);
         `endif
        end
      end
    end
  end

endmodule
//---- END MODULE read_analog_io ----

//---- MODULE AND2 ----
/*--------------------------------------------------------------------
 CELL NAME : AND2
 CELL TYPE : comb
 CELL LOGIC : Y = A & B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND2(Y,A,B);
 input A,B;
 output Y;

 and      U2(Y, A, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND2 ----

//---- MODULE AND2A ----
/*--------------------------------------------------------------------
 CELL NAME : AND2A
 CELL TYPE : comb
 CELL LOGIC : Y = !A & B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND2A(Y,A,B);
 input A,B;
 output Y;

 not	INV_0(A_, A);
 and      U5(Y, A_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND2A ----

//---- MODULE AND2B ----
/*--------------------------------------------------------------------
 CELL NAME : AND2B
 CELL TYPE : comb
 CELL LOGIC : Y = !A & !B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND2B(Y,A,B);
 input A,B;
 output Y;

 not	INV_1(A_, A);
 not	INV_2(B_, B);
 and      U8(Y, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND2B ----

//---- MODULE AND3 ----
/*--------------------------------------------------------------------
 CELL NAME : AND3
 CELL TYPE : comb
 CELL LOGIC : Y = A & B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U15(NET_0_0, A, B);
 and      U16(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND3 ----

//---- MODULE AND3A ----
/*--------------------------------------------------------------------
 CELL NAME : AND3A
 CELL TYPE : comb
 CELL LOGIC : Y = !A & B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND3A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_4(A_, A);
 and      U20(NET_0_0, A_, B);
 and      U21(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND3A ----

//---- MODULE AND3B ----
/*--------------------------------------------------------------------
 CELL NAME : AND3B
 CELL TYPE : comb
 CELL LOGIC : Y = !A & !B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND3B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_5(A_, A);
 not	INV_6(B_, B);
 and      U25(NET_0_0, A_, B_);
 and      U26(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND3B ----

//---- MODULE AND3C ----
/*--------------------------------------------------------------------
 CELL NAME : AND3C
 CELL TYPE : comb
 CELL LOGIC : Y = !A & !B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND3C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_7(A_, A);
 not	INV_8(B_, B);
 not	INV_9(C_, C);
 and      U30(NET_0_0, A_, B_);
 and      U31(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND3C ----

//---- MODULE AO12 ----
/*--------------------------------------------------------------------
 CELL NAME : AO12
 CELL TYPE : comb
 CELL LOGIC : Y = !A & B + !A & !C + A & !B & C + B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO12(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_13(A_, A);
 not	INV_14(B_, B);
 not	INV_15(C_, C);
 UDP_MUX2   U56(NET_0_5, B, NET_0_3, C_);
 and      U59(NET_0_3, A, B_);
 or       U60(Y, NET_0_5, NET_0_2);
 and      U63(NET_0_0, A_, B);
 or       U64(NET_0_2, NET_0_0, NET_0_1);
 and      U66(NET_0_1, A_, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO12 ----

//---- MODULE AO13 ----
/*--------------------------------------------------------------------
 CELL NAME : AO13
 CELL TYPE : comb
 CELL LOGIC : Y = A & B + A & !C + B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO13(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_16(C_, C);
 and      U71(NET_0_0, A, B);
 or       U72(NET_0_2, NET_0_0, NET_0_1);
 and      U74(NET_0_1, A, C_);
 or       U75(Y, NET_0_2, NET_0_3);
 and      U77(NET_0_3, B, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO13 ----

//---- MODULE AO14 ----
/*--------------------------------------------------------------------
 CELL NAME : AO14
 CELL TYPE : comb
 CELL LOGIC : Y = A & B + A & !C + B & !C + !A & !B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO14(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_17(A_, A);
 not	INV_18(B_, B);
 not	INV_19(C_, C);
 and      U82(NET_0_5, A_, B_);
 UDP_MUX2   U83(NET_0_4, NET_0_5, B, C);
 or       U85(Y, NET_0_4, NET_0_2);
 and      U88(NET_0_0, A, B);
 or       U89(NET_0_2, NET_0_0, NET_0_1);
 and      U91(NET_0_1, A, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO14 ----

//---- MODULE AO15 ----
/*--------------------------------------------------------------------
 CELL NAME : AO15
 CELL TYPE : comb
 CELL LOGIC : Y = A & !B & C + !A & B & C + !A & !B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO15(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_20(A_, A);
 not	INV_21(B_, B);
 not	INV_22(C_, C);
 and      U96(NET_0_0, A, B_);
 UDP_MUX2   U97(NET_0_4, NET_0_0, NET_0_5, C);
 and      U100(NET_0_5, A_, B_);
 or       U101(Y, NET_0_4, NET_0_3);
 and      U104(NET_0_2, A_, B);
 and      U105(NET_0_3, NET_0_2, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO15 ----

//---- MODULE AO16 ----
/*--------------------------------------------------------------------
 CELL NAME : AO16
 CELL TYPE : comb
 CELL LOGIC : Y = A & B & !C + !A & !B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO16(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_23(A_, A);
 not	INV_24(B_, B);
 not	INV_25(C_, C);
 and      U109(NET_0_0, A, B);
 UDP_MUX2   U110(Y, NET_0_0, NET_0_2, C_);
 and      U113(NET_0_2, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO16 ----

//---- MODULE AO17 ----
/*--------------------------------------------------------------------
 CELL NAME : AO17
 CELL TYPE : comb
 CELL LOGIC : Y = A & B & C + !A & B & !C + !A & !B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO17(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_26(A_, A);
 not	INV_27(B_, B);
 not	INV_28(C_, C);
 and      U118(NET_0_5, A_, B_);
 UDP_MUX2   U119(NET_0_4, NET_0_5, NET_0_2, C);
 and      U122(NET_0_2, A_, B);
 or       U123(Y, NET_0_4, NET_0_1);
 and      U126(NET_0_0, A, B);
 and      U127(NET_0_1, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO17 ----

//---- MODULE AO18 ----
/*--------------------------------------------------------------------
 CELL NAME : AO18
 CELL TYPE : comb
 CELL LOGIC : Y = !A & B + !A & !C + B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO18(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_29(A_, A);
 not	INV_30(C_, C);
 and      U132(NET_0_0, A_, B);
 or       U133(NET_0_2, NET_0_0, NET_0_1);
 and      U135(NET_0_1, A_, C_);
 or       U136(Y, NET_0_2, NET_0_3);
 and      U138(NET_0_3, B, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO18 ----

//---- MODULE AO1 ----
/*--------------------------------------------------------------------
 CELL NAME : AO1
 CELL TYPE : comb
 CELL LOGIC : Y = (A & B) + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U142(NET_0_0, A, B);
 or       U143(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1 ----

//---- MODULE AO1A ----
/*--------------------------------------------------------------------
 CELL NAME : AO1A
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & B) + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_31(A_, A);
 and      U147(NET_0_0, A_, B);
 or       U148(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1A ----

//---- MODULE AO1B ----
/*--------------------------------------------------------------------
 CELL NAME : AO1B
 CELL TYPE : comb
 CELL LOGIC : Y = (A & B) + !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_32(C_, C);
 and      U152(NET_0_0, A, B);
 or       U153(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1B ----

//---- MODULE AO1C ----
/*--------------------------------------------------------------------
 CELL NAME : AO1C
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & B) + !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_33(A_, A);
 not	INV_34(C_, C);
 and      U157(NET_0_0, A_, B);
 or       U158(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1C ----

//---- MODULE AO1D ----
/*--------------------------------------------------------------------
 CELL NAME : AO1D
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & !B) + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1D(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_35(A_, A);
 not	INV_36(B_, B);
 and      U162(NET_0_0, A_, B_);
 or       U163(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1D ----

//---- MODULE AO1E ----
/*--------------------------------------------------------------------
 CELL NAME : AO1E
 CELL TYPE : comb
 CELL LOGIC : Y = !A & !B + !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1E(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_37(A_, A);
 not	INV_38(B_, B);
 not	INV_39(C_, C);
 and      U167(NET_0_0, A_, B_);
 or       U168(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1E ----

//---- MODULE AOI1 ----
/*--------------------------------------------------------------------
 CELL NAME : AOI1
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U192(NET_0_0, A, B);
 nor      U193(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI1 ----

//---- MODULE AOI1A ----
/*--------------------------------------------------------------------
 CELL NAME : AOI1A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_44(A_, A);
 and      U197(NET_0_0, A_, B);
 nor      U198(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI1A ----

//---- MODULE AOI1B ----
/*--------------------------------------------------------------------
 CELL NAME : AOI1B
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B + !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI1B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_45(C_, C);
 and      U202(NET_0_0, A, B);
 nor      U203(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI1B ----

//---- MODULE AOI1C ----
/*--------------------------------------------------------------------
 CELL NAME : AOI1C
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI1C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_46(A_, A);
 not	INV_47(B_, B);
 and      U207(NET_0_0, A_, B_);
 nor      U208(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI1C ----

//---- MODULE AOI1D ----
/*--------------------------------------------------------------------
 CELL NAME : AOI1D
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B + !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI1D(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_48(A_, A);
 not	INV_49(B_, B);
 not	INV_50(C_, C);
 and      U212(NET_0_0, A_, B_);
 nor      U213(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI1D ----

//---- MODULE AOI5 ----
/*--------------------------------------------------------------------
 CELL NAME : AOI5
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B & C + A & !B & !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI5(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_54(A_, A);
 not	INV_55(B_, B);
 not	INV_56(C_, C);
 and      U237(NET_0_0, A_, B);
 UDPN_MUX2  U238(Y, NET_0_0, NET_0_2, C);
 and      U241(NET_0_2, A, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI5 ----

//---- MODULE AX1 ----
/*--------------------------------------------------------------------
 CELL NAME : AX1
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & B) ^ C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_57(A_, A);
 and      U245(NET_0_0, A_, B);
 xor      U246(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1 ----

//---- MODULE AX1A ----
/*--------------------------------------------------------------------
 CELL NAME : AX1A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_58(A_, A);
 and      U250(NET_0_0, A_, B);
 xnor     U251(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1A ----

//---- MODULE AX1B ----
/*--------------------------------------------------------------------
 CELL NAME : AX1B
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & !B) ^ C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_59(A_, A);
 not	INV_60(B_, B);
 and      U255(NET_0_0, A_, B_);
 xor      U256(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1B ----

//---- MODULE AX1C ----
/*--------------------------------------------------------------------
 CELL NAME : AX1C
 CELL TYPE : comb
 CELL LOGIC : Y = (A & B) ^ C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U260(NET_0_0, A, B);
 xor      U261(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1C ----

//---- MODULE AX1D ----
/*--------------------------------------------------------------------
 CELL NAME : AX1D
 CELL TYPE : comb
 CELL LOGIC : Y = !((!A & !B) ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1D(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_61(A_, A);
 not	INV_62(B_, B);
 and      U265(NET_0_0, A_, B_);
 xnor     U266(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1D ----

//---- MODULE AX1E ----
/*--------------------------------------------------------------------
 CELL NAME : AX1E
 CELL TYPE : comb
 CELL LOGIC : Y = !((A & B) ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1E(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U270(NET_0_0, A, B);
 xnor     U271(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1E ----

//---- MODULE AXO1 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO1
 CELL TYPE : comb
 CELL LOGIC : Y = A & B + (B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_63(B_, B);
 not	INV_64(C_, C);
 and      U275(NET_0_1_XOR_REXT, B, C_);
 or       U276(Y, NET_0_1_XOR_REXT, NET_0_1);
 UDP_MUX2   U278(NET_0_1, C, A, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO1 ----

//---- MODULE AXO2 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO2
 CELL TYPE : comb
 CELL LOGIC : Y = !A & B + (B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO2(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_65(A_, A);
 not	INV_66(B_, B);
 not	INV_67(C_, C);
 and      U283(NET_0_1_XOR_REXT, B, C_);
 or       U284(Y, NET_0_1_XOR_REXT, NET_0_1);
 UDP_MUX2   U286(NET_0_1, C, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO2 ----

//---- MODULE AXO3 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO3
 CELL TYPE : comb
 CELL LOGIC : Y = A & !B + (B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_68(B_, B);
 not	INV_69(C_, C);
 and      U291(NET_0_1_XOR_LEXT, B_, C);
 or       U292(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U294(NET_0_1, A, C_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO3 ----

//---- MODULE AXO5 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO5
 CELL TYPE : comb
 CELL LOGIC : Y =  !A & B + (!B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO5(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_70(A_, A);
 not	INV_71(B_, B);
 not	INV_72(C_, C);
 and      U299(NET_0_1_XOR_LEXT, B, C);
 or       U300(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U302(NET_0_1, A_, C_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO5 ----

//---- MODULE AXO6 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO6
 CELL TYPE : comb
 CELL LOGIC : Y =  A & !B + (!B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO6(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_73(B_, B);
 not	INV_74(C_, C);
 and      U307(NET_0_1_XOR_REXT, B_, C_);
 or       U308(Y, NET_0_1_XOR_REXT, NET_0_1);
 UDP_MUX2   U310(NET_0_1, C, A, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO6 ----

//---- MODULE AXO7 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO7
 CELL TYPE : comb
 CELL LOGIC : Y =  !A & !B + (B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO7(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_75(A_, A);
 not	INV_76(B_, B);
 not	INV_77(C_, C);
 and      U315(NET_0_1_XOR_LEXT, B_, C);
 or       U316(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U318(NET_0_1, A_, C_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO7 ----

//---- MODULE AXOI1 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI1
 CELL TYPE : comb
 CELL LOGIC : Y =  !(A & B + (B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_78(B_, B);
 not	INV_79(C_, C);
 and      U323(NET_0_1_XOR_REXT, B, C_);
 nor      U324(Y, NET_0_1_XOR_REXT, NET_0_1);
 UDP_MUX2   U326(NET_0_1, C, A, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI1 ----

//---- MODULE AXOI2 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI2
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B + (B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI2(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_80(A_, A);
 not	INV_81(B_, B);
 not	INV_82(C_, C);
 and      U331(NET_0_1_XOR_REXT, B, C_);
 nor      U332(Y, NET_0_1_XOR_REXT, NET_0_1);
 UDP_MUX2   U334(NET_0_1, C, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI2 ----

//---- MODULE AXOI3 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI3
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & !B + (B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_83(B_, B);
 not	INV_84(C_, C);
 and      U339(NET_0_1_XOR_LEXT, B_, C);
 nor      U340(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U342(NET_0_1, A, C_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI3 ----

//---- MODULE AXOI4 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI4
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B + (!B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI4(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_85(B_, B);
 not	INV_86(C_, C);
 and      U347(NET_0_1_XOR_LEXT, B, C);
 nor      U348(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U350(NET_0_1, A, C_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI4 ----

//---- MODULE AXOI5 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI5
 CELL TYPE : comb
 CELL LOGIC : Y =  !(!A & B + (!B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI5(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_87(A_, A);
 not	INV_88(B_, B);
 not	INV_89(C_, C);
 and      U355(NET_0_1_XOR_LEXT, B, C);
 nor      U356(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U358(NET_0_1, A_, C_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI5 ----

//---- MODULE AXOI7 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI7
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B + (B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI7(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_90(A_, A);
 not	INV_91(B_, B);
 not	INV_92(C_, C);
 and      U363(NET_0_1_XOR_LEXT, B_, C);
 nor      U364(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U366(NET_0_1, A_, C_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI7 ----

//---- MODULE BIBUF ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U370(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF ----

//---- MODULE BIBUF_F_12 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_12(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U373(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_12 ----

//---- MODULE BIBUF_F_12D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_12D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_12D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U376(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_12D ----

//---- MODULE BIBUF_F_12U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_12U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_12U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U379(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_12U ----

//---- MODULE BIBUF_F_16 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_16(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U382(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_16 ----

//---- MODULE BIBUF_F_16D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_16D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_16D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U385(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_16D ----

//---- MODULE BIBUF_F_16U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_16U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_16U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U388(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_16U ----

//---- MODULE BIBUF_F_24 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_24(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U391(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_24 ----

//---- MODULE BIBUF_F_24D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_24D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_24D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U394(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_24D ----

//---- MODULE BIBUF_F_24U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_24U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_24U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U397(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_24U ----

//---- MODULE BIBUF_F_8 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_8(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U400(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_8 ----

//---- MODULE BIBUF_F_8D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_8D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_8D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U403(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_8D ----

//---- MODULE BIBUF_F_8U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_8U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_8U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U406(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_8U ----

//---- MODULE BIBUF_GTLP25 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_GTLP25
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_GTLP25(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U409(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_GTLP25 ----

//---- MODULE BIBUF_GTLP33 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_GTLP33
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_GTLP33(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U412(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_GTLP33 ----

//---- MODULE BIBUF_HSTL_I ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_HSTL_I
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_HSTL_I(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U415(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_HSTL_I ----

//---- MODULE BIBUF_LVCMOS15 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS15
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS15(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U418(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS15 ----

//---- MODULE BIBUF_LVCMOS15D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS15D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS15D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U421(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS15D ----

//---- MODULE BIBUF_LVCMOS15U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS15U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS15U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U424(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS15U ----

//---- MODULE BIBUF_LVCMOS18 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS18
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS18(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U427(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS18 ----

//---- MODULE BIBUF_LVCMOS18D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS18D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS18D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U430(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS18D ----

//---- MODULE BIBUF_LVCMOS18U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS18U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS18U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U433(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS18U ----

//---- MODULE BIBUF_LVCMOS25 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS25
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS25(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U436(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS25 ----

//---- MODULE BIBUF_LVCMOS25D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS25D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS25D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U439(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS25D ----

//---- MODULE BIBUF_LVCMOS25U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS25U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS25U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U442(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS25U ----

//---- MODULE BIBUF_LVCMOS33 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS33
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS33(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U2(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
        (D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS33 ----

//---- MODULE BIBUF_LVCMOS33D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS33D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS33D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U5(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
        (D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS33D ----

//---- MODULE BIBUF_LVCMOS33U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS33U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS33U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U8(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
        (D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS33U ----

//---- MODULE BIBUF_LVCMOS5 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS5
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS5(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U445(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS5 ----

//---- MODULE BIBUF_LVCMOS5D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS5D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS5D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U448(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS5D ----

//---- MODULE BIBUF_LVCMOS5U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS5U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS5U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U451(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS5U ----

//---- MODULE BIBUF_LVDS ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVDS
 CELL TYPE : comb
 CELL LOGIC : PADP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVDS(Y,PADP,PADN,D,E);
 input D,E;
 inout PADP,PADN;
 output Y;
 reg NOTIFY_REG;
 reg temp;

   bufif1   U89(PADP, D, E);
   not      U88(D_tmp, D);
   bufif1   U87(PADN, D_tmp, E);
   pmos     U86(Y,temp,1'b0);

   always @(PADP or PADN) begin
     if ((PADP == 1'b1) && (PADN == 1'b0))
        temp = 1'b1;
     else if ((PADP == 1'b0) && (PADN == 1'b1))
        temp = 1'b0;
     else
        temp = 1'bx;
    end


      specify

	specparam tpdLH_E_to_PADP = ( 0.0:0.0:0.0 );
	specparam tpdHL_E_to_PADP = ( 0.0:0.0:0.0 );
        specparam tpdLZ_E_to_PADP = ( 0.1:0.1:0.1 );
        specparam tpdZL_E_to_PADP = ( 0.1:0.1:0.1 );
        specparam tpdHZ_E_to_PADP = ( 0.1:0.1:0.1 );
        specparam tpdZH_E_to_PADP = ( 0.1:0.1:0.1 );
	specparam tpdLH_E_to_PADN = ( 0.0:0.0:0.0 );
	specparam tpdHL_E_to_PADN = ( 0.0:0.0:0.0 );
        specparam tpdLZ_E_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdZL_E_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdHZ_E_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdZH_E_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdLH_D_to_PADP = ( 0.1:0.1:0.1 );
        specparam tpdHL_D_to_PADP = ( 0.1:0.1:0.1 );
        specparam tpdLH_D_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdHL_D_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdLH_PADP_to_Y = ( 0.1:0.1:0.1 );
        specparam tpdHL_PADP_to_Y = ( 0.1:0.1:0.1 );
        specparam tpdLH_PADN_to_Y = ( 0.1:0.1:0.1 );
        specparam tpdHL_PADN_to_Y = ( 0.1:0.1:0.1 );
        specparam MacroType = "comb";

        //pin to pin path delay 

        //if(~D)
        ( E => PADP ) = ( tpdLH_E_to_PADP,tpdHL_E_to_PADP,tpdLZ_E_to_PADP,tpdZH_E_to_PADP,tpdHZ_E_to_PADP,tpdZL_E_to_PADP );
        ( E => PADN ) = ( tpdLH_E_to_PADN,tpdHL_E_to_PADN,tpdLZ_E_to_PADN,tpdZH_E_to_PADN,tpdHZ_E_to_PADN,tpdZL_E_to_PADN );

        ( D => PADP ) = ( tpdLH_D_to_PADP,tpdHL_D_to_PADP );
        ( D => PADN ) = ( tpdLH_D_to_PADN,tpdHL_D_to_PADN );

        ( D => Y )    = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
        ( E => Y )    = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
        ( PADP => Y ) = ( tpdLH_PADP_to_Y, tpdHL_PADP_to_Y );
        ( PADN => Y ) = ( tpdLH_PADN_to_Y, tpdHL_PADN_to_Y );

        $width( negedge PADP, 0.0, 0, NOTIFY_REG );
        $width( posedge PADP, 0.0, 0, NOTIFY_REG );
        $width( negedge PADN, 0.0, 0, NOTIFY_REG );
        $width( posedge PADN, 0.0, 0, NOTIFY_REG );
        $width( negedge D, 0.0, 0, NOTIFY_REG );
        $width( posedge D, 0.0, 0, NOTIFY_REG );
        $width( negedge E, 0.0, 0, NOTIFY_REG );
        $width( posedge E, 0.0, 0, NOTIFY_REG );


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVDS ----

//---- MODULE BIBUF_PCI ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_PCI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_PCI(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U454(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_PCI ----

//---- MODULE BIBUF_PCIX ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_PCIX
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_PCIX(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U457(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_PCIX ----

//---- MODULE BIBUF_SSTL2_I ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_SSTL2_I
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_SSTL2_I(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U460(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_SSTL2_I ----

//---- MODULE BIBUF_SSTL2_II ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_SSTL2_II
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_SSTL2_II(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U463(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_SSTL2_II ----

//---- MODULE BIBUF_SSTL3_I ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_SSTL3_I
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_SSTL3_I(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U466(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_SSTL3_I ----

//---- MODULE BIBUF_SSTL3_II ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_SSTL3_II
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_SSTL3_II(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U469(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_SSTL3_II ----

//---- MODULE BIBUF_S_12 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_12(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U472(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_12 ----

//---- MODULE BIBUF_S_12D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_12D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_12D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U475(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_12D ----

//---- MODULE BIBUF_S_12U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_12U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_12U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U478(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_12U ----

//---- MODULE BIBUF_S_16 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_16(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U481(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_16 ----

//---- MODULE BIBUF_S_16D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_16D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_16D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U484(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_16D ----

//---- MODULE BIBUF_S_16U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_16U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_16U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U487(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_16U ----

//---- MODULE BIBUF_S_24 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_24(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U490(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_24 ----

//---- MODULE BIBUF_S_24D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_24D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_24D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U493(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_24D ----

//---- MODULE BIBUF_S_24U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_24U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_24U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U496(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_24U ----

//---- MODULE BIBUF_S_8 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_8(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U499(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_8 ----

//---- MODULE BIBUF_S_8D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_8D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_8D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U502(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_8D ----

//---- MODULE BIBUF_S_8U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_8U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_8U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U505(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_8U ----

//---- MODULE CLKBUF ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf    BUF_U_00(Y,PAD);

       specify

                specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
                specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
                specparam MacroType = "comb";

                //pin to pin path delay

                (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF ----

//---- MODULE CLKBUF_GTLP25 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_GTLP25
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_GTLP25(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_GTLP25 ----

//---- MODULE CLKBUF_GTLP33 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_GTLP33
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_GTLP33(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_GTLP33 ----

//---- MODULE CLKBUF_HSTL_I ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_HSTL_I
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_HSTL_I(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_HSTL_I ----

//---- MODULE CLKBUF_LVCMOS15 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVCMOS15
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVCMOS15(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVCMOS15 ----

//---- MODULE CLKBUF_LVCMOS18 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVCMOS18
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVCMOS18(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVCMOS18 ----

//---- MODULE CLKBUF_LVCMOS25 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVCMOS25
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVCMOS25(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVCMOS25 ----

//---- MODULE CLKBUF_LVCMOS33 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVCMOS33
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVCMOS33(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

      specify

        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVCMOS33 ----

//---- MODULE CLKBUF_LVCMOS5 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVCMOS5
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVCMOS5(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVCMOS5 ----

//---- MODULE CLKBUF_LVDS ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVDS
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVDS (PADP,PADN,Y);
  
    input PADP,PADN;
    output Y;
 reg NOTIFY_REG;

    reg temp;

    pmos p1(Y,temp,1'b0);
    always @(PADP or PADN) begin

    if ((PADP == 1'b1) && (PADN == 1'b0))
       temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
       temp = 1'b0;
    else
       temp = 1'bx;
    end


    specify

         specparam   LibName       = "fusion";
         specparam   InputLoad$PADP = 0;
         specparam   InputLoad$PADN = 0;
         specparam   OutputLoad$Y  = 0;

         specparam   MacroType = "clkbuf_lvds";


        (PADP => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
          (PADN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge PADP, 0.0, 0, NOTIFY_REG);
         $width(posedge PADP, 0.0, 0, NOTIFY_REG);
         $width(negedge PADN, 0.0, 0, NOTIFY_REG);
         $width(posedge PADN, 0.0, 0, NOTIFY_REG);


    endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVDS ----

//---- MODULE CLKBUF_LVPECL ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVPECL
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVPECL (PADP,PADN,Y);
`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif
  
    input PADP,PADN;
    output Y;
 reg NOTIFY_REG;

    buf b1(Y, PADP);

    always @(PADP or PADN) begin
       if (PADP != ~PADN) begin
            if ( WARNING_MSGS_ON )
        $display(" -- Error: two inputs should be complement with each other!\n");
        //$finish;
       end
    end

    specify

         specparam   LibName       = "fusion";
         specparam   InputLoad$PADP = 0;
         specparam   InputLoad$PADN = 0;
         specparam   OutputLoad$Y  = 0;

         specparam   MacroType = "clkbuf_lvpecl";


        (PADP => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
          (PADN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge PADP, 0.0, 0, NOTIFY_REG);
         $width(posedge PADP, 0.0, 0, NOTIFY_REG);
         $width(negedge PADN, 0.0, 0, NOTIFY_REG);
         $width(posedge PADN, 0.0, 0, NOTIFY_REG);


    endspecify

endmodule


`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVPECL ----

//---- MODULE CLKBUF_PCI ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_PCI
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_PCI(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_PCI ----

//---- MODULE CLKBUF_PCIX ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_PCIX
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_PCIX(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_PCIX ----

//---- MODULE CLKBUF_SSTL2_I ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_SSTL2_I
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_SSTL2_I(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_SSTL2_I ----

//---- MODULE CLKBUF_SSTL2_II ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_SSTL2_II
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_SSTL2_II(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_SSTL2_II ----

//---- MODULE CLKBUF_SSTL3_I ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_SSTL3_I
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_SSTL3_I(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_SSTL3_I ----

//---- MODULE CLKBUF_SSTL3_II ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_SSTL3_II
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_SSTL3_II(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_SSTL3_II ----

//---- MODULE DFI0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0(CLK, QN,D);
 input D,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0 ----

//---- MODULE DFI0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0C0(CLR, CLK, QN,D);
 input D,CLR,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,CLR, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,CLR);
       buf U_c2 (Enable02, CLR);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(negedge CLK, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0C0 ----

//---- MODULE DFI0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0C1(CLR, CLK, QN,D);
 input D,CLR,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(q_tmp, D,CLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(negedge CLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0C1 ----

//---- MODULE DFI0E0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E0(E, CLK, QN,D);
 input D,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,VCC_0, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I3 (_E0, E);
      buf U_c0 (Enable01,_E0);
      buf U_c2 (Enable02, _E0);
      buf U_c4 (Enable04, _E0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK,  0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E0 ----

//---- MODULE DFI0E0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E0C0(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,CLR, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, CLR);
      and U_c2 (Enable02, _E0, CLR);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E0C0 ----

//---- MODULE DFI0E0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E0C1(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(q_tmp, D,CLK,CLR_0, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _CLR0);
      and U_c2 (Enable02, _E0, _CLR0);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E0C1 ----

//---- MODULE DFI0E0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E0P0(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, PRE);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E0P0 ----

//---- MODULE DFI0E0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E0P1(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _PRE0);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E0P1 ----

//---- MODULE DFI0E1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E1(E, CLK, QN,D);
 input D,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(q_tmp, D,CLK,VCC_0, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      buf U_c0 (Enable01,E);
      buf U_c2 (Enable02, E);
      buf U_c4 (Enable04, E);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK,  0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E1 ----

//---- MODULE DFI0E1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E1C0(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(q_tmp, D,CLK,CLR, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, CLR);
      and U_c2 (Enable02, E, CLR);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E1C0 ----

//---- MODULE DFI0E1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E1C1(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(E_0, E);

 Dffpf DF_0(q_tmp, D,CLK,CLR_0, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, _CLR0);
      and U_c2 (Enable02, E, _CLR0);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E1C1 ----

//---- MODULE DFI0E1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E1P0(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, PRE);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E1P0 ----

//---- MODULE DFI0E1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E1P1(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(E_0, E);

 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, _PRE0);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E1P1 ----

//---- MODULE DFI0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0P0(PRE, CLK, QN,D);
 input D,PRE,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, PRE);       buf U_c4 (Enable04, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0P0 ----

//---- MODULE DFI0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0P1(PRE, CLK, QN,D);
 input D,PRE,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0P1 ----

//---- MODULE DFI0P1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0P1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, CLR=CLR, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0P1C1(PRE, CLR, CLK, QN,D);
 input D,PRE,CLR,CLK;
 output QN;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(q_tmp, D,CLK,CLR_0, PRE_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, _CLR0, _PRE0);
       buf U_c2 (Enable02, _CLR0);
       buf U_c4 (Enable04, _PRE0);
      and U_c6 (Enable05, _CLR0, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& ~CLR,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);
	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0P1C1 ----

//---- MODULE DFI1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1(CLK, QN,D);
 input D,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1 ----

//---- MODULE DFI1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1C0(CLR, CLK, QN,D);
 input D,CLR,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,CLR, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,CLR);
       buf U_c2 (Enable02, CLR);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge CLK, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1C0 ----

//---- MODULE DFI1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1C1(CLR, CLK, QN,D);
 input D,CLR,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(q_tmp, D,CLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge CLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1C1 ----

//---- MODULE DFI1E0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E0(E, CLK, QN,D);
 input D,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,VCC_0, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I3 (_E0, E);
      buf U_c0 (Enable01,_E0);
      buf U_c2 (Enable02, _E0);
      buf U_c4 (Enable04, _E0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK,  0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E0 ----

//---- MODULE DFI1E0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E0C0(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,CLR, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, CLR);
      and U_c2 (Enable02, _E0, CLR);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E0C0 ----

//---- MODULE DFI1E0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E0C1(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(q_tmp, D,CLK,CLR_0, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _CLR0);
      and U_c2 (Enable02, _E0, _CLR0);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E0C1 ----

//---- MODULE DFI1E0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E0P0(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, PRE);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E0P0 ----

//---- MODULE DFI1E0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E0P1(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _PRE0);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E0P1 ----

//---- MODULE DFI1E1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E1(E, CLK, QN,D);
 input D,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(q_tmp, D,CLK,VCC_0, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,E);
      buf U_c2 (Enable02, E);
      buf U_c4 (Enable04, E);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK,  0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E1 ----

//---- MODULE DFI1E1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E1C0(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(q_tmp, D,CLK,CLR, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, CLR);
      and U_c2 (Enable02, E, CLR);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E1C0 ----

//---- MODULE DFI1E1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E1C1(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(E_0, E);

 Dffpr DF_0(q_tmp, D,CLK,CLR_0, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, _CLR0);
      and U_c2 (Enable02, E, _CLR0);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E1C1 ----

//---- MODULE DFI1E1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E1P0(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, PRE);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E1P0 ----

//---- MODULE DFI1E1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E1P1(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(E_0, E);

 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, _PRE0);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E1P1 ----

//---- MODULE DFI1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1P0(PRE, CLK, QN,D);
 input D,PRE,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, PRE);       buf U_c4 (Enable04, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1P0 ----

//---- MODULE DFI1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1P1(PRE, CLK, QN,D);
 input D,PRE,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1P1 ----

//---- MODULE DFI1P1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1P1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, CLR=CLR, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1P1C1(PRE, CLR, CLK, QN,D);
 input D,PRE,CLR,CLK;
 output QN;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(q_tmp, D,CLK,CLR_0, PRE_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, _CLR0, _PRE0);
       buf U_c2 (Enable02, _CLR0);
       buf U_c4 (Enable04, _PRE0);
      and U_c6 (Enable05, _CLR0, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& ~CLR,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);
	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1P1C1 ----

//---- MODULE DFN0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0(CLK, Q,D);
 input D,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0 ----

//---- MODULE DFN0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0C0(CLR, CLK, Q,D);
 input D,CLR,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,CLR, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,CLR);
       buf U_c2 (Enable02, CLR);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(negedge CLK, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0C0 ----

//---- MODULE DFN0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0C1(CLR, CLK, Q,D);
 input D,CLR,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(Q, D,CLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(negedge CLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0C1 ----

//---- MODULE DFN0E0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E0(E, CLK, Q,D);
 input D,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,VCC_0, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I3 (_E0, E);
      buf U_c0 (Enable01,_E0);
      buf U_c2 (Enable02, _E0);
      buf U_c4 (Enable04, _E0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK,  0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E0 ----

//---- MODULE DFN0E0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E0C0(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,CLR, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, CLR);
      and U_c2 (Enable02, _E0, CLR);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E0C0 ----

//---- MODULE DFN0E0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E0C1(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(Q, D,CLK,CLR_0, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _CLR0);
      and U_c2 (Enable02, _E0, _CLR0);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E0C1 ----

//---- MODULE DFN0E0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E0P0(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,VCC_0, PRE, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, PRE);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E0P0 ----

//---- MODULE DFN0E0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E0P1(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpf DF_0(Q, D,CLK,VCC_0, PRE_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _PRE0);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E0P1 ----

//---- MODULE DFN0E1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E1(E, CLK, Q,D);
 input D,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(Q, D,CLK,VCC_0, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      buf U_c0 (Enable01,E);
      buf U_c2 (Enable02, E);
      buf U_c4 (Enable04, E);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK,  0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E1 ----

//---- MODULE DFN0E1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E1C0(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(Q, D,CLK,CLR, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, CLR);
      and U_c2 (Enable02, E, CLR);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E1C0 ----

//---- MODULE DFN0E1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E1C1(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(E_0, E);

 Dffpf DF_0(Q, D,CLK,CLR_0, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, _CLR0);
      and U_c2 (Enable02, E, _CLR0);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E1C1 ----

//---- MODULE DFN0E1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E1P0(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(Q, D,CLK,VCC_0, PRE, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, PRE);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E1P0 ----

//---- MODULE DFN0E1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E1P1(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(E_0, E);

 Dffpf DF_0(Q, D,CLK,VCC_0, PRE_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, _PRE0);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E1P1 ----

//---- MODULE DFN0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0P0(PRE, CLK, Q,D);
 input D,PRE,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,VCC_0, PRE, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, PRE);       buf U_c4 (Enable04, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0P0 ----

//---- MODULE DFN0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0P1(PRE, CLK, Q,D);
 input D,PRE,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpf DF_0(Q, D,CLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0P1 ----

//---- MODULE DFN0P1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0P1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, CLR=CLR, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0P1C1(PRE, CLR, CLK, Q,D);
 input D,PRE,CLR,CLK;
 output Q;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(Q, D,CLK,CLR_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, _CLR0, _PRE0);
       buf U_c2 (Enable02, _CLR0);
       buf U_c4 (Enable04, _PRE0);
      and U_c6 (Enable05, _CLR0, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& ~CLR,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);
	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0P1C1 ----

//---- MODULE DFN1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1(CLK, Q,D);
 input D,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1 ----

//---- MODULE DFN1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1C0(CLR, CLK, Q,D);
 input D,CLR,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,CLR, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,CLR);
       buf U_c2 (Enable02, CLR);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge CLK, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1C0 ----

//---- MODULE DFN1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1C1(CLR, CLK, Q,D);
 input D,CLR,CLK;
 output Q;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 UFPRB DF_0( Q, D, CLK, CLR_0, NOTIFY_REG );

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge CLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1C1 ----

//---- MODULE DFN1E0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E0(E, CLK, Q,D);
 input D,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,VCC_0, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I3 (_E0, E);
      buf U_c0 (Enable01,_E0);
      buf U_c2 (Enable02, _E0);
      buf U_c4 (Enable04, _E0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK,  0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E0 ----

//---- MODULE DFN1E0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E0C0(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,CLR, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, CLR);
      and U_c2 (Enable02, _E0, CLR);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E0C0 ----

//---- MODULE DFN1E0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E0C1(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(Q, D,CLK,CLR_0, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _CLR0);
      and U_c2 (Enable02, _E0, _CLR0);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E0C1 ----

//---- MODULE DFN1E0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E0P0(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,VCC_0, PRE, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, PRE);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E0P0 ----

//---- MODULE DFN1E0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E0P1(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(Q, D,CLK,VCC_0, PRE_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _PRE0);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E0P1 ----

//---- MODULE DFN1E1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E1(E, CLK, Q,D);
 input D,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(Q, D,CLK,VCC_0, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,E);
      buf U_c2 (Enable02, E);
      buf U_c4 (Enable04, E);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK,  0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E1 ----

//---- MODULE DFN1E1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E1C0(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(Q, D,CLK,CLR, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, CLR);
      and U_c2 (Enable02, E, CLR);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E1C0 ----

//---- MODULE DFN1E1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E1C1(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(E_0, E);

 Dffpr DF_0(Q, D,CLK,CLR_0, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, _CLR0);
      and U_c2 (Enable02, E, _CLR0);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E1C1 ----

//---- MODULE DFN1E1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E1P0(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(Q, D,CLK,VCC_0, PRE, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, PRE);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E1P0 ----

//---- MODULE DFN1E1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E1P1(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(E_0, E);

 Dffpr DF_0(Q, D,CLK,VCC_0, PRE_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, _PRE0);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E1P1 ----

//---- MODULE DFN1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1P0(PRE, CLK, Q,D);
 input D,PRE,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,VCC_0, PRE, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, PRE);       buf U_c4 (Enable04, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1P0 ----

//---- MODULE DFN1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1P1(PRE, CLK, Q,D);
 input D,PRE,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(Q, D,CLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1P1 ----

//---- MODULE DFN1P1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1P1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, CLR=CLR, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1P1C1(PRE, CLR, CLK, Q,D);
 input D,PRE,CLR,CLK;
 output Q;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(Q, D,CLK,CLR_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, _CLR0, _PRE0);
       buf U_c2 (Enable02, _CLR0);
       buf U_c4 (Enable04, _PRE0);
      and U_c6 (Enable05, _CLR0, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& ~CLR,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);
	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1P1C1 ----

//---- MODULE DLI0 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, D=D ];
-----------------------------------------------------------------*/

module DLI0(G, QN,D);
 input D,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 DL2C_UDP DL_U0(QN_, D, G, GND, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	buf U_c1 (Enable2, _G);
	buf U_c3 (Enable4, _G);
	buf U_c5 (Enable6, _G);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G, 0.0, NOTIFY_REG);
	$hold(posedge G, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G, 0.0, NOTIFY_REG);
	$hold(posedge G, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G, 0.0, 0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0 ----

//---- MODULE DLI0C0 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0C0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, _CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLI0C0(CLR, G, QN,D);
 input D,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(QN_, D, G, CLR_, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,CLR);
	and U_c1 (Enable2, _G, CLR);
	buf U_c2 (Enable3, CLR);
	and U_c3 (Enable4, _G, CLR);
	buf U_c5 (Enable6, _G);
	buf U_c6 (Enable7, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && CLR )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(posedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  CLR, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, posedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0C0 ----

//---- MODULE DLI0C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLI0C1(CLR, G, QN,D);
 input D,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(QN_, D, G, CLR, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,_CLR);
	and U_c1 (Enable2, _G, _CLR);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, _G, _CLR);
	buf U_c5 (Enable6, _G);
	buf U_c6 (Enable7, _CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && !CLR )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(negedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge CLR, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, negedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0C1 ----

//---- MODULE DLI0P0 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0P0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, _PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI0P0(PRE, G, QN,D);
 input D,PRE,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 DL2C_UDP DL_U0(QN_, D, G, GND, PRE_, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,PRE);	and U_c1 (Enable2, _G, PRE);
	buf U_c3 (Enable4, _G);
	buf U_c4 (Enable5, PRE);
	and U_c5 (Enable6, _G, PRE);
	buf U_c6 (Enable7, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (!G )
       (posedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  PRE, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, posedge PRE, 0.0, NOTIFY_REG);
	$hold(posedge G, posedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0P0 ----

//---- MODULE DLI0P1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0P1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI0P1(PRE, G, QN,D);
 input D,PRE,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 DL2C_UDP DL_U0(QN_, D, G, GND, PRE, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,_PRE);
	and U_c1 (Enable2, _G, _PRE);
	buf U_c3 (Enable4, _G);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, _G, _PRE);
	buf U_c6 (Enable7, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && !PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (!G )
	(negedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, negedge PRE, 0.0, NOTIFY_REG);
	$hold(posedge G,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0P1 ----

//---- MODULE DLI0P1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0P1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, CLR=CLR, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI0P1C1(PRE, CLR, G, QN,D);
 input D,PRE,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(QN_, D, G, CLR, PRE, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	not U_I2 (_CLR, CLR);
	and U_c0 (Enable1, _CLR, _PRE);
	and U_c1 (Enable2, _G, _CLR, _PRE);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, _G, _CLR);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, _G, _PRE);
	and U_c6 (Enable7, _CLR, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && !CLR && !PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(negedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	if (!CLR)
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (!G && !CLR )
	(negedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& Enable3, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, posedge G &&&  Enable3, 0.0, NOTIFY_REG);
	$hold (posedge G &&& Enable3 , negedge PRE, 0.0, NOTIFY_REG);
	$recovery (negedge CLR, posedge G &&& Enable5, 0.0, NOTIFY_REG);
	$hold (posedge G &&& Enable5, negedge CLR, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable3,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0P1C1 ----

//---- MODULE DLI1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, D=D ];
-----------------------------------------------------------------*/

module DLI1(G, QN,D);
 input D,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, GND, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	buf U_c1 (Enable2, G);
	buf U_c3 (Enable4, G);
	buf U_c5 (Enable6, G);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G, 0.0, NOTIFY_REG);
	$hold(negedge G, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G, 0.0, NOTIFY_REG);
	$hold(negedge G, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G, 0.0, 0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1 ----

//---- MODULE DLI1C0 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1C0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, _CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLI1C0(CLR, G, QN,D);
 input D,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, CLR_, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,CLR);
	and U_c1 (Enable2, G,CLR);
	buf U_c2 (Enable3, CLR);
	and U_c3 (Enable4, G, CLR);
	buf U_c5 (Enable6, G);
	buf U_c6 (Enable7, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && CLR )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(posedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  CLR, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, posedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1C0 ----

//---- MODULE DLI1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLI1C1(CLR, G, QN,D);
 input D,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, CLR, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,_CLR);
	and U_c1 (Enable2, G,_CLR);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, G, _CLR);
	buf U_c5 (Enable6, G);
	buf U_c6 (Enable7, _CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && !CLR )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(negedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge CLR, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, negedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1C1 ----

//---- MODULE DLI1P0 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1P0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, _PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI1P0(PRE, G, QN,D);
 input D,PRE,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, GND, PRE_, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,PRE);	and U_c1 (Enable2, G, PRE);
	buf U_c3 (Enable4, G);
	buf U_c4 (Enable5, PRE);
	and U_c5 (Enable6, G, PRE);
	buf U_c6 (Enable7, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (G )
       (posedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  PRE, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, posedge PRE, 0.0, NOTIFY_REG);
	$hold(negedge G, posedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1P0 ----

//---- MODULE DLI1P1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1P1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI1P1(PRE, G, QN,D);
 input D,PRE,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, GND, PRE, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,_PRE);
	and U_c1 (Enable2, G, _PRE);
	buf U_c3 (Enable4, G);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, G, _PRE);
	buf U_c6 (Enable7, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && !PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (G )
	(negedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, negedge PRE, 0.0, NOTIFY_REG);
	$hold(negedge G,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1P1 ----

//---- MODULE DLI1P1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1P1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, CLR=CLR, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI1P1C1(PRE, CLR, G, QN,D);
 input D,PRE,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, CLR, PRE, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	not U_I2 (_CLR, CLR);
	and U_c0 (Enable1, _CLR, _PRE);
	and U_c1 (Enable2, G, _CLR, _PRE);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, G, _CLR);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, G, _PRE);
	and U_c6 (Enable7, _CLR, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && !CLR && !PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(negedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	if (!CLR)
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (G && !CLR )
	(negedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& Enable3, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, negedge G &&&  Enable3, 0.0, NOTIFY_REG);
	$hold (negedge G &&& Enable3 , negedge PRE, 0.0, NOTIFY_REG);
	$recovery (negedge CLR, negedge G &&& Enable5, 0.0, NOTIFY_REG);
	$hold (negedge G &&& Enable5, negedge CLR, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable3,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1P1C1 ----

//---- MODULE DLN0 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, D=D ];
-----------------------------------------------------------------*/

module DLN0(G, Q,D);
 input D,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 DL2C_UDP DL_U0(Q, D, G, GND, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	buf U_c1 (Enable2, _G);
	buf U_c3 (Enable4, _G);
	buf U_c5 (Enable6, _G);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G, 0.0, NOTIFY_REG);
	$hold(posedge G, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G, 0.0, NOTIFY_REG);
	$hold(posedge G, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G, 0.0, 0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0 ----

//---- MODULE DLN0C0 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0C0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, _CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLN0C0(CLR, G, Q,D);
 input D,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(Q, D, G, CLR_, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,CLR);
	and U_c1 (Enable2, _G, CLR);
	buf U_c2 (Enable3, CLR);
	and U_c3 (Enable4, _G, CLR);
	buf U_c5 (Enable6, _G);
	buf U_c6 (Enable7, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && CLR )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(posedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  CLR, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, posedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0C0 ----

//---- MODULE DLN0C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLN0C1(CLR, G, Q,D);
 input D,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(Q, D, G, CLR, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,_CLR);
	and U_c1 (Enable2, _G, _CLR);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, _G, _CLR);
	buf U_c5 (Enable6, _G);
	buf U_c6 (Enable7, _CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && !CLR )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(negedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge CLR, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, negedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0C1 ----

//---- MODULE DLN0P0 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0P0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, _PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN0P0(PRE, G, Q,D);
 input D,PRE,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 DL2C_UDP DL_U0(Q, D, G, GND, PRE_, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,PRE);	and U_c1 (Enable2, _G, PRE);
	buf U_c3 (Enable4, _G);
	buf U_c4 (Enable5, PRE);
	and U_c5 (Enable6, _G, PRE);
	buf U_c6 (Enable7, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
       if (!G )
       (posedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  PRE, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, posedge PRE, 0.0, NOTIFY_REG);
	$hold(posedge G, posedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0P0 ----

//---- MODULE DLN0P1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0P1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN0P1(PRE, G, Q,D);
 input D,PRE,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 DL2C_UDP DL_U0(Q, D, G, GND, PRE, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,_PRE);
	and U_c1 (Enable2, _G, _PRE);
	buf U_c3 (Enable4, _G);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, _G, _PRE);
	buf U_c6 (Enable7, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && !PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
       if (!G )
	(negedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, negedge PRE, 0.0, NOTIFY_REG);
	$hold(posedge G,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0P1 ----

//---- MODULE DLN0P1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0P1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, CLR=CLR, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN0P1C1(PRE, CLR, G, Q,D);
 input D,PRE,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(Q, D, G, CLR, PRE, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	not U_I2 (_CLR, CLR);
	and U_c0 (Enable1, _CLR, _PRE);
	and U_c1 (Enable2, _G, _CLR, _PRE);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, _G, _CLR);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, _G, _PRE);
	and U_c6 (Enable7, _CLR, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output

	if (!G && !CLR && !PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(negedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	if (!CLR)
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
        if (!G && !CLR )
	(negedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& Enable3, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, posedge G &&&  Enable3, 0.0, NOTIFY_REG);
	$hold (posedge G &&& Enable3 , negedge PRE, 0.0, NOTIFY_REG);
	$recovery (negedge CLR, posedge G &&& Enable5, 0.0, NOTIFY_REG);
	$hold (posedge G &&& Enable5, negedge CLR, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable3,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0P1C1 ----

//---- MODULE DLN1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, D=D ];
-----------------------------------------------------------------*/

module DLN1(G, Q,D);
 input D,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, GND, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	buf U_c1 (Enable2, G);
	buf U_c3 (Enable4, G);
	buf U_c5 (Enable6, G);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (G )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G, 0.0, NOTIFY_REG);
	$hold(negedge G, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G, 0.0, NOTIFY_REG);
	$hold(negedge G, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G, 0.0, 0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1 ----

//---- MODULE DLN1C0 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1C0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, _CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLN1C0(CLR, G, Q,D);
 input D,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, CLR_, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,CLR);
	and U_c1 (Enable2, G,CLR);
	buf U_c2 (Enable3, CLR);
	and U_c3 (Enable4, G, CLR);
	buf U_c5 (Enable6, G);
	buf U_c6 (Enable7, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && CLR )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(posedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  CLR, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, posedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1C0 ----

//---- MODULE DLN1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLN1C1(CLR, G, Q,D);
 input D,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, CLR, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,_CLR);
	and U_c1 (Enable2, G,_CLR);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, G, _CLR);
	buf U_c5 (Enable6, G);
	buf U_c6 (Enable7, _CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);

        //check timing delay for output

	if (G && !CLR )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(negedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge CLR, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, negedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1C1 ----

//---- MODULE DLN1P0 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1P0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, _PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN1P0(PRE, G, Q,D);
 input D,PRE,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, GND, PRE_, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,PRE);	and U_c1 (Enable2, G, PRE);
	buf U_c3 (Enable4, G);
	buf U_c4 (Enable5, PRE);
	and U_c5 (Enable6, G, PRE);
	buf U_c6 (Enable7, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output

	if (G && PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
        if (G )
        (posedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  PRE, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, posedge PRE, 0.0, NOTIFY_REG);
	$hold(negedge G, posedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1P0 ----

//---- MODULE DLN1P1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1P1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN1P1(PRE, G, Q,D);
 input D,PRE,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, GND, PRE, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,_PRE);
	and U_c1 (Enable2, G, _PRE);
	buf U_c3 (Enable4, G);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, G, _PRE);
	buf U_c6 (Enable7, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output

	if (G && !PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
        if (G )
	(negedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, negedge PRE, 0.0, NOTIFY_REG);
	$hold(negedge G,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1P1 ----

//---- MODULE DLN1P1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1P1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, CLR=CLR, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN1P1C1(PRE, CLR, G, Q,D);
 input D,PRE,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, CLR, PRE, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	not U_I2 (_CLR, CLR);
	and U_c0 (Enable1, _CLR, _PRE);
	and U_c1 (Enable2, G, _CLR, _PRE);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, G, _CLR);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, G, _PRE);
	and U_c6 (Enable7, _CLR, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="fusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output

	if (G && !CLR && !PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(negedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	if (!CLR)
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
        if (G && !CLR )
	(negedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& Enable3, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, negedge G &&&  Enable3, 0.0, NOTIFY_REG);
	$hold (negedge G &&& Enable3 , negedge PRE, 0.0, NOTIFY_REG);
	$recovery (negedge CLR, negedge G &&& Enable5, 0.0, NOTIFY_REG);
	$hold (negedge G &&& Enable5, negedge CLR, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable3,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1P1C1 ----

//---- MODULE GND ----
/*--------------------------------------------------------------------
 CELL NAME : GND
 CELL TYPE : comb
 CELL LOGIC : Y=0
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module GND(Y);
 output Y;

 supply0	Y;

       specify

		specparam MacroType = "comb";

		//pin to pin path delay 

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE GND ----

//---- MODULE INBUF ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF ----

//---- MODULE INBUF_GTLP25 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_GTLP25
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_GTLP25(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_GTLP25 ----

//---- MODULE INBUF_GTLP33 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_GTLP33
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_GTLP33(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_GTLP33 ----

//---- MODULE INBUF_HSTL_I ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_HSTL_I
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_HSTL_I(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_HSTL_I ----

//---- MODULE INBUF_LVCMOS15 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS15
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS15(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS15 ----

//---- MODULE INBUF_LVCMOS15D ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS15D
 CELL TYPE : comb
 CELL LOGIC : Y#Down=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS15D(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS15D ----

//---- MODULE INBUF_LVCMOS15U ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS15U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS15U(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS15U ----

//---- MODULE INBUF_LVCMOS18 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS18
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS18(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS18 ----

//---- MODULE INBUF_LVCMOS18D ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS18D
 CELL TYPE : comb
 CELL LOGIC : Y#Down=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS18D(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS18D ----

//---- MODULE INBUF_LVCMOS18U ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS18U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS18U(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS18U ----

//---- MODULE INBUF_LVCMOS25 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS25
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS25(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS25 ----

//---- MODULE INBUF_LVCMOS25D ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS25D
 CELL TYPE : comb
 CELL LOGIC : Y#Down=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS25D(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS25D ----

//---- MODULE INBUF_LVCMOS25U ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS25U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS25U(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS25U ----

//---- MODULE INBUF_LVCMOS33 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS33
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS33(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

      specify

        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS33 ----

//---- MODULE INBUF_LVCMOS33D ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS33D
 CELL TYPE : comb
 CELL LOGIC : Y#Down=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS33D(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

      specify

        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS33D ----

//---- MODULE INBUF_LVCMOS33U ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS33U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS33U(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

      specify

        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS33U ----

//---- MODULE INBUF_LVCMOS5 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS5
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS5(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS5 ----

//---- MODULE INBUF_LVCMOS5D ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS5D
 CELL TYPE : comb
 CELL LOGIC : Y#Down=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS5D(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS5D ----

//---- MODULE INBUF_LVCMOS5U ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS5U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS5U(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS5U ----

//---- MODULE INBUF_LVDS ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVDS
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps


module INBUF_LVDS (PADP,PADN,Y);
  
    input PADP,PADN;
    output Y;
 reg NOTIFY_REG;
    reg temp;
 
   pmos p1(Y,temp,1'b0);
    always @(PADP or PADN) begin

    if ((PADP == 1'b1) && (PADN == 1'b0))
       temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
       temp = 1'b0;
    else
       temp = 1'bx;
    end


    specify

         specparam   LibName       = "fusion";
         specparam   InputLoad$PADP = 0;
         specparam   InputLoad$PADN = 0;
         specparam   OutputLoad$Y  = 0;

         specparam   MacroType = "inbuf_lvds";


        (PADP => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PADN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge PADP, 0.0, 0, NOTIFY_REG);
         $width(posedge PADP, 0.0, 0, NOTIFY_REG);
         $width(negedge PADN, 0.0, 0, NOTIFY_REG);
         $width(posedge PADN, 0.0, 0, NOTIFY_REG);


    endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVDS ----

//---- MODULE INBUF_LVPECL ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVPECL
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVPECL (PADP,PADN,Y);
  
    input PADP,PADN;
    output Y;
 reg NOTIFY_REG;
    reg temp;

    pmos p1(Y,temp,1'b0);
    always @(PADP or PADN) begin

    if ((PADP == 1'b1) && (PADN == 1'b0))
       temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
       temp = 1'b0;
    else
       temp = 1'bx;
    end


    specify

         specparam   LibName       = "fusion";
         specparam   InputLoad$PADP = 0;
         specparam   InputLoad$PADN = 0;
         specparam   OutputLoad$Y  = 0;

         specparam   MacroType = "inbuf_lvpecl";


        (PADP => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PADN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge PADP, 0.0, 0, NOTIFY_REG);
         $width(posedge PADP, 0.0, 0, NOTIFY_REG);
         $width(negedge PADN, 0.0, 0, NOTIFY_REG);
         $width(posedge PADN, 0.0, 0, NOTIFY_REG);

    endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVPECL ----

//---- MODULE INBUF_PCI ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_PCI
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_PCI(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf    BUF_U_00(Y,PAD);

       specify

                specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
                specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
                specparam MacroType = "comb";

                //pin to pin path delay

                (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_PCI ----

//---- MODULE INBUF_PCIX ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_PCIX
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_PCIX(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_PCIX ----

//---- MODULE INBUF_SSTL2_I ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_SSTL2_I
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_SSTL2_I(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_SSTL2_I ----

//---- MODULE INBUF_SSTL2_II ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_SSTL2_II
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_SSTL2_II(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_SSTL2_II ----

//---- MODULE INBUF_SSTL3_I ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_SSTL3_I
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_SSTL3_I(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_SSTL3_I ----

//---- MODULE INBUF_SSTL3_II ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_SSTL3_II
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_SSTL3_II(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_SSTL3_II ----

//---- MODULE INV ----
/*--------------------------------------------------------------------
 CELL NAME : INV
 CELL TYPE : comb
 CELL LOGIC : Y = !A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INV(Y,A);
 input A;
 output Y;

 not	INV_U_00(Y,A);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INV ----

//---- MODULE MAJ3 ----
/*--------------------------------------------------------------------
 CELL NAME : MAJ3
 CELL TYPE : comb
 CELL LOGIC : Y = (A & B) + (B & C) + (A & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MAJ3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 and      U510(NET_0_0, A, B);
 or       U511(NET_0_2, NET_0_0, NET_0_1);
 and      U513(NET_0_1, B, C);
 or       U514(Y, NET_0_2, NET_0_3);
 and      U516(NET_0_3, A, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MAJ3 ----

//---- MODULE MAJ3X ----
/*--------------------------------------------------------------------
 CELL NAME : MAJ3X
 CELL TYPE : comb
 CELL LOGIC : Y = A & B & !C + A & !B & C + !A & B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MAJ3X(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_93(A_, A);
 not	INV_94(B_, B);
 not	INV_95(C_, C);
 and      U521(NET_0_0, A, B);
 UDP_MUX2   U522(NET_0_4, NET_0_0, NET_0_5, C_);
 and      U525(NET_0_5, A_, B);
 or       U526(Y, NET_0_4, NET_0_3);
 and      U529(NET_0_2, A, B_);
 and      U530(NET_0_3, NET_0_2, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MAJ3X ----

//---- MODULE MAJ3XI ----
/*--------------------------------------------------------------------
 CELL NAME : MAJ3XI
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B & !C + A & !B & C + !A & B & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MAJ3XI(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_96(A_, A);
 not	INV_97(B_, B);
 not	INV_98(C_, C);
 and      U535(NET_0_0, A, B);
 UDP_MUX2   U536(NET_0_4, NET_0_0, NET_0_5, C_);
 and      U539(NET_0_5, A_, B);
 nor      U540(Y, NET_0_4, NET_0_3);
 and      U543(NET_0_2, A, B_);
 and      U544(NET_0_3, NET_0_2, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MAJ3XI ----

//---- MODULE MIN3 ----
/*--------------------------------------------------------------------
 CELL NAME : MIN3
 CELL TYPE : comb
 CELL LOGIC : Y = !A & !B + !A & !C + !B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MIN3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_99(A_, A);
 not	INV_100(B_, B);
 not	INV_101(C_, C);
 and      U549(NET_0_0, A_, B_);
 or       U550(NET_0_2, NET_0_0, NET_0_1);
 and      U552(NET_0_1, A_, C_);
 or       U553(Y, NET_0_2, NET_0_3);
 and      U555(NET_0_3, B_, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MIN3 ----

//---- MODULE MIN3X ----
/*--------------------------------------------------------------------
 CELL NAME : MIN3X
 CELL TYPE : comb
 CELL LOGIC : Y = A & !B & !C + !A & B & !C + !A & !B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MIN3X(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_102(A_, A);
 not	INV_103(B_, B);
 not	INV_104(C_, C);
 and      U560(NET_0_0, A, B_);
 UDP_MUX2   U561(NET_0_4, NET_0_0, NET_0_5, C_);
 and      U564(NET_0_5, A_, B_);
 or       U565(Y, NET_0_4, NET_0_3);
 and      U568(NET_0_2, A_, B);
 and      U569(NET_0_3, NET_0_2, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MIN3X ----

//---- MODULE MIN3XI ----
/*--------------------------------------------------------------------
 CELL NAME : MIN3XI
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & !B & !C + !A & B & !C + !A & !B & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MIN3XI(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_105(A_, A);
 not	INV_106(B_, B);
 not	INV_107(C_, C);
 and      U574(NET_0_0, A, B_);
 UDP_MUX2   U575(NET_0_4, NET_0_0, NET_0_5, C_);
 and      U578(NET_0_5, A_, B_);
 nor      U579(Y, NET_0_4, NET_0_3);
 and      U582(NET_0_2, A_, B);
 and      U583(NET_0_3, NET_0_2, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MIN3XI ----

//---- MODULE MX2 ----
/*--------------------------------------------------------------------
 CELL NAME : MX2
 CELL TYPE : comb
 CELL LOGIC : Y = (A & !S) + (B & S)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MX2(Y,A,S,B);
 input A,S,B;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_110(S_, S);
 UDP_MUX2   U594(Y, A, B, S_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_S_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_S_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(S => Y ) = ( tpdLH_S_to_Y, tpdHL_S_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MX2 ----

//---- MODULE MX2A ----
/*--------------------------------------------------------------------
 CELL NAME : MX2A
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & !S) + (B & S)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MX2A(Y,A,S,B);
 input A,S,B;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_111(A_, A);
 not	INV_112(S_, S);
 UDP_MUX2   U598(Y, A_, B, S_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_S_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_S_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(S => Y ) = ( tpdLH_S_to_Y, tpdHL_S_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MX2A ----

//---- MODULE MX2B ----
/*--------------------------------------------------------------------
 CELL NAME : MX2B
 CELL TYPE : comb
 CELL LOGIC : Y = (A & !S) + (!B & S)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MX2B(Y,A,S,B);
 input A,S,B;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_113(S_, S);
 not	INV_114(B_, B);
 UDP_MUX2   U602(Y, A, B_, S_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_S_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_S_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(S => Y ) = ( tpdLH_S_to_Y, tpdHL_S_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MX2B ----

//---- MODULE MX2C ----
/*--------------------------------------------------------------------
 CELL NAME : MX2C
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & !S) + (!B & S)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MX2C(Y,A,S,B);
 input A,S,B;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_115(A_, A);
 not	INV_116(S_, S);
 not	INV_117(B_, B);
 UDP_MUX2   U606(Y, A_, B_, S_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_S_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_S_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(S => Y ) = ( tpdLH_S_to_Y, tpdHL_S_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MX2C ----

//---- MODULE NAND2 ----
/*--------------------------------------------------------------------
 CELL NAME : NAND2
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND2(Y,A,B);
 input A,B;
 output Y;

 nand     U610(Y, A, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND2 ----

//---- MODULE NAND2A ----
/*--------------------------------------------------------------------
 CELL NAME : NAND2A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND2A(Y,A,B);
 input A,B;
 output Y;

 not	INV_118(A_, A);
 nand     U613(Y, A_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND2A ----

//---- MODULE NAND2B ----
/*--------------------------------------------------------------------
 CELL NAME : NAND2B
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND2B(Y,A,B);
 input A,B;
 output Y;

 not	INV_119(A_, A);
 not	INV_120(B_, B);
 nand     U616(Y, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND2B ----

//---- MODULE NAND3 ----
/*--------------------------------------------------------------------
 CELL NAME : NAND3
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U620(NET_0_0, A, B);
 nand     U621(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND3 ----

//---- MODULE NAND3A ----
/*--------------------------------------------------------------------
 CELL NAME : NAND3A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND3A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_121(A_, A);
 and      U625(NET_0_0, A_, B);
 nand     U626(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND3A ----

//---- MODULE NAND3B ----
/*--------------------------------------------------------------------
 CELL NAME : NAND3B
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND3B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_122(A_, A);
 not	INV_123(B_, B);
 and      U630(NET_0_0, A_, B_);
 nand     U631(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND3B ----

//---- MODULE NAND3C ----
/*--------------------------------------------------------------------
 CELL NAME : NAND3C
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B & !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND3C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_124(A_, A);
 not	INV_125(B_, B);
 not	INV_126(C_, C);
 and      U635(NET_0_0, A_, B_);
 nand     U636(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND3C ----

//---- MODULE NOR2 ----
/*--------------------------------------------------------------------
 CELL NAME : NOR2
 CELL TYPE : comb
 CELL LOGIC : Y = !(A + B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR2(Y,A,B);
 input A,B;
 output Y;

 nor      U649(Y, A, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR2 ----

//---- MODULE NOR2A ----
/*--------------------------------------------------------------------
 CELL NAME : NOR2A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A + B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR2A(Y,A,B);
 input A,B;
 output Y;

 not	INV_130(A_, A);
 nor      U652(Y, A_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR2A ----

//---- MODULE NOR2B ----
/*--------------------------------------------------------------------
 CELL NAME : NOR2B
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A + !B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR2B(Y,A,B);
 input A,B;
 output Y;

 not	INV_131(A_, A);
 not	INV_132(B_, B);
 nor      U655(Y, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR2B ----

//---- MODULE NOR3 ----
/*--------------------------------------------------------------------
 CELL NAME : NOR3
 CELL TYPE : comb
 CELL LOGIC : Y = !(A + B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 or       U662(NET_0_0, A, B);
 nor      U663(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR3 ----

//---- MODULE NOR3A ----
/*--------------------------------------------------------------------
 CELL NAME : NOR3A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A + B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR3A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_134(A_, A);
 or       U667(NET_0_0, A_, B);
 nor      U668(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR3A ----

//---- MODULE NOR3B ----
/*--------------------------------------------------------------------
 CELL NAME : NOR3B
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A + !B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR3B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_135(A_, A);
 not	INV_136(B_, B);
 or       U672(NET_0_0, A_, B_);
 nor      U673(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR3B ----

//---- MODULE NOR3C ----
/*--------------------------------------------------------------------
 CELL NAME : NOR3C
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A + !B + !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR3C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_137(A_, A);
 not	INV_138(B_, B);
 not	INV_139(C_, C);
 or       U677(NET_0_0, A_, B_);
 nor      U678(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR3C ----

//---- MODULE OA1 ----
/*--------------------------------------------------------------------
 CELL NAME : OA1
 CELL TYPE : comb
 CELL LOGIC : Y = (A + B) & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OA1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 or       U692(NET_0_0, A, B);
 and      U693(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OA1 ----

//---- MODULE OA1A ----
/*--------------------------------------------------------------------
 CELL NAME : OA1A
 CELL TYPE : comb
 CELL LOGIC : Y = (!A + B) & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OA1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_143(A_, A);
 or       U697(NET_0_0, A_, B);
 and      U698(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OA1A ----

//---- MODULE OA1B ----
/*--------------------------------------------------------------------
 CELL NAME : OA1B
 CELL TYPE : comb
 CELL LOGIC : Y = !C & (A + B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OA1B(Y,C,A,B);
 input C,A,B;
 output Y;
 wire NET_0_0;

 not	INV_144(C_, C);
 and      U701(Y, C_, NET_0_0);
 or       U703(NET_0_0, A, B);

       specify

		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OA1B ----

//---- MODULE OA1C ----
/*--------------------------------------------------------------------
 CELL NAME : OA1C
 CELL TYPE : comb
 CELL LOGIC : Y = (!A + B) & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OA1C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_145(A_, A);
 not	INV_146(C_, C);
 or       U707(NET_0_0, A_, B);
 and      U708(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OA1C ----

//---- MODULE OAI1 ----
/*--------------------------------------------------------------------
 CELL NAME : OAI1
 CELL TYPE : comb
 CELL LOGIC : Y = !((A + B) & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OAI1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 or       U732(NET_0_0, A, B);
 nand     U733(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OAI1 ----

//---- MODULE OR2 ----
/*--------------------------------------------------------------------
 CELL NAME : OR2
 CELL TYPE : comb
 CELL LOGIC : Y = A + B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR2(Y,A,B);
 input A,B;
 output Y;

 or       U756(Y, A, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR2 ----

//---- MODULE OR2A ----
/*--------------------------------------------------------------------
 CELL NAME : OR2A
 CELL TYPE : comb
 CELL LOGIC : Y = !A + B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR2A(Y,A,B);
 input A,B;
 output Y;

 not	INV_156(A_, A);
 or       U759(Y, A_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR2A ----

//---- MODULE OR2B ----
/*--------------------------------------------------------------------
 CELL NAME : OR2B
 CELL TYPE : comb
 CELL LOGIC : Y = !A + !B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR2B(Y,A,B);
 input A,B;
 output Y;

 not	INV_157(A_, A);
 not	INV_158(B_, B);
 or       U762(Y, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR2B ----

//---- MODULE OR3 ----
/*--------------------------------------------------------------------
 CELL NAME : OR3
 CELL TYPE : comb
 CELL LOGIC : Y = A + B + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 or       U769(NET_0_0, A, B);
 or       U770(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR3 ----

//---- MODULE OR3A ----
/*--------------------------------------------------------------------
 CELL NAME : OR3A
 CELL TYPE : comb
 CELL LOGIC : Y = !A + B + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR3A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_160(A_, A);
 or       U774(NET_0_0, A_, B);
 or       U775(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR3A ----

//---- MODULE OR3B ----
/*--------------------------------------------------------------------
 CELL NAME : OR3B
 CELL TYPE : comb
 CELL LOGIC : Y = !A + !B + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR3B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_161(A_, A);
 not	INV_162(B_, B);
 or       U779(NET_0_0, A_, B_);
 or       U780(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR3B ----

//---- MODULE OR3C ----
/*--------------------------------------------------------------------
 CELL NAME : OR3C
 CELL TYPE : comb
 CELL LOGIC : Y = !A + !B + !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR3C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_163(A_, A);
 not	INV_164(B_, B);
 not	INV_165(C_, C);
 or       U784(NET_0_0, A_, B_);
 or       U785(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR3C ----

//---- MODULE OUTBUF ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF ----

//---- MODULE OUTBUF_F_12 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_12(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_12 ----

//---- MODULE OUTBUF_F_16 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_16(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_16 ----

//---- MODULE OUTBUF_F_24 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_24(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_24 ----

//---- MODULE OUTBUF_F_8 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_8(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_8 ----

//---- MODULE OUTBUF_GTLP25 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_GTLP25
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_GTLP25(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_GTLP25 ----

//---- MODULE OUTBUF_GTLP33 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_GTLP33
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_GTLP33(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_GTLP33 ----

//---- MODULE OUTBUF_HSTL_I ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_HSTL_I
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_HSTL_I(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_HSTL_I ----

//---- MODULE OUTBUF_LVCMOS15 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVCMOS15
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVCMOS15(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVCMOS15 ----

//---- MODULE OUTBUF_LVCMOS18 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVCMOS18
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVCMOS18(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVCMOS18 ----

//---- MODULE OUTBUF_LVCMOS25 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVCMOS25
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVCMOS25(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVCMOS25 ----

//---- MODULE OUTBUF_LVCMOS33 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVCMOS33
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVCMOS33(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

      specify

        specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        (D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVCMOS33 ----

//---- MODULE OUTBUF_LVCMOS5 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVCMOS5
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVCMOS5(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVCMOS5 ----

//---- MODULE OUTBUF_LVDS ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVDS
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVDS(D, PADP,PADN);

input   D;
output  PADP,PADN;
 reg NOTIFY_REG;


        buf b1(PADP,D);
        not n1(PADN,D);

specify

         specparam   LibName        = "fusion";
         specparam   InputLoad$D    = 1;
         specparam   OutputLoad$PADP = 0;
         specparam   OutputLoad$PADN = 0;
         specparam   MacroType      = "io";

        (D => PADP) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (D => PADN) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge D, 0.0, 0, NOTIFY_REG);
         $width(posedge D, 0.0, 0, NOTIFY_REG);


endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVDS ----

//---- MODULE OUTBUF_LVPECL ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVPECL
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVPECL(D, PADP,PADN);

input   D;
output  PADP,PADN;
 reg NOTIFY_REG;


        buf b1(PADP,D);
        not n1(PADN,D);
specify

         specparam   LibName        = "fusion";
         specparam   InputLoad$D    = 1;
         specparam   OutputLoad$PADP = 0;
         specparam   OutputLoad$PADN = 0;
         specparam   MacroType      = "io";

        (D => PADP) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (D => PADN) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge D, 0.0, 0, NOTIFY_REG);
         $width(posedge D, 0.0, 0, NOTIFY_REG);


endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVPECL ----

//---- MODULE OUTBUF_PCI ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_PCI
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_PCI(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_PCI ----

//---- MODULE OUTBUF_PCIX ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_PCIX
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_PCIX(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_PCIX ----

//---- MODULE OUTBUF_SSTL2_I ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_SSTL2_I
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_SSTL2_I(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_SSTL2_I ----

//---- MODULE OUTBUF_SSTL2_II ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_SSTL2_II
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_SSTL2_II(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_SSTL2_II ----

//---- MODULE OUTBUF_SSTL3_I ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_SSTL3_I
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_SSTL3_I(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_SSTL3_I ----

//---- MODULE OUTBUF_SSTL3_II ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_SSTL3_II
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_SSTL3_II(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_SSTL3_II ----

//---- MODULE OUTBUF_S_12 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_12(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_12 ----

//---- MODULE OUTBUF_S_16 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_16(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_16 ----

//---- MODULE OUTBUF_S_24 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_24(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_24 ----

//---- MODULE OUTBUF_S_8 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_8(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_8 ----

//---- MODULE TRIBUFF ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U798(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF ----

//---- MODULE TRIBUFF_F_12 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_12(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U801(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_12 ----

//---- MODULE TRIBUFF_F_12D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_12D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_12D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U804(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_12D ----

//---- MODULE TRIBUFF_F_12U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_12U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_12U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U807(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_12U ----

//---- MODULE TRIBUFF_F_16 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_16(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U810(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_16 ----

//---- MODULE TRIBUFF_F_16D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_16D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_16D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U813(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_16D ----

//---- MODULE TRIBUFF_F_16U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_16U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_16U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U816(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_16U ----

//---- MODULE TRIBUFF_F_24 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_24(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U819(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_24 ----

//---- MODULE TRIBUFF_F_24D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_24D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_24D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U822(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_24D ----

//---- MODULE TRIBUFF_F_24U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_24U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_24U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U825(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_24U ----

//---- MODULE TRIBUFF_F_8 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_8(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U828(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_8 ----

//---- MODULE TRIBUFF_F_8D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_8D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_8D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U831(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_8D ----

//---- MODULE TRIBUFF_F_8U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_8U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_8U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U834(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_8U ----

//---- MODULE TRIBUFF_GTLP25 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_GTLP25
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_GTLP25(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U837(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_GTLP25 ----

//---- MODULE TRIBUFF_GTLP33 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_GTLP33
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_GTLP33(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U840(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_GTLP33 ----

//---- MODULE TRIBUFF_HSTL_I ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_HSTL_I
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_HSTL_I(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U843(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_HSTL_I ----

//---- MODULE TRIBUFF_LVCMOS15 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS15
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS15(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U846(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS15 ----

//---- MODULE TRIBUFF_LVCMOS15D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS15D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS15D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U849(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS15D ----

//---- MODULE TRIBUFF_LVCMOS15U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS15U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS15U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U852(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS15U ----

//---- MODULE TRIBUFF_LVCMOS18 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS18
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS18(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U855(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS18 ----

//---- MODULE TRIBUFF_LVCMOS18D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS18D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS18D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U858(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS18D ----

//---- MODULE TRIBUFF_LVCMOS18U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS18U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS18U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U861(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS18U ----

//---- MODULE TRIBUFF_LVCMOS25 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS25
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS25(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U864(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS25 ----

//---- MODULE TRIBUFF_LVCMOS25D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS25D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS25D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U867(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS25D ----

//---- MODULE TRIBUFF_LVCMOS25U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS25U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS25U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U870(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS25U ----

//---- MODULE TRIBUFF_LVCMOS33 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS33
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS33(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U11(PAD, D, E);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS33 ----

//---- MODULE TRIBUFF_LVCMOS33D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS33D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS33D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U14(PAD, D, E);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS33D ----

//---- MODULE TRIBUFF_LVCMOS33U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS33U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS33U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U17(PAD, D, E);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS33U ----

//---- MODULE TRIBUFF_LVCMOS5 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS5
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS5(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U873(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS5 ----

//---- MODULE TRIBUFF_LVCMOS5D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS5D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS5D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U876(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS5D ----

//---- MODULE TRIBUFF_LVCMOS5U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS5U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS5U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U879(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS5U ----

//---- MODULE TRIBUFF_LVDS ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVDS
 CELL TYPE : comb
 CELL LOGIC : PADP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVDS(PADP,PADN,D,E);
 input D,E;
 output PADP,PADN;
 reg NOTIFY_REG;

 bufif1   U99(PADP, D, E);
 not      U98(D_tmp, D);
 bufif1   U97(PADN, D_tmp, E);

      specify

	specparam tpdLH_E_to_PADP = (0.0:0.0:0.0);
	specparam tpdHL_E_to_PADP = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PADP = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PADP = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PADP = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PADP = (0.1:0.1:0.1);
	specparam tpdLH_E_to_PADN = (0.0:0.0:0.0);
	specparam tpdHL_E_to_PADN = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PADN = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PADN = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PADN = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PADN = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PADP = (0.1:0.1:0.1);
        specparam tpdHL_D_to_PADP = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PADN = (0.1:0.1:0.1);
        specparam tpdHL_D_to_PADN = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        //if(~D)
        (E => PADP ) = ( tpdLH_E_to_PADP,tpdHL_E_to_PADP,tpdLZ_E_to_PADP,tpdZH_E_to_PADP,tpdHZ_E_to_PADP,tpdZL_E_to_PADP);
        (E => PADN ) = ( tpdLH_E_to_PADN,tpdHL_E_to_PADN,tpdLZ_E_to_PADN,tpdZH_E_to_PADN,tpdHZ_E_to_PADN,tpdZL_E_to_PADN);

        (D => PADP ) = ( tpdLH_D_to_PADP,tpdHL_D_to_PADP);
        (D => PADN ) = ( tpdLH_D_to_PADN,tpdHL_D_to_PADN);

        $width(negedge D, 0.0, 0, NOTIFY_REG);
        $width(posedge D, 0.0, 0, NOTIFY_REG);
        $width(negedge E, 0.0, 0, NOTIFY_REG);
        $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVDS ----

//---- MODULE TRIBUFF_PCI ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_PCI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_PCI(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U882(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_PCI ----

//---- MODULE TRIBUFF_PCIX ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_PCIX
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_PCIX(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U885(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_PCIX ----

//---- MODULE TRIBUFF_SSTL2_I ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_SSTL2_I
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_SSTL2_I(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U888(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_SSTL2_I ----

//---- MODULE TRIBUFF_SSTL2_II ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_SSTL2_II
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_SSTL2_II(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U891(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_SSTL2_II ----

//---- MODULE TRIBUFF_SSTL3_I ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_SSTL3_I
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_SSTL3_I(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U894(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_SSTL3_I ----

//---- MODULE TRIBUFF_SSTL3_II ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_SSTL3_II
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_SSTL3_II(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U897(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_SSTL3_II ----

//---- MODULE TRIBUFF_S_12 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_12(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U900(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_12 ----

//---- MODULE TRIBUFF_S_12D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_12D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_12D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U903(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_12D ----

//---- MODULE TRIBUFF_S_12U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_12U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_12U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U906(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_12U ----

//---- MODULE TRIBUFF_S_16 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_16(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U909(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_16 ----

//---- MODULE TRIBUFF_S_16D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_16D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_16D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U912(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_16D ----

//---- MODULE TRIBUFF_S_16U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_16U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_16U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U915(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_16U ----

//---- MODULE TRIBUFF_S_24 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_24(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U918(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_24 ----

//---- MODULE TRIBUFF_S_24D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_24D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_24D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U921(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_24D ----

//---- MODULE TRIBUFF_S_24U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_24U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_24U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U924(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_24U ----

//---- MODULE TRIBUFF_S_8 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_8(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U927(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_8 ----

//---- MODULE TRIBUFF_S_8D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_8D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_8D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U930(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_8D ----

//---- MODULE TRIBUFF_S_8U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_8U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_8U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U933(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_8U ----

//---- MODULE VCC ----
/*--------------------------------------------------------------------
 CELL NAME : VCC
 CELL TYPE : comb
 CELL LOGIC : Y=1
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module VCC(Y);
 output Y;

 supply1    Y;

       specify

		specparam MacroType = "comb";

		//pin to pin path delay 

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE VCC ----

//---- MODULE XA1 ----
/*--------------------------------------------------------------------
 CELL NAME : XA1
 CELL TYPE : comb
 CELL LOGIC : Y = (A ^ B) & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XA1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_169(A_, A);
 not	INV_170(B_, B);
 UDP_MUX2   U937(NET_0_0, B, B_, A_);
 and      U939(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XA1 ----

//---- MODULE XA1A ----
/*--------------------------------------------------------------------
 CELL NAME : XA1A
 CELL TYPE : comb
 CELL LOGIC : Y = !(A ^ B) & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XA1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_171(A_, A);
 not	INV_172(B_, B);
 UDPN_MUX2  U943(NET_0_0, B, B_, A_);
 and      U945(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XA1A ----

//---- MODULE XA1B ----
/*--------------------------------------------------------------------
 CELL NAME : XA1B
 CELL TYPE : comb
 CELL LOGIC : Y = (A ^ B) & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XA1B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_173(A_, A);
 not	INV_174(B_, B);
 not	INV_175(C_, C);
 UDP_MUX2   U949(NET_0_0, B, B_, A_);
 and      U951(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XA1B ----

//---- MODULE XA1C ----
/*--------------------------------------------------------------------
 CELL NAME : XA1C
 CELL TYPE : comb
 CELL LOGIC : Y = !(A ^ B) & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XA1C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_176(A_, A);
 not	INV_177(B_, B);
 not	INV_178(C_, C);
 UDPN_MUX2  U955(NET_0_0, B, B_, A_);
 and      U957(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XA1C ----

//---- MODULE XAI1 ----
/*--------------------------------------------------------------------
 CELL NAME : XAI1
 CELL TYPE : comb
 CELL LOGIC : Y = !((A ^ B) & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XAI1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_179(A_, A);
 not	INV_180(B_, B);
 UDP_MUX2   U961(NET_0_0, B, B_, A_);
 nand     U963(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XAI1 ----

//---- MODULE XAI1A ----
/*--------------------------------------------------------------------
 CELL NAME : XAI1A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!(A ^ B) & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XAI1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_181(A_, A);
 not	INV_182(B_, B);
 UDPN_MUX2  U967(NET_0_0, B, B_, A_);
 nand     U969(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XAI1A ----

//---- MODULE XNOR2 ----
/*--------------------------------------------------------------------
 CELL NAME : XNOR2
 CELL TYPE : comb
 CELL LOGIC : Y = !(A ^ B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XNOR2(Y,A,B);
 input A,B;
 output Y;

 not	INV_183(A_, A);
 not	INV_184(B_, B);
 UDPN_MUX2  U972(Y, B, B_, A_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XNOR2 ----

//---- MODULE XNOR3 ----
/*--------------------------------------------------------------------
 CELL NAME : XNOR3
 CELL TYPE : comb
 CELL LOGIC : Y = !(A ^ B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XNOR3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_187(A_, A);
 not	INV_188(B_, B);
 UDP_MUX2   U981(NET_0_0, B, B_, A_);
 xnor     U983(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XNOR3 ----

//---- MODULE XO1 ----
/*--------------------------------------------------------------------
 CELL NAME : XO1
 CELL TYPE : comb
 CELL LOGIC : Y = (A ^ B) + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XO1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_189(A_, A);
 not	INV_190(B_, B);
 UDP_MUX2   U987(NET_0_0, B, B_, A_);
 or       U989(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XO1 ----

//---- MODULE XO1A ----
/*--------------------------------------------------------------------
 CELL NAME : XO1A
 CELL TYPE : comb
 CELL LOGIC : Y = !(A ^ B) + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XO1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_191(A_, A);
 not	INV_192(B_, B);
 UDPN_MUX2  U993(NET_0_0, B, B_, A_);
 or       U995(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XO1A ----

//---- MODULE XOR2 ----
/*--------------------------------------------------------------------
 CELL NAME : XOR2
 CELL TYPE : comb
 CELL LOGIC : Y = A ^ B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XOR2(Y,A,B);
 input A,B;
 output Y;

 not	INV_193(A_, A);
 not	INV_194(B_, B);
 UDP_MUX2   U998(Y, B, B_, A_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XOR2 ----

//---- MODULE XOR3 ----
/*--------------------------------------------------------------------
 CELL NAME : XOR3
 CELL TYPE : comb
 CELL LOGIC : Y = A ^ B ^ C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XOR3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_197(A_, A);
 not	INV_198(B_, B);
 UDP_MUX2   U1007(NET_0_0, B, B_, A_);
 xor      U1009(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XOR3 ----

//---- MODULE ZOR3 ----
/*--------------------------------------------------------------------
 CELL NAME : ZOR3
 CELL TYPE : comb
 CELL LOGIC : Y = A & B & C + !A & !B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module ZOR3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_199(A_, A);
 not	INV_200(B_, B);
 not	INV_201(C_, C);
 and      U1013(NET_0_0, A, B);
 UDP_MUX2   U1014(Y, NET_0_0, NET_0_2, C);
 and      U1017(NET_0_2, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE ZOR3 ----

//---- MODULE ZOR3I ----
/*--------------------------------------------------------------------
 CELL NAME : ZOR3I
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B & C + !A & !B & !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module ZOR3I(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_202(A_, A);
 not	INV_203(B_, B);
 not	INV_204(C_, C);
 and      U1021(NET_0_0, A, B);
 UDPN_MUX2  U1022(Y, NET_0_0, NET_0_2, C);
 and      U1025(NET_0_2, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE ZOR3I ----

//---- MODULE BUFF ----
/*--------------------------------------------------------------------
 CELL NAME : BUFF
 CELL TYPE : comb
 CELL LOGIC : Y = A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BUFF(Y,A);
 input A;
 output Y;

 buf	BUF_U_00(Y,A);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BUFF ----

//---- MODULE CLKINT ----
/*--------------------------------------------------------------------
 CELL NAME : CLKINT
 CELL TYPE : comb
 CELL LOGIC : Y = A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKINT(Y,A);
 input A;
 output Y;

 buf	BUF_U_00(Y,A);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKINT ----

//---- MODULE IOIN_IB ----
/*--------------------------------------------------------------------
 CELL NAME : IOIN_IB
 CELL TYPE : comb
 CELL LOGIC : Y = YIN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IB(Y,YIN);
 input YIN;
 output Y;

 buf	BUF_U_00(Y,YIN);

       specify

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IB ----

//---- MODULE IOIN_IRC ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IRC
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, CLR=CLR, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IRC(CLR, ICLK, Y,YIN);
 input YIN,CLR,ICLK;
 output Y;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(Y, YIN,ICLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IRC ----

//---- MODULE IOIN_IRP ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IRP
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, PRE=PRE, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IRP(PRE, ICLK, Y,YIN);
 input YIN,PRE,ICLK;
 output Y;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(Y, YIN,ICLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IRP ----

//---- MODULE IOIN_IREC ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IREC
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, E=ICE, CLR=CLR, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IREC(CLR, ICE, ICLK, Y,YIN);
 input YIN,CLR,ICE,ICLK;
 output Y;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(ICE_0, ICE);

 Dffpr DF_0(Y, YIN,ICLK,CLR_0, VCC_0, ICE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, ICE, _CLR0);
      and U_c2 (Enable02, ICE, _CLR0);
      buf U_c4 (Enable04, ICE);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable05, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable05, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IREC ----

//---- MODULE IOIN_IREP ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IREP
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, E=ICE, PRE=PRE, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IREP(PRE, ICE, ICLK, Y,YIN);
 input YIN,PRE,ICE,ICLK;
 output Y;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(ICE_0, ICE);

 Dffpr DF_0(Y, YIN,ICLK,VCC_0, PRE_0, ICE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, ICE, _PRE0);
      buf U_c2 (Enable02, ICE);
      and U_c4 (Enable04, ICE, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable05, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable05, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IREP ----

//---- MODULE IOTRI_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_OB_EB
 CELL TYPE : comb
 CELL LOGIC : DOUT=D;EOUT=E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_EB(DOUT,EOUT,D,E);
 input D,E;
 output DOUT,EOUT;

 buf	BUF_U_00(DOUT,D);
 buf	BUF_U_01(EOUT,E);

       specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );
		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_EB ----

//---- MODULE IOTRI_OB_ERC ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_ERC
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, CLR=CLR, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_ERC(CLR, OCLK, EOUT,DOUT,E,D);
 input E,D,CLR,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(EOUT, E,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_ERC ----

//---- MODULE IOTRI_OB_ERP ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_ERP
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, PRE=PRE, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_ERP(PRE, OCLK, EOUT,DOUT,E,D);
 input E,D,PRE,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_ERP ----

//---- MODULE IOTRI_OB_EREC ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_EREC
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, E=OCE, CLR=CLR, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_EREC(CLR, OCE, OCLK, EOUT,DOUT,E,D);
 input E,D,CLR,OCE,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c2 (Enable02, OCE, _CLR0);
      buf U_c4 (Enable04, OCE);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_EREC ----

//---- MODULE IOTRI_OB_EREP ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_EREP
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, E=OCE, PRE=PRE, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_EREP(PRE, OCE, OCLK, EOUT,DOUT,E,D);
 input E,D,PRE,OCE,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c2 (Enable02, OCE);
      and U_c4 (Enable04, OCE, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_EREP ----

//---- MODULE IOTRI_ORC_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_ORC_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, CLR=CLR, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORC_EB(CLR, OCLK, DOUT,EOUT,D,E);
 input D,E,CLR,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORC_EB ----

//---- MODULE IOTRI_ORP_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_ORP_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, PRE=PRE, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORP_EB(PRE, OCLK, DOUT,EOUT,D,E);
 input D,E,PRE,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORP_EB ----

//---- MODULE IOTRI_OREC_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OREC_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, E=OCE, CLR=CLR, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OREC_EB(CLR, OCE, OCLK, DOUT,EOUT,D,E);
 input D,E,CLR,OCE,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c2 (Enable02, OCE, _CLR0);
      buf U_c4 (Enable04, OCE);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OREC_EB ----

//---- MODULE IOTRI_OREP_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OREP_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, E=OCE, PRE=PRE, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OREP_EB(PRE, OCE, OCLK, DOUT,EOUT,D,E);
 input D,E,PRE,OCE,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c2 (Enable02, OCE);
      and U_c4 (Enable04, OCE, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OREP_EB ----

//---- MODULE IOTRI_ORC_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_ORC_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORC_ERC(DOUT,EOUT,D,OCLK,CLR,E);
 input D,OCLK,CLR,E;
 output DOUT,EOUT;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& ~CLR, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& ~CLR, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& ~CLR, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& ~CLR, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& ~CLR ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& ~CLR, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& ~CLR, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& ~CLR, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& ~CLR, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& ~CLR, negedge E,0.0, NOTIFY_REG);



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORC_ERC ----

//---- MODULE IOTRI_OREC_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_OREC_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OREC_EREC(DOUT,EOUT,D,OCLK,CLR,OCE,E);
 input D,OCLK,CLR,OCE,E;
 output DOUT,EOUT;
 supply1 VCC_0;

 supply1 VCC_1;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c2 (Enable02, OCE, _CLR0);
      buf U_c4 (Enable04, OCE);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OREC_EREC ----

//---- MODULE IOTRI_ORP_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_ORP_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORP_ERP(DOUT,EOUT,D,OCLK,PRE,E);
 input D,OCLK,PRE,E;
 output DOUT,EOUT;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
      buf U_c4 (Enable04, _PRE0);
      buf U_c6 (Enable05, _PRE0);





//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORP_ERP ----

//---- MODULE IOTRI_OREP_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_OREP_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OREP_EREP(DOUT,EOUT,D,OCLK,OCE,PRE,E);
 input D,OCLK,OCE,PRE,E;
 output DOUT,EOUT;
 supply1 VCC_0;

 supply1 VCC_1;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c2 (Enable02, OCE);
      and U_c4 (Enable04, OCE, _PRE0);
       buf U_c6 (Enable05, _PRE0);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OREP_EREP ----

//---- MODULE IOBI_IB_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_EB
 CELL TYPE : comb
 CELL LOGIC : DOUT=D;EOUT=E;Y=YIN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_EB(DOUT,EOUT,Y,D,E,YIN);
 input D,E,YIN;
 output DOUT,EOUT,Y;

 buf	BUF_U_00(DOUT,D);
 buf	BUF_U_01(EOUT,E);
 buf	BUF_U_02(Y,YIN);

       specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );
		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );
		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_EB ----

//---- MODULE IOBI_IB_OB_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_ERC(DOUT,EOUT,Y,D,E,OCLK,CLR,YIN);
 input D,E,OCLK,CLR,YIN;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
       buf U_c2 (Enable12, _CLR1);
      buf U_c6 (Enable15, _CLR1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_ERC ----

//---- MODULE IOBI_IB_OB_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_EREC(DOUT,EOUT,Y,D,E,OCLK,CLR,OCE,YIN);
 input D,E,OCLK,CLR,OCE,YIN;
 output DOUT,EOUT,Y;

 supply1 VCC_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      and U_c0 (Enable11, OCE, _CLR1);
      and U_c2 (Enable12, OCE, _CLR1);
      buf U_c4 (Enable14, OCE);
      buf U_c6 (Enable15, _CLR1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

        	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
        	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	        specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	        specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_EREC ----

//---- MODULE IOBI_IB_OB_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_ERP(DOUT,EOUT,Y,D,E,OCLK,PRE,YIN);
 input D,E,OCLK,PRE,YIN;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      buf U_c0 (Enable11, _PRE1);
      buf U_c4 (Enable14, _PRE1);
      buf U_c6 (Enable15, _PRE1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_ERP ----

//---- MODULE IOBI_IB_OB_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_EREP(DOUT,EOUT,Y,D,E,OCLK,OCE,PRE,YIN);
 input D,E,OCLK,OCE,PRE,YIN;
 output DOUT,EOUT,Y;

 supply1 VCC_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c0 (Enable11, OCE, _PRE1);
      buf U_c2 (Enable12, OCE);
      and U_c4 (Enable14, OCE, _PRE1);
       buf U_c6 (Enable15, _PRE1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_EREP ----

//---- MODULE IOBI_IB_OD_EB ----
/*--------------------------------------------------------------------
 CELL NAME  : IOBI_IB_OD_EB
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OD_EB(DR, DF, CLR, E, OCLK, YIN, DOUT, EOUT, Y);
input DR, DF, CLR, E, OCLK, YIN;
output DOUT, EOUT, Y;

wire tmp1_zd, tmp2_zd;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    buf buf_D(Y, YIN);
    buf buf_E(EOUT, E);
 
    not INV_CLR(CLR_, CLR);
    Dffpr DF_1(tmp1_zd, DR, OCLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp2_zd, DF, OCLK, CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(DOUT, tmp1_zd, tmp2_zd , OCLK);

    specify

        //check timing delay for output

        (YIN => Y )  = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => EOUT ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        
        (posedge CLR  => (DOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (OCLK => DOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        //(posedge OCLK => (DOUT +: DR))   = (0.1:0.1:0.1, 0.1:0.1:0.1);   //for consistency with other DDR_IN macros
        //(negedge OCLK => (DOUT +: DF))   = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge DR, posedge OCLK, 0.0, NOTIFY_REG);
        $setup(negedge DR, posedge OCLK, 0.0, NOTIFY_REG);
        $hold(posedge OCLK, posedge DR, 0.0, NOTIFY_REG);
        $hold(posedge OCLK, negedge DR, 0.0, NOTIFY_REG);

        $setup(posedge DF, posedge OCLK, 0.0, NOTIFY_REG);
        $setup(negedge DF, posedge OCLK, 0.0, NOTIFY_REG);
        $hold(posedge OCLK, posedge DF, 0.0, NOTIFY_REG);
        $hold(posedge OCLK, negedge DF, 0.0, NOTIFY_REG);

        $recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);
        $hold(posedge OCLK, negedge CLR, 0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge OCLK, 0, 0, NOTIFY_REG);
        $width(negedge OCLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR,  0, 0, NOTIFY_REG);

    endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OD_EB ----

//---- MODULE IOBI_IB_ORC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,YIN);
 input E,D,OCLK,CLR,YIN;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
       buf U_c2 (Enable12, _CLR1);
      buf U_c6 (Enable15, _CLR1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORC_EB ----

//---- MODULE IOBI_IB_OREC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OREC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OREC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,OCE,YIN);
 input E,D,OCLK,CLR,OCE,YIN;
 output EOUT,DOUT,Y;

 supply1 VCC_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      and U_c0 (Enable11, OCE, _CLR1);
      and U_c2 (Enable12, OCE, _CLR1);
      buf U_c4 (Enable14, OCE);
      buf U_c6 (Enable15, _CLR1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	        specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
         	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	        specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OREC_EB ----

//---- MODULE IOBI_IB_ORP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORP_EB(EOUT,DOUT,Y,E,D,OCLK,PRE,YIN);
 input E,D,OCLK,PRE,YIN;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      buf U_c0 (Enable11, _PRE1);
       buf U_c4 (Enable14, _PRE1);
       buf U_c6 (Enable15, _PRE1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORP_EB ----

//---- MODULE IOBI_IB_OREP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OREP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OREP_EB(EOUT,DOUT,Y,E,D,OCLK,OCE,PRE,YIN);
 input E,D,OCLK,OCE,PRE,YIN;
 output EOUT,DOUT,Y;

 supply1 VCC_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c0 (Enable11, OCE, _PRE1);
      buf U_c2 (Enable12, OCE);
      and U_c4 (Enable14, OCE, _PRE1);
       buf U_c6 (Enable15, _PRE1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OREP_EB ----

//---- MODULE IOBI_IB_ORC_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORC_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORC_ERC(DOUT,EOUT,Y,D,OCLK,CLR,E,YIN);
 input D,OCLK,CLR,E,YIN;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
      buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
	specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);


		//pin to pin path delay 

	(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORC_ERC ----

//---- MODULE IOBI_IB_OREC_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OREC_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OREC_EREC(DOUT,EOUT,Y,D,OCLK,CLR,OCE,E,YIN);
 input D,OCLK,CLR,OCE,E,YIN;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;



 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c2 (Enable02, OCE, _CLR0);
      buf U_c4 (Enable04, OCE);
      buf U_c6 (Enable05, _CLR0);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);


		//pin to pin path delay 

	(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OREC_EREC ----

//---- MODULE IOBI_IB_ORP_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORP_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORP_ERP(DOUT,EOUT,Y,D,OCLK,PRE,E,YIN);
 input D,OCLK,PRE,E,YIN;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
      buf U_c4 (Enable04, _PRE0);
      buf U_c6 (Enable05, _PRE0);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
	specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//pin to pin path delay 

	(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORP_ERP ----

//---- MODULE IOBI_IB_OREP_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OREP_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OREP_EREP(DOUT,EOUT,Y,D,OCLK,OCE,PRE,E,YIN);
 input D,OCLK,OCE,PRE,E,YIN;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;



 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c2 (Enable02, OCE);
      and U_c4 (Enable04, OCE, _PRE0);
       buf U_c6 (Enable05, _PRE0);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	//pin to pin path delay 

	(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OREP_EREP ----

//---- MODULE IOBI_IRC_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK,CLR);
 input D,E,YIN,ICLK,CLR;
 output DOUT,EOUT,Y;


 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(EOUT,E);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);




// some temp signals created for timing checking sections

      not U2_I2 (_CLR2, CLR);
      buf U_c0 (Enable21,_CLR2);
      buf U_c2 (Enable22, _CLR2);
      buf U_c6 (Enable25, _CLR2);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_OB_EB ----

//---- MODULE IOBI_IREC_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK,CLR,ICE);
 input D,E,YIN,ICLK,CLR,ICE;
 output DOUT,EOUT,Y;


 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(EOUT,E);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);




// some temp signals created for timing checking sections

      not U2_I2 (_CLR2, CLR);
      and U_c0 (Enable21, ICE, _CLR2);
      and U_c2 (Enable22, ICE, _CLR2);
      buf U_c4 (Enable24, ICE);
      buf U_c6 (Enable25, _CLR2);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_OB_EB ----

//---- MODULE IOBI_IRP_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK,PRE);
 input D,E,YIN,ICLK,PRE;
 output DOUT,EOUT,Y;


 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(EOUT,E);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);




// some temp signals created for timing checking sections

      not U2_I1 (_PRE2, PRE);
      buf U_c0 (Enable21, _PRE2);
       buf U_c4 (Enable24, _PRE2);
       buf U_c6 (Enable25, _PRE2);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_OB_EB ----

//---- MODULE IOBI_IREP_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK,ICE,PRE);
 input D,E,YIN,ICLK,ICE,PRE;
 output DOUT,EOUT,Y;


 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(EOUT,E);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);




// some temp signals created for timing checking sections

      not U2_I1 (_PRE2, PRE);
      and U_c0 (Enable21, ICE, _PRE2);
      buf U_c2 (Enable22, ICE);
      and U_c4 (Enable24, ICE, _PRE2);
       buf U_c6 (Enable25, _PRE2);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_OB_EB ----

//---- MODULE IOBI_IRC_OB_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_OB_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_OB_ERC(DOUT,EOUT,Y,D,E,OCLK,CLR,YIN,ICLK);
 input D,E,OCLK,CLR,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
      buf U_c2 (Enable12, _CLR1);
      buf U_c6 (Enable15, _CLR1);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable11, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable11, negedge YIN,0.0, NOTIFY_REG);

        $hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);
        $recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);

	$width(posedge ICLK &&& Enable12, 0, 0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable12, 0, 0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_OB_ERC ----

//---- MODULE IOBI_IREC_OB_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_OB_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_OB_ERC(DOUT,EOUT,Y,D,E,OCLK,CLR,YIN,ICLK,ICE);
 input D,E,OCLK,CLR,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
      buf U_c2 (Enable12, _CLR1);
      buf U_c6 (Enable15, _CLR1);


// some temp signals created for timing checking sections

      and U_c00 (Enable21, ICE, _CLR1);
      and U_c02 (Enable22, ICE, _CLR1);
      buf U_c04 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable15, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable15, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_OB_ERC ----

//---- MODULE IOBI_IRC_OB_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_OB_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_OB_EREC(DOUT,EOUT,Y,D,E,OCLK,CLR,OCE,YIN,ICLK);
 input D,E,OCLK,CLR,OCE,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I02 (_CLR1, CLR);
      and U_c00 (Enable11, OCE, _CLR1);
      and U_c02 (Enable12, OCE, _CLR1);
      buf U_c04 (Enable14, OCE);
      buf U_c06 (Enable15, _CLR1);


// some temp signals created for timing checking sections

      buf U_c0 (Enable21,_CLR1);
      buf U_c2 (Enable22, _CLR1);
      buf U_c6 (Enable25, _CLR1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_OB_EREC ----

//---- MODULE IOBI_IREC_OB_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_OB_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_OB_EREC(DOUT,EOUT,Y,D,E,OCLK,CLR,OCE,YIN,ICLK,ICE);
 input D,E,OCLK,CLR,OCE,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I02 (_CLR1, CLR);
      and U_c00 (Enable11, OCE, _CLR1);
      and U_c02 (Enable12, OCE, _CLR1);
      buf U_c04 (Enable14, OCE);
      buf U_c06 (Enable15, _CLR1);


// some temp signals created for timing checking sections

      and U_c0 (Enable21, ICE, _CLR1);
      and U_c2 (Enable22, ICE, _CLR1);
      buf U_c4 (Enable24, ICE);
      buf U_c6 (Enable25, _CLR1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_OB_EREC ----

//---- MODULE IOBI_IRP_OB_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_OB_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_OB_ERP(DOUT,EOUT,Y,D,E,OCLK,PRE,YIN,ICLK);
 input D,E,OCLK,PRE,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      buf U_c0 (Enable11, _PRE1);
      buf U_c4 (Enable14, _PRE1);
      buf U_c6 (Enable15, _PRE1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable11, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable11, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable15, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_OB_ERP ----

//---- MODULE IOBI_IREP_OB_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_OB_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_OB_ERP(DOUT,EOUT,Y,D,E,OCLK,PRE,YIN,ICLK,ICE);
 input D,E,OCLK,PRE,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I01 (_PRE1, PRE);
      buf U_c00 (Enable11, _PRE1);
      buf U_c04 (Enable14, _PRE1);
      buf U_c06 (Enable15, _PRE1);

      and U_c0 (Enable21, ICE, _PRE1);
      buf U_c2 (Enable22, ICE);
      and U_c4 (Enable24, ICE, _PRE1);
      buf U_c6 (Enable25, _PRE1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_OB_ERP ----

//---- MODULE IOBI_IRP_OB_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_OB_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_OB_EREP(DOUT,EOUT,Y,D,E,OCLK,OCE,PRE,YIN,ICLK);
 input D,E,OCLK,OCE,PRE,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c00 (Enable11, OCE, _PRE1);
      buf U_c02 (Enable12, OCE);
      and U_c04 (Enable14, OCE, _PRE1);
      buf U_c06 (Enable15, _PRE1);

      buf U_c0 (Enable21, _PRE1);
      buf U_c4 (Enable24, _PRE1);
      buf U_c6 (Enable25, _PRE1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_OB_EREP ----

//---- MODULE IOBI_IREP_OB_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_OB_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_OB_EREP(DOUT,EOUT,Y,D,E,OCLK,OCE,PRE,YIN,ICLK,ICE);
 input D,E,OCLK,OCE,PRE,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c0 (Enable11, OCE, _PRE1);
      buf U_c2 (Enable12, OCE);
      and U_c4 (Enable14, OCE, _PRE1);
      buf U_c6 (Enable15, _PRE1);

      and U_c7 (Enable21, ICE, _PRE1);
      buf U_c8 (Enable22, ICE);
      and U_c9 (Enable24, ICE, _PRE1);
      buf U_c10 (Enable25, _PRE1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_OB_EREP ----

//---- MODULE IOBI_IRC_ORC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_ORC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_ORC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,YIN,ICLK);
 input E,D,OCLK,CLR,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
      buf U_c2 (Enable12, _CLR1);
      buf U_c6 (Enable15, _CLR1);

      buf U_c3 (Enable21,_CLR1);
      buf U_c4 (Enable22, _CLR1);
      buf U_c5 (Enable25, _CLR1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_ORC_EB ----

//---- MODULE IOBI_IREC_ORC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_ORC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_ORC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,YIN,ICLK,ICE);
 input E,D,OCLK,CLR,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
      buf U_c1 (Enable12, _CLR1);
      buf U_c2 (Enable15, _CLR1);

      and U_c3 (Enable21, ICE, _CLR1);
      and U_c4 (Enable22, ICE, _CLR1);
      buf U_c5 (Enable24, ICE);
      buf U_c6 (Enable25, _CLR1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_ORC_EB ----

//---- MODULE IOBI_IRC_OREC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_OREC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_OREC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,OCE,YIN,ICLK);
 input E,D,OCLK,CLR,OCE,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      and U_c0 (Enable11, OCE, _CLR1);
      and U_c1 (Enable12, OCE, _CLR1);
      buf U_c2 (Enable14, OCE);
      buf U_c3 (Enable15, _CLR1);

      buf U_c4 (Enable21,_CLR1);
      buf U_c5 (Enable22, _CLR1);
      buf U_c6 (Enable25, _CLR1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_OREC_EB ----

//---- MODULE IOBI_IREC_OREC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_OREC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_OREC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,OCE,YIN,ICLK,ICE);
 input E,D,OCLK,CLR,OCE,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      and U_c0 (Enable11, OCE, _CLR1);
      and U_c1 (Enable12, OCE, _CLR1);
      buf U_c2 (Enable14, OCE);
      buf U_c3 (Enable15, _CLR1);

      and U_c4 (Enable21, ICE, _CLR1);
      and U_c5 (Enable22, ICE, _CLR1);
      buf U_c6 (Enable24, ICE);
      buf U_c7 (Enable25, _CLR1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_OREC_EB ----

//---- MODULE IOBI_IRP_ORP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_ORP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_ORP_EB(EOUT,DOUT,Y,E,D,OCLK,PRE,YIN,ICLK);
 input E,D,OCLK,PRE,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      buf U_c0 (Enable11, _PRE1);
      buf U_c1 (Enable14, _PRE1);
      buf U_c2 (Enable15, _PRE1);

      buf U_c3 (Enable21, _PRE1);
      buf U_c4 (Enable24, _PRE1);
      buf U_c5 (Enable25, _PRE1);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_ORP_EB ----

//---- MODULE IOBI_IRP_OREP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_OREP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_OREP_EB(EOUT,DOUT,Y,E,D,OCLK,OCE,PRE,YIN,ICLK);
 input E,D,OCLK,OCE,PRE,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c0 (Enable11, OCE, _PRE1);
      buf U_c1 (Enable12, OCE);
      and U_c2 (Enable14, OCE, _PRE1);
      buf U_c3 (Enable15, _PRE1);

      buf U_c4 (Enable21, _PRE1);
      buf U_c5 (Enable24, _PRE1);
      buf U_c6 (Enable25, _PRE1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_OREP_EB ----

//---- MODULE IOBI_IREP_ORP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_ORP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_ORP_EB(EOUT,DOUT,Y,E,D,OCLK,PRE,YIN,ICLK,ICE);
 input E,D,OCLK,PRE,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      buf U_c0 (Enable11, _PRE1);
      buf U_c1 (Enable14, _PRE1);
      buf U_c2 (Enable15, _PRE1);

      and U_c3 (Enable21, ICE, _PRE1);
      buf U_c4 (Enable22, ICE);
      and U_c5 (Enable24, ICE, _PRE1);
      buf U_c6 (Enable25, _PRE1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_ORP_EB ----

//---- MODULE IOBI_IREP_OREP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_OREP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_OREP_EB(EOUT,DOUT,Y,E,D,OCLK,OCE,PRE,YIN,ICLK,ICE);
 input E,D,OCLK,OCE,PRE,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c0 (Enable11, OCE, _PRE1);
      buf U_c1 (Enable12, OCE);
      and U_c2 (Enable14, OCE, _PRE1);
      buf U_c3 (Enable15, _PRE1);

      and U_c4 (Enable21, ICE, _PRE1);
      buf U_c5 (Enable22, ICE);
      and U_c6 (Enable24, ICE, _PRE1);
      buf U_c7 (Enable25, _PRE1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_OREP_EB ----

//---- MODULE IOBI_IRC_ORC_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_ORC_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_ORC_ERC(DOUT,EOUT,Y,D,OCLK,CLR,E,YIN,ICLK);
 input D,OCLK,CLR,E,YIN,ICLK;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
      buf U_c1 (Enable02, _CLR0);
      buf U_c2 (Enable05, _CLR0);

      buf U_c3 (Enable11,_CLR0);
      buf U_c4 (Enable12, _CLR0);
      buf U_c5 (Enable15, _CLR0);

      buf U_c6 (Enable21,_CLR0);
      buf U_c7 (Enable22, _CLR0);
      buf U_c8 (Enable25, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_ORC_ERC ----

//---- MODULE IOBI_IRC_OREC_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_OREC_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_OREC_EREC(DOUT,EOUT,Y,D,OCLK,CLR,OCE,E,YIN,ICLK);
 input D,OCLK,CLR,OCE,E,YIN,ICLK;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c1 (Enable02, OCE, _CLR0);
      buf U_c2 (Enable04, OCE);
      buf U_c3 (Enable05, _CLR0);

      and U_c4 (Enable11, OCE, _CLR0);
      and U_c5 (Enable12, OCE, _CLR0);
      buf U_c6 (Enable14, OCE);
      buf U_c7 (Enable15, _CLR0);

      buf U_c8 (Enable21,_CLR0);
      buf U_c9 (Enable22, _CLR0);
      buf U_c10 (Enable25, _CLR0);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_OREC_EREC ----

//---- MODULE IOBI_IREC_ORC_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_ORC_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_ORC_ERC(DOUT,EOUT,Y,D,OCLK,CLR,E,YIN,ICLK,ICE);
 input D,OCLK,CLR,E,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
      buf U_c1 (Enable02, _CLR0);
      buf U_c2 (Enable05, _CLR0);

      buf U_c3 (Enable11,_CLR0);
      buf U_c4 (Enable12, _CLR0);
      buf U_c5 (Enable15, _CLR0);

      and U_c6 (Enable21, ICE, _CLR0);
      and U_c7 (Enable22, ICE, _CLR0);
      buf U_c8 (Enable24, ICE);
      buf U_c9 (Enable25, _CLR0);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_ORC_ERC ----

//---- MODULE IOBI_IREC_OREC_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_OREC_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_OREC_EREC(DOUT,EOUT,Y,D,OCLK,CLR,OCE,E,YIN,ICLK,ICE);
 input D,OCLK,CLR,OCE,E,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c1 (Enable02, OCE, _CLR0);
      buf U_c2 (Enable04, OCE);
      buf U_c3 (Enable05, _CLR0);

      and U_c4 (Enable11, OCE, _CLR0);
      and U_c5 (Enable12, OCE, _CLR0);
      buf U_c6 (Enable14, OCE);
      buf U_c7 (Enable15, _CLR0);

      and U_c8 (Enable21, ICE, _CLR0);
      and U_c9 (Enable22, ICE, _CLR0);
      buf U_c10 (Enable24, ICE);
      buf U_c11 (Enable25, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_OREC_EREC ----

//---- MODULE IOBI_IRP_ORP_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_ORP_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_ORP_ERP(DOUT,EOUT,Y,D,OCLK,PRE,E,YIN,ICLK);
 input D,OCLK,PRE,E,YIN,ICLK;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
      buf U_c1 (Enable04, _PRE0);
      buf U_c2 (Enable05, _PRE0);

      buf U_c3 (Enable11, _PRE0);
      buf U_c4 (Enable14, _PRE0);
      buf U_c5 (Enable15, _PRE0);

      buf U_c6 (Enable21, _PRE0);
      buf U_c7 (Enable24, _PRE0);
      buf U_c8 (Enable25, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_ORP_ERP ----

//---- MODULE IOBI_IRP_OREP_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_OREP_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_OREP_EREP(DOUT,EOUT,Y,D,OCLK,OCE,PRE,E,YIN,ICLK);
 input D,OCLK,OCE,PRE,E,YIN,ICLK;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c1 (Enable02, OCE);
      and U_c2 (Enable04, OCE, _PRE0);
      buf U_c3 (Enable05, _PRE0);

      and U_c4 (Enable11, OCE, _PRE0);
      buf U_c5 (Enable12, OCE);
      and U_c6 (Enable14, OCE, _PRE0);
      buf U_c7 (Enable15, _PRE0);

      buf U_c8 (Enable21, _PRE0);
      buf U_c9 (Enable24, _PRE0);
      buf U_c10 (Enable25, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_OREP_EREP ----

//---- MODULE IOBI_IREP_ORP_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_ORP_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_ORP_ERP(DOUT,EOUT,Y,D,OCLK,PRE,E,YIN,ICLK,ICE);
 input D,OCLK,PRE,E,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
      buf U_c1 (Enable04, _PRE0);
      buf U_c2 (Enable05, _PRE0);

      buf U_c3 (Enable11, _PRE0);
      buf U_c4 (Enable14, _PRE0);
      buf U_c5 (Enable15, _PRE0);

      and U_c6 (Enable21, ICE, _PRE0);
      buf U_c7 (Enable22, ICE);
      and U_c8 (Enable24, ICE, _PRE0);
      buf U_c9 (Enable25, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_ORP_ERP ----

//---- MODULE IOBI_IREP_OREP_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_OREP_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_OREP_EREP(DOUT,EOUT,Y,D,OCLK,OCE,PRE,E,YIN,ICLK,ICE);
 input D,OCLK,OCE,PRE,E,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c1 (Enable02, OCE);
      and U_c2 (Enable04, OCE, _PRE0);
      buf U_c3 (Enable05, _PRE0);

      not U1_I4 (_PRE1, PRE);
      and U_c4 (Enable11, OCE, _PRE0);
      buf U_c5 (Enable12, OCE);
      and U_c6 (Enable14, OCE, _PRE0);
      buf U_c7 (Enable15, _PRE0);

      and U_c8 (Enable21, ICE, _PRE0);
      buf U_c9 (Enable22, ICE);
      and U_c10 (Enable24, ICE, _PRE0);
      buf U_c11 (Enable25, _PRE0);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_OREP_EREP ----

//---- MODULE IOPAD_IN ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_IN
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_IN(Y,PAD);
 input PAD;
 output Y;

 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_IN ----

//---- MODULE IOPADP_IN ----
/*--------------------------------------------------------------------
 CELL NAME  : IOPADP_IN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADP_IN(PAD,N2PIN,Y);

output  Y;
input  PAD,N2PIN;
    
 reg NOTIFY_REG;

     buf          BF1   (Y, PAD);

specify 
    specparam   LibName       = "fusion";
    specparam   InputLoad$PAD = 1;
    specparam   OutputLoad$Y  = 0;
    specparam   MacroType     = "io";

 
        (PAD => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1); 
        (N2PIN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                specparam PATHPULSE$N2PIN$Y = (0.1, 0.1);
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge N2PIN, 0.0, 0, NOTIFY_REG);
                $width(posedge N2PIN, 0.0, 0, NOTIFY_REG);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);


endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADP_IN ----

//---- MODULE IOPADN_IN ----
/*--------------------------------------------------------------------
 CELL NAME  : IOPADN_IN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADN_IN(PAD,N2POUT);

output  N2POUT;
input  PAD;

 reg NOTIFY_REG;
    
     buf          BF1   (N2POUT, PAD);

specify 
    specparam   LibName       = "fusion";
    specparam   InputLoad$PAD = 1;
    specparam   OutputLoad$Y  = 0;
    specparam   MacroType     = "io";

 
        (PAD => N2POUT) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                specparam PATHPULSE$PAD$N2POUT = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADN_IN ----

//---- MODULE IOPAD_TRI ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_TRI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_TRI(PAD,D,E);
 input D,E;
 output PAD;

 reg NOTIFY_REG;

 bufif1   U1210(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_TRI ----

//---- MODULE IOPADP_TRI ----
/*--------------------------------------------------------------------
 CELL NAME  : IOPADP_TRI
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADP_TRI(D, E, PAD);

output  PAD;
input  D, E;

 reg NOTIFY_REG;

   bufif1       BF1   (PAD, D, E);

specify 
 
         specparam   LibName     = "fusion";
         specparam   OutputLoad$PAD = 0;
         specparam   InputLoad$D = 1;
         specparam   InputLoad$E = 1;
 
         specparam   MacroType = "io";

        (E => PAD) = (0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1); 
        (D => PAD) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

 
endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADP_TRI ----

//---- MODULE IOPADN_TRI ----
/*--------------------------------------------------------------------
 CELL NAME  : IOPADN_TRI
---------------------------------------------------------------------*/      

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADN_TRI(DB, E, PAD);

output  PAD;
input  DB, E;

 reg NOTIFY_REG;

   not          INVT (net1,DB);
   bufif1       BF1  (PAD, net1, E);

specify 
 
         specparam   LibName     = "fusion";
         specparam   OutputLoad$PAD = 0;
         specparam   InputLoad$DB = 1;
         specparam   InputLoad$E = 1;
 
         specparam   MacroType = "io";


        (E  => PAD) = (0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1); 
        (DB => PAD) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                specparam PATHPULSE$DB$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                $width(negedge DB, 0.0, 0, NOTIFY_REG);
                $width(posedge DB, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

 
endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADN_TRI ----

//---- MODULE IOPAD_BI ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_BI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_BI(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;

 reg NOTIFY_REG;

 bufif1   U1213(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                specparam PATHPULSE$D$Y = (0.1, 0.1);
                specparam PATHPULSE$E$Y = (0.1, 0.1);
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_BI ----

//---- MODULE IOPADP_BI ----
/*--------------------------------------------------------------------
 CELL NAME : IOPADP_BI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADP_BI(Y,PAD,N2PIN,D,E);
 input D,E,N2PIN;
 inout PAD;
 output Y;
 reg NOTIFY_REG;
 reg temp;

   bufif1   U89(PAD, D, E);
   pmos     U86(Y,temp,1'b0);

   always @(PAD or N2PIN) begin
     if ((PAD == 1'b1) && (N2PIN == 1'b0))
        temp = 1'b1;
     else if ((PAD == 1'b0) && (N2PIN == 1'b1))
        temp = 1'b0;
     else
        temp = 1'bx;
    end


      specify

	specparam tpdLH_E_to_PAD   = ( 0.1:0.1:0.1 );
	specparam tpdHL_E_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdLZ_E_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdZL_E_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdHZ_E_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdZH_E_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdLH_D_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdHL_D_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdLH_PAD_to_Y   = ( 0.1:0.1:0.1 );
        specparam tpdHL_PAD_to_Y   = ( 0.1:0.1:0.1 );
        specparam tpdLH_N2PIN_to_Y = ( 0.1:0.1:0.1 );
        specparam tpdHL_N2PIN_to_Y = ( 0.1:0.1:0.1 );
        specparam MacroType = "comb";

        //pin to pin path delay 

        //if(~D)
        ( E => PAD )   = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD );
        ( D => PAD )   = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD );

        ( D => Y )     = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
        ( E => Y )     = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
        ( PAD   => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
        ( N2PIN => Y ) = ( tpdLH_N2PIN_to_Y, tpdHL_N2PIN_to_Y );

        specparam PATHPULSE$D$PAD = (0.1, 0.1);
        specparam PATHPULSE$E$PAD = (0.1, 0.1);
        specparam PATHPULSE$PAD$Y = (0.1, 0.1);
        specparam PATHPULSE$D$Y   = (0.1, 0.1);
        specparam PATHPULSE$E$Y   = (0.1, 0.1);

        $width( negedge PAD, 0.0, 0, NOTIFY_REG );
        $width( posedge PAD, 0.0, 0, NOTIFY_REG );
        $width( negedge N2PIN, 0.0, 0, NOTIFY_REG );
        $width( posedge N2PIN, 0.0, 0, NOTIFY_REG );
        $width( negedge D, 0.0, 0, NOTIFY_REG );
        $width( posedge D, 0.0, 0, NOTIFY_REG );
        $width( negedge E, 0.0, 0, NOTIFY_REG );
        $width( posedge E, 0.0, 0, NOTIFY_REG );


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADP_BI ----

//---- MODULE IOPADN_BI ----
/*--------------------------------------------------------------------
 CELL NAME : IOPADN_BI
 CELL TYPE : comb
 CELL LOGIC : PAD=!DB@E ; N2POUT=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADN_BI(N2POUT,PAD,DB,E);
 input DB,E;
 inout PAD;
 output N2POUT;
 reg NOTIFY_REG;
 reg temp;

   not      U79(DB_tmp,DB);
   bufif1   U78(PAD, DB_tmp, E);
   buf      U77(N2POUT,PAD);

      specify

	specparam tpdLH_E_to_PAD  = ( 0.1:0.1:0.1 );
	specparam tpdHL_E_to_PAD  = ( 0.1:0.1:0.1 );
        specparam tpdLZ_E_to_PAD  = ( 0.1:0.1:0.1 );
        specparam tpdZL_E_to_PAD  = ( 0.1:0.1:0.1 );
        specparam tpdHZ_E_to_PAD  = ( 0.1:0.1:0.1 );
        specparam tpdZH_E_to_PAD  = ( 0.1:0.1:0.1 );
        specparam tpdLH_DB_to_PAD = ( 0.1:0.1:0.1 );
        specparam tpdHL_DB_to_PAD = ( 0.1:0.1:0.1 );
        specparam tpdLH_PAD_to_N2POUT = ( 0.1:0.1:0.1 );
        specparam tpdHL_PAD_to_N2POUT = ( 0.1:0.1:0.1 );
        specparam MacroType = "comb";

        //pin to pin path delay 

        //if(~D)
        ( E => PAD )  = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD );
        ( DB => PAD ) = ( tpdLH_DB_to_PAD,tpdHL_DB_to_PAD );

        ( PAD   => N2POUT ) = ( tpdLH_PAD_to_N2POUT, tpdHL_PAD_to_N2POUT );

        specparam PATHPULSE$DB$PAD     = (0.1, 0.1);
        specparam PATHPULSE$E$PAD      = (0.1, 0.1);
        specparam PATHPULSE$PAD$N2POUT = (0.1, 0.1);

        $width( negedge PAD, 0.0, 0, NOTIFY_REG );
        $width( posedge PAD, 0.0, 0, NOTIFY_REG );
        $width( negedge DB, 0.0, 0, NOTIFY_REG );
        $width( posedge DB, 0.0, 0, NOTIFY_REG );
        $width( negedge E, 0.0, 0, NOTIFY_REG );
        $width( posedge E, 0.0, 0, NOTIFY_REG );


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADN_BI ----

//---- MODULE IOPAD_IN_U ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_IN_U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_IN_U(Y,PAD);
 input PAD;
 output Y;

 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_IN_U ----

//---- MODULE IOPAD_IN_D ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_IN_D
 CELL TYPE : comb
 CELL LOGIC : Y#DOWN=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_IN_D(Y,PAD);
 input PAD;
 output Y;

 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_IN_D ----

//---- MODULE IOPAD_TRI_U ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_TRI_U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_TRI_U(PAD,D,E);
 input D,E;
 output PAD;

 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U2089(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_TRI_U ----

//---- MODULE IOPAD_TRI_D ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_TRI_D
 CELL TYPE : comb
 CELL LOGIC : PAD#DOWN=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_TRI_D(PAD,D,E);
 input D,E;
 output PAD;

 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U2092(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_TRI_D ----

//---- MODULE IOPAD_BI_U ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_BI_U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_BI_U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;

 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U2095(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                specparam PATHPULSE$D$Y = (0.1, 0.1);
                specparam PATHPULSE$E$Y = (0.1, 0.1);
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_BI_U ----

//---- MODULE IOPAD_BI_D ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_BI_D
 CELL TYPE : comb
 CELL LOGIC : PAD#DOWN=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_BI_D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;

 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U2098(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                specparam PATHPULSE$D$Y = (0.1, 0.1);
                specparam PATHPULSE$E$Y = (0.1, 0.1);
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_BI_D ----

//---- MODULE IOPADN_OUT ----
/*--------------------------------------------------------------------
 CELL NAME : IOPADN_OUT
 CELL TYPE : comb
 CELL LOGIC : PAD=!DB
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADN_OUT(PAD,DB);
 input DB;
 output PAD;

 reg NOTIFY_REG;

 not	INV_U_00(PAD,DB);

       specify

		specparam tpdLH_DB_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_DB_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(DB => PAD ) = ( tpdLH_DB_to_PAD, tpdHL_DB_to_PAD );

                specparam PATHPULSE$DB$PAD = (0.1, 0.1);
                $width(negedge DB, 0.0, 0, NOTIFY_REG);
                $width(posedge DB, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADN_OUT ----

//---- MODULE BIBUF_F_2 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_2(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1052(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_2 ----

//---- MODULE BIBUF_F_2D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_2D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_2D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1055(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_2D ----

//---- MODULE BIBUF_F_2U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_2U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_2U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1058(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_2U ----

//---- MODULE BIBUF_F_4 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_4(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1061(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_4 ----

//---- MODULE BIBUF_F_4D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_4D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_4D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1064(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_4D ----

//---- MODULE BIBUF_F_4U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_4U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_4U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1067(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_4U ----

//---- MODULE BIBUF_F_6 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_6(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1079(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_6 ----

//---- MODULE BIBUF_F_6D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_6D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_6D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1082(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_6D ----

//---- MODULE BIBUF_F_6U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_6U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_6U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1085(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_6U ----

//---- MODULE BIBUF_GTL33 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_GTL33
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_GTL33(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1088(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_GTL33 ----

//---- MODULE BIBUF_GTL25 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_GTL25
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_GTL25(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1094(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_GTL25 ----

//---- MODULE BIBUF_HSTL_II ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_HSTL_II
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_HSTL_II(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1100(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_HSTL_II ----

//---- MODULE BIBUF_S_2 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_2(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1103(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_2 ----

//---- MODULE BIBUF_S_2D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_2D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_2D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1106(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_2D ----

//---- MODULE BIBUF_S_2U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_2U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_2U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1109(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_2U ----

//---- MODULE BIBUF_S_4 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_4(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1112(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_4 ----

//---- MODULE BIBUF_S_4D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_4D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_4D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1115(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_4D ----

//---- MODULE BIBUF_S_4U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_4U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_4U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1118(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_4U ----

//---- MODULE BIBUF_S_6 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_6(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1121(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_6 ----

//---- MODULE BIBUF_S_6D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_6D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_6D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1124(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_6D ----

//---- MODULE BIBUF_S_6U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_6U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_6U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1127(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_6U ----

//---- MODULE CLKBUF_GTL25 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_GTL25
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_GTL25(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_GTL25 ----

//---- MODULE CLKBUF_GTL33 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_GTL33
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_GTL33(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_GTL33 ----

//---- MODULE CLKBUF_HSTL_II ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_HSTL_II
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_HSTL_II(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_HSTL_II ----

//---- MODULE INBUF_GTL33 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_GTL33
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_GTL33(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_GTL33 ----

//---- MODULE INBUF_GTL25 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_GTL25
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_GTL25(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_GTL25 ----

//---- MODULE INBUF_HSTL_II ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_HSTL_II
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_HSTL_II(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_HSTL_II ----

//---- MODULE OUTBUF_F_2 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_2(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_2 ----

//---- MODULE OUTBUF_F_4 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_4(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_4 ----

//---- MODULE OUTBUF_F_6 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_6(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_6 ----

//---- MODULE OUTBUF_GTL25 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_GTL25
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_GTL25(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_GTL25 ----

//---- MODULE OUTBUF_GTL33 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_GTL33
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_GTL33(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_GTL33 ----

//---- MODULE OUTBUF_HSTL_II ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_HSTL_II
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_HSTL_II(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_HSTL_II ----

//---- MODULE OUTBUF_S_2 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_2(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_2 ----

//---- MODULE OUTBUF_S_4 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_4(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_4 ----

//---- MODULE OUTBUF_S_6 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_6(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_6 ----

//---- MODULE TRIBUFF_F_2 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_2(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1139(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_2 ----

//---- MODULE TRIBUFF_F_2D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_2D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_2D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1142(PAD, D, E);
 tri0 PAD;

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_2D ----

//---- MODULE TRIBUFF_F_2U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_2U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_2U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1145(PAD, D, E);
       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_2U ----

//---- MODULE TRIBUFF_F_4 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_4(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1148(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_4 ----

//---- MODULE TRIBUFF_F_4D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_4D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_4D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1151(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_4D ----

//---- MODULE TRIBUFF_F_4U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_4U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_4U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1154(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_4U ----

//---- MODULE TRIBUFF_F_6 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_6(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1157(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_6 ----

//---- MODULE TRIBUFF_F_6D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_6D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_6D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1160(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_6D ----

//---- MODULE TRIBUFF_F_6U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_6U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_6U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1163(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_6U ----

//---- MODULE TRIBUFF_GTL25 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_GTL25
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_GTL25(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1178(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_GTL25 ----

//---- MODULE TRIBUFF_GTL33 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_GTL33
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_GTL33(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1181(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_GTL33 ----

//---- MODULE TRIBUFF_HSTL_II ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_HSTL_II
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_HSTL_II(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1187(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_HSTL_II ----

//---- MODULE TRIBUFF_S_2 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_2(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1190(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_2 ----

//---- MODULE TRIBUFF_S_2D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_2D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_2D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1193(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_2D ----

//---- MODULE TRIBUFF_S_2U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_2U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_2U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1196(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_2U ----

//---- MODULE TRIBUFF_S_4 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_4(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1199(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_4 ----

//---- MODULE TRIBUFF_S_4D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_4D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_4D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1202(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_4D ----

//---- MODULE TRIBUFF_S_4U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_4U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_4U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1205(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_4U ----

//---- MODULE TRIBUFF_S_6 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_6(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1208(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_6 ----

//---- MODULE TRIBUFF_S_6D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_6D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_6D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1211(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_6D ----

//---- MODULE TRIBUFF_S_6U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_6U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_6U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1214(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_6U ----

//---- MODULE BUFD ----
/*--------------------------------------------------------------------
 CELL NAME : BUFD
 CELL TYPE : comb
 CELL LOGIC : Y=A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BUFD(Y,A);
 input A;
 output Y;

 buf	BUF_U_00(Y,A);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BUFD ----

//---- MODULE INVD ----
/*--------------------------------------------------------------------
 CELL NAME : INVD
 CELL TYPE : comb
 CELL LOGIC : Y=!A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INVD(Y,A);
 input A;
 output Y;

 not	INV_U_00(Y,A);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INVD ----

//---- MODULE IOIN_IR ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IR
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IR(ICLK, Y,YIN);
 input YIN,ICLK;
 output Y;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Y, YIN,ICLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IR ----

//---- MODULE IOIN_IRE ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IRE
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, E=ICE, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IRE(ICE, ICLK, Y,YIN);
 input YIN,ICE,ICLK;
 output Y;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(ICE_0, ICE);

 Dffpr DF_0(Y, YIN,ICLK,VCC_0, VCC_0, ICE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,ICE);
      buf U_c2 (Enable02, ICE);
      buf U_c4 (Enable04, ICE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IRE ----

//---- MODULE IOTRI_OB_ER ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_ER
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_ER(OCLK, EOUT,DOUT,E,D);
 input E,D,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_ER ----

//---- MODULE IOTRI_OB_ERE ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_ERE
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, E=OCE, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_ERE(OCE, OCLK, EOUT,DOUT,E,D);
 input E,D,OCE,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,OCE);
      buf U_c2 (Enable02, OCE);
      buf U_c4 (Enable04, OCE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_ERE ----

//---- MODULE IOTRI_OR_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OR_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OR_EB(OCLK, DOUT,EOUT,D,E);
 input D,E,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OR_EB ----

//---- MODULE IOTRI_ORE_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_ORE_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, E=OCE, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORE_EB(OCE, OCLK, DOUT,EOUT,D,E);
 input D,E,OCE,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, VCC_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,OCE);
      buf U_c2 (Enable02, OCE);
      buf U_c4 (Enable04, OCE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORE_EB ----

//---- MODULE IOTRI_ORE_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_ORE_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORE_ERE(EOUT,DOUT,E,OCLK,OCE,D);
 input E,OCLK,OCE,D;
 output EOUT,DOUT;
 supply1 VCC_0;

 supply1 VCC_1;


 reg NOTIFY_REG;

 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);


// some temp signals created for timing checking sections

      buf U_c0 (Enable01,OCE);
      buf U_c2 (Enable02, OCE);
      buf U_c4 (Enable04, OCE);

      buf U_c3 (Enable11,OCE);
      buf U_c5 (Enable12, OCE);
      buf U_c6 (Enable14, OCE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORE_ERE ----

//---- MODULE IOTRI_OR_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_OR_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OR_ER(EOUT,DOUT,E,OCLK,D);
 input E,OCLK,D;
 output EOUT,DOUT;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;


 reg NOTIFY_REG;


 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OR_ER ----

//---- MODULE IOBI_IB_OB_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_ER(DOUT,Y,EOUT,D,YIN,E,OCLK);
 input D,YIN,E,OCLK;
 output DOUT,Y,EOUT;


 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(Y,YIN);


 Dffpr DF_2(EOUT, E,OCLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_ER ----

//---- MODULE IOBI_IB_OB_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_ERE(DOUT,Y,EOUT,D,YIN,E,OCLK,OCE);
 input D,YIN,E,OCLK,OCE;
 output DOUT,Y,EOUT;


 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(Y,YIN);

 not INV_EN_2(OCE_2, OCE);

 Dffpr DF_2(EOUT, E,OCLK,VCC_2, VCC_2, OCE_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable21,OCE);
      buf U_c2 (Enable22, OCE);
      buf U_c4 (Enable24, OCE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_ERE ----

//---- MODULE IOBI_IB_OR_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOBI_IB_OR_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, D=D ];
 CELL COMB EQN : "EOUT = E, Y = YIN"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OR_EB(OCLK, DOUT,Y, EOUT,D,E, YIN);
 input D,E,OCLK,YIN;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);
 buf U0 (Y,YIN);

	// create the sequential logic -- DFF flip-flop plus comb input logic

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

        (YIN => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OR_EB ----

//---- MODULE IOBI_IB_ORE_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORE_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORE_EB(EOUT,Y,DOUT,E,YIN,D,OCLK,OCE);
 input E,YIN,D,OCLK,OCE;
 output EOUT,Y,DOUT;


 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 buf	BUF_U_10(Y,YIN);

 not INV_EN_2(OCE_2, OCE);

 Dffpr DF_2(DOUT, D,OCLK,VCC_2, VCC_2, OCE_2, NOTIFY_REG);




// some temp signals created for timing checking sections

      buf U_c0 (Enable21,OCE);
      buf U_c2 (Enable22, OCE);
      buf U_c4 (Enable24, OCE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORE_EB ----

//---- MODULE IOBI_IB_OR_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OR_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OR_ER(Y,DOUT,EOUT,YIN,D,OCLK,E);
 input YIN,D,OCLK,E;
 output Y,DOUT,EOUT;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(Y,YIN);


 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);
 Dffpr DF_2(EOUT, E,OCLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OR_ER ----

//---- MODULE IOBI_IB_ORE_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORE_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORE_ERE(Y,DOUT,EOUT,YIN,D,OCLK,OCE,E);
 input YIN,D,OCLK,OCE,E;
 output Y,DOUT,EOUT;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(Y,YIN);
 not INV_EN_1(OCE_1, OCE);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);
 not INV_EN_2(OCE_2, OCE);
 Dffpr DF_2(EOUT, E,OCLK,VCC_2, VCC_2, OCE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      buf U_c0 (Enable11,OCE);
      buf U_c2 (Enable12, OCE);
      buf U_c4 (Enable14, OCE);

      buf U_c1 (Enable21,OCE);
      buf U_c3 (Enable22, OCE);
      buf U_c5 (Enable24, OCE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
	specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, negedge E,0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORE_ERE ----

//---- MODULE IOBI_IR_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK);
 input D,E,YIN,ICLK;
 output DOUT,EOUT,Y;


 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(EOUT,E);


 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_OB_EB ----

//---- MODULE IOBI_IRE_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK,ICE);
 input D,E,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;


 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);
 buf	BUF_U_10(EOUT,E);
 not INV_EN_2(ICE_2, ICE);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable21,ICE);
      buf U_c2 (Enable22, ICE);
      buf U_c4 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_OB_EB ----

//---- MODULE IOBI_IR_OB_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_OB_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_OB_ER(DOUT,EOUT,Y,D,E,OCLK,YIN,ICLK);
 input D,E,OCLK,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);


 Dffpr DF_1(EOUT, E,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_OB_ER ----

//---- MODULE IOBI_IRE_OB_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_OB_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_OB_ER(DOUT,EOUT,Y,D,E,OCLK,YIN,ICLK,ICE);
 input D,E,OCLK,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);


 Dffpr DF_1(EOUT, E,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      buf U_c0 (Enable21,ICE);
      buf U_c2 (Enable22, ICE);
      buf U_c4 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_OB_ER ----

//---- MODULE IOBI_IR_OB_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_OB_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_OB_ERE(DOUT,EOUT,Y,D,E,OCLK,OCE,YIN,ICLK);
 input D,E,OCLK,OCE,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      buf U_c0 (Enable11,OCE);
      buf U_c2 (Enable12, OCE);
      buf U_c4 (Enable14, OCE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_OB_ERE ----

//---- MODULE IOBI_IRE_OB_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_OB_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_OB_ERE(DOUT,EOUT,Y,D,E,OCLK,OCE,YIN,ICLK,ICE);
 input D,E,OCLK,OCE,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      buf U_c0 (Enable11,OCE);
      buf U_c2 (Enable12, OCE);
      buf U_c4 (Enable14, OCE);

      buf U_c1 (Enable21,ICE);
      buf U_c3 (Enable22, ICE);
      buf U_c5 (Enable24, ICE);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

	//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_OB_ERE ----

//---- MODULE IOBI_IR_OR_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_OR_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_OR_EB(EOUT,DOUT,Y,E,D,OCLK,YIN,ICLK);
 input E,D,OCLK,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);


 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_OR_EB ----

//---- MODULE IOBI_IRE_OR_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_OR_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_OR_EB(EOUT,DOUT,Y,E,D,OCLK,YIN,ICLK,ICE);
 input E,D,OCLK,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);


 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);
 not INV_EN_2(ICE_2, ICE);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable21,ICE);
      buf U_c2 (Enable22, ICE);
      buf U_c4 (Enable24, ICE);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_OR_EB ----

//---- MODULE IOBI_IR_ORE_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_ORE_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_ORE_EB(EOUT,DOUT,Y,E,D,OCLK,OCE,YIN,ICLK);
 input E,D,OCLK,OCE,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);
 not INV_EN_1(OCE_1, OCE);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable11,OCE);
      buf U_c2 (Enable12, OCE);
      buf U_c4 (Enable14, OCE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_ORE_EB ----

//---- MODULE IOBI_IRE_ORE_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_ORE_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_ORE_EB(EOUT,DOUT,Y,E,D,OCLK,OCE,YIN,ICLK,ICE);
 input E,D,OCLK,OCE,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);
 not INV_EN_1(OCE_1, OCE);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);
 not INV_EN_2(ICE_2, ICE);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable11,OCE);
      buf U_c2 (Enable12, OCE);
      buf U_c4 (Enable14, OCE);

      buf U_c1 (Enable21,ICE);
      buf U_c3 (Enable22, ICE);
      buf U_c5 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_ORE_EB ----

//---- MODULE IOBI_IR_OR_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_OR_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_OR_ER(EOUT,DOUT,Y,E,OCLK,D,YIN,ICLK);
 input E,OCLK,D,YIN,ICLK;
 output EOUT,DOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;


 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_OR_ER ----

//---- MODULE IOBI_IR_ORE_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_ORE_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_ORE_ERE(EOUT,DOUT,Y,E,OCLK,OCE,D,YIN,ICLK);
 input E,OCLK,OCE,D,YIN,ICLK;
 output EOUT,DOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);


 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      buf U_c0 (Enable01,OCE);
      buf U_c2 (Enable02, OCE);
      buf U_c4 (Enable04, OCE);

      buf U_c1 (Enable11,OCE);
      buf U_c3 (Enable12, OCE);
      buf U_c5 (Enable14, OCE);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_ORE_ERE ----

//---- MODULE IOBI_IRE_OR_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_OR_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_OR_ER(EOUT,DOUT,Y,E,OCLK,D,YIN,ICLK,ICE);
 input E,OCLK,D,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;


 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);
 not INV_EN_2(ICE_2, ICE);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);

      buf U_c0 (Enable21,ICE);
      buf U_c2 (Enable22, ICE);
      buf U_c4 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_OR_ER ----

//---- MODULE IOBI_IRE_ORE_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_ORE_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_ORE_ERE(EOUT,DOUT,Y,E,OCLK,OCE,D,YIN,ICLK,ICE);
 input E,OCLK,OCE,D,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, OCE_0, NOTIFY_REG);
 not INV_EN_1(OCE_1, OCE);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);
 not INV_EN_2(ICE_2, ICE);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,OCE);
      buf U_c2 (Enable02, OCE);
      buf U_c4 (Enable04, OCE);

      buf U_c1 (Enable11,OCE);
      buf U_c3 (Enable12, OCE);
      buf U_c5 (Enable14, OCE);

      buf U_c6 (Enable21,ICE);
      buf U_c7 (Enable22, ICE);
      buf U_c8 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);


	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_ORE_ERE ----

//---- MODULE CLKBIBUF ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBIBUF
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E % Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBIBUF(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1583(PAD, D, E);
 buf    BUF_U1(Y,PAD);

        specify
		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
                specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
                specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
                specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
                specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
                specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
                specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
                specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
                specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
                specparam MacroType = "comb";

                //pin to pin path delay

            //if (~D)
                (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

                (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
                (D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                (E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

        endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBIBUF ----

//---- MODULE DDR_OUT ----
/*--------------------------------------------------------------------
 CELL NAME  : DDR_OUT
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DDR_OUT(Q,CLK,CLR,DR,DF);
input CLK,CLR,DR,DF;
output Q;

wire tmp_out0,tmp_out1;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);

    Dffpr DF_1(tmp_out0, DR,CLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp_out1, DF,CLK,CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(Q,tmp_out0,tmp_out1,CLK);



 specify

         specparam   LibName     = "fusion";
         specparam   InputLoad$DR = 2;
         specparam   InputLoad$DF = 2;
         specparam   InputLoad$CLR = 6;
         specparam   InputLoad$CLK = 2;
         specparam   OutputLoad$Q = 2;

         specparam   MacroType = "ddr_out";

          //check timing delay for output

        (CLK => Q)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (Q +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge DR,posedge CLK,0.0, NOTIFY_REG);
        $setup(negedge DR,posedge CLK,0.0, NOTIFY_REG);
        $hold(posedge CLK,posedge DR,0.0, NOTIFY_REG);
        $hold(posedge CLK,negedge DR,0.0, NOTIFY_REG);

        $setup(posedge DF,posedge CLK,0.0, NOTIFY_REG);
        $setup(negedge DF,posedge CLK,0.0, NOTIFY_REG);
        $hold(posedge CLK,negedge DF,0.0, NOTIFY_REG);
        $hold(posedge CLK,posedge DF,0.0, NOTIFY_REG);

           //checking timing for control signals


        $hold(posedge CLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge CLK,0,  0, NOTIFY_REG);
        $width(negedge CLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge CLK, 0.0, NOTIFY_REG);


    endspecify


endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DDR_OUT ----

//---- MODULE DDR_REG ----
/*--------------------------------------------------------------------
 CELL NAME  : DDR_REG
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DDR_REG(D,CLK,CLR,QR,QF);
input D, CLR, CLK;
output QR,QF;

wire tmp_out;
supply1 VCC;
supply0 GND;
reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);
  
    Dffpf DF_0(tmp_out, D,       CLK, VCC,  VCC, GND, NOTIFY_REG);
    Dffpr DF_1(QF,      tmp_out, CLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(QR,      D,       CLK, CLR_, VCC, GND, NOTIFY_REG);


 specify

         specparam   LibName     = "fusion";
         specparam   InputLoad$YIN = 2;
         specparam   InputLoad$CLR = 6;
         specparam   InputLoad$ICLK = 2;
         specparam   OutputLoad$YR = 2;
         specparam   OutputLoad$YF = 2;

         specparam   MacroType = "ddr";
         specparam   SeqType   = "flipflop";

          //check timing delay for output

        (posedge CLK => (QR +: D))=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (QR +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (CLK => QF) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (QF +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge D,posedge CLK,0.0, NOTIFY_REG);
        $setup(negedge D,posedge CLK,0.0, NOTIFY_REG);
        $hold(posedge CLK,posedge D,0.0, NOTIFY_REG);
        $hold(posedge CLK,negedge D,0.0, NOTIFY_REG);

        $setup(posedge D,negedge CLK,0.0, NOTIFY_REG);
        $setup(negedge D,negedge CLK,0.0, NOTIFY_REG);
        $hold(negedge CLK,negedge D,0.0, NOTIFY_REG);
        $hold(negedge CLK,posedge D,0.0, NOTIFY_REG);


        //checking timing for control signals


        $hold(posedge CLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge CLK,0,  0, NOTIFY_REG);
        $width(negedge CLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge CLK, 0.0, NOTIFY_REG);


    endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DDR_REG ----

//---- MODULE IOBI_ID_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME  : IOBI_ID_OB_EB
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_ID_OB_EB(D, CLR, E, ICLK, YIN, DOUT, EOUT, YR, YF);
input D, CLR, E, ICLK, YIN;
output DOUT, EOUT, YR, YF;

wire tmp_zd;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    buf buf_D(DOUT, D);
    buf buf_E(EOUT, E);
 
    not INV_CLR(CLR_, CLR);
    Dffpf DF_1(tmp_zd, YIN,    ICLK, VCC,  VCC, GND, NOTIFY_REG);
    Dffpr DF_2(YF,     tmp_zd, ICLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_3(YR,     YIN,    ICLK, CLR_, VCC, GND, NOTIFY_REG);

    specify

        //check timing delay for output

        (D => DOUT ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => EOUT ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        
        (posedge CLR  => (YF +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR  => (YR +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        //(posedge ICLK => (YF +: YIN))  = (0.1:0.1:0.1, 0.1:0.1:0.1); // is this right??? no, negedge; no-edge is safe 
        (ICLK => YF) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge ICLK => (YR +: YIN))  = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge YIN, posedge ICLK, 0.0, NOTIFY_REG);
        $setup(negedge YIN, posedge ICLK, 0.0, NOTIFY_REG);
        $hold(posedge ICLK, posedge YIN, 0.0, NOTIFY_REG);
        $hold(posedge ICLK, negedge YIN, 0.0, NOTIFY_REG);

        $setup(posedge YIN, negedge ICLK, 0.0, NOTIFY_REG);
        $setup(negedge YIN, negedge ICLK, 0.0, NOTIFY_REG);
        $hold(negedge ICLK, negedge YIN, 0.0, NOTIFY_REG);
        $hold(negedge ICLK, posedge YIN, 0.0, NOTIFY_REG);

        $recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);
        $hold(posedge ICLK, negedge CLR, 0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge ICLK, 0, 0, NOTIFY_REG);
        $width(negedge ICLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR,  0, 0, NOTIFY_REG);

    endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_ID_OB_EB ----

//---- MODULE IOBI_ID_OD_EB ----
/*--------------------------------------------------------------------
 CELL NAME  : IOBI_ID_OD_EB
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_ID_OD_EB(E,DOUT,OCLK,CLR,DR,DF,YR,YF,ICLK,YIN,EOUT);
input YIN,E,OCLK,CLR,DR,DF,ICLK;
output DOUT,EOUT,YR,YF;

wire tmp_out, tmp_out0,tmp_out1;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);
    buf buf_inst(EOUT,E);
 
    Dffpr DF_1(tmp_out0, DR,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp_out1, DF,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(DOUT,tmp_out0,tmp_out1,OCLK);

    Dffpf DF_3(tmp_out, YIN,     ICLK, VCC,  VCC, GND, NOTIFY_REG);
    Dffpr DF_4(YF,      tmp_out, ICLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_5(YR,      YIN,     ICLK, CLR_, VCC, GND, NOTIFY_REG);




    specify

        //check timing delay for output

        (posedge ICLK => (YR +: YIN))=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YR +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YF +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (ICLK => YF) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (DOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (OCLK => DOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => EOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $hold(posedge ICLK,posedge YIN,0.0, NOTIFY_REG);
        $hold(posedge ICLK,negedge YIN,0.0, NOTIFY_REG);

        $setup(posedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $hold(negedge ICLK,negedge YIN,0.0, NOTIFY_REG);
        $hold(negedge ICLK,posedge YIN,0.0, NOTIFY_REG);


        //checking timing for control signals


        $hold(posedge ICLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge ICLK,0,  0, NOTIFY_REG);
        $width(negedge ICLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);

        //checking setup and hold timing for inputs

        $setup(posedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DR,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DR,0.0, NOTIFY_REG);

        $setup(posedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DF,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DF,0.0, NOTIFY_REG);

      //checking timing for control signals


        $hold(posedge OCLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge OCLK,0,  0, NOTIFY_REG);
        $width(negedge OCLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);



    endspecify


endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_ID_OD_EB ----

//---- MODULE IOBI_ID_OD_ERC ----
/*--------------------------------------------------------------------
 CELL NAME  : IOBI_ID_OD_ERC
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_ID_OD_ERC(E,DOUT,OCLK,CLR,DR,DF,YR,YF,ICLK,YIN,EOUT);
input E,OCLK,CLR,DR,DF,YIN,ICLK;
output DOUT,EOUT,YR,YF;

wire tmp_out, tmp_out0,tmp_out1;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);

    Dffpr DF_1(tmp_out0, DR,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp_out1, DF,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(DOUT,tmp_out0,tmp_out1,OCLK);

    Dffpf DF_3(tmp_out, YIN,     ICLK, VCC,  VCC, GND, NOTIFY_REG);
    Dffpr DF_4(YF,      tmp_out, ICLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_5(YR,      YIN,     ICLK, CLR_, VCC, GND, NOTIFY_REG);

    Dffpr DF_6(EOUT, E,OCLK,CLR_, VCC, GND, NOTIFY_REG);



   specify

        //check timing delay for output

        (posedge ICLK => (YR +: YIN))=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YR +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YF +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (ICLK => YF) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (DOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (OCLK => DOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (EOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (OCLK => EOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $hold(posedge ICLK,posedge YIN,0.0, NOTIFY_REG);
        $hold(posedge ICLK,negedge YIN,0.0, NOTIFY_REG);

        $setup(posedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $hold(negedge ICLK,negedge YIN,0.0, NOTIFY_REG);
        $hold(negedge ICLK,posedge YIN,0.0, NOTIFY_REG);


        //checking timing for control signals


        $hold(posedge ICLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge ICLK,0,  0, NOTIFY_REG);
        $width(negedge ICLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


        $setup(posedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DR,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DR,0.0, NOTIFY_REG);

        $setup(posedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DF,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DF,0.0, NOTIFY_REG);

      //checking timing for control signals


        $hold(posedge OCLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge OCLK,0,  0, NOTIFY_REG);
        $width(negedge OCLK, 0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

        $setup(posedge E,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge E,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge E,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge E,0.0, NOTIFY_REG);


    endspecify


endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_ID_OD_ERC ----

//---- MODULE IOIN_ID ----
/*--------------------------------------------------------------------
 CELL NAME  : IOIN_ID
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_ID(YIN,ICLK,CLR,YR,YF);
input YIN, CLR, ICLK;
output YR,YF;

wire tmp_out;
supply1 VCC;
supply0 GND;
reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);
   
    Dffpf DF_0(tmp_out, YIN,     ICLK, VCC,  VCC, GND, NOTIFY_REG);
    Dffpr DF_1(YF,      tmp_out, ICLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(YR,      YIN,     ICLK, CLR_, VCC, GND, NOTIFY_REG);


 specify

         specparam   LibName     = "fusion";
         specparam   InputLoad$YIN = 2;
         specparam   InputLoad$CLR = 6;
         specparam   InputLoad$ICLK = 2;
         specparam   OutputLoad$YR = 2;
         specparam   OutputLoad$YF = 2;

         specparam   MacroType = "ddr";
         specparam   SeqType   = "flipflop";

          //check timing delay for output

        (posedge ICLK => (YR +: YIN))=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YR +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (ICLK => YF) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YF +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $hold(posedge ICLK,posedge YIN,0.0, NOTIFY_REG);
        $hold(posedge ICLK,negedge YIN,0.0, NOTIFY_REG);

        $setup(posedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $hold(negedge ICLK,negedge YIN,0.0, NOTIFY_REG);
        $hold(negedge ICLK,posedge YIN,0.0, NOTIFY_REG);


        //checking timing for control signals


        $hold(posedge ICLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge ICLK,0,  0, NOTIFY_REG);
        $width(negedge ICLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


    endspecify


endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_ID ----

//---- MODULE IOTRI_OD_EB ----
/*--------------------------------------------------------------------
 CELL NAME  : IOTRI_OD_EB
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OD_EB(E,EOUT,DOUT,OCLK,CLR,DR,DF);
input E,OCLK,CLR,DR,DF;
output DOUT, EOUT;

wire tmp_out0,tmp_out1;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);
    buf buf_inst(EOUT,E);
   
    Dffpr DF_1(tmp_out0, DR,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp_out1, DF,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(DOUT,tmp_out0,tmp_out1,OCLK);

specify

         specparam   LibName     = "fusion";
         specparam   InputLoad$DR = 2;
         specparam   InputLoad$DF = 2;
         specparam   InputLoad$CLR = 6;
         specparam   InputLoad$OCLK = 2;
         specparam   OutputLoad$DOUT = 2;

         specparam   MacroType = "ddr";
         specparam   SeqType   = "flipflop";

          //check timing delay for output

        (OCLK => DOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (DOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => EOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DR,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DR,0.0, NOTIFY_REG);

        $setup(posedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DF,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DF,0.0, NOTIFY_REG);


        //checking timing for control signals


        $hold(posedge OCLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge OCLK,0,  0, NOTIFY_REG);
        $width(negedge OCLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


    endspecify


endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OD_EB ----

//---- MODULE IOTRI_OD_ERC ----
/*--------------------------------------------------------------------
 CELL NAME  : IOTRI_OD_ERC
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OD_ERC(E,EOUT,DOUT,OCLK,CLR,DR,DF);
input E,OCLK,CLR,DR,DF;
output DOUT, EOUT;

wire tmp_out0,tmp_out1;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);

    Dffpr DF_0(EOUT,E,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_1(tmp_out0, DR,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp_out1, DF,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(DOUT,tmp_out0,tmp_out1,OCLK);



 specify

         specparam   LibName     = "fusion";
         specparam   InputLoad$DR = 2;
         specparam   InputLoad$DF = 2;
         specparam   InputLoad$CLR = 6;
         specparam   InputLoad$OCLK = 2;
         specparam   OutputLoad$DOUT = 2;

         specparam   MacroType = "ddr";
         specparam   SeqType   = "flipflop";

          //check timing delay for output

        (OCLK => DOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (OCLK => EOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (DOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (EOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DR,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DR,0.0, NOTIFY_REG);

        $setup(posedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DF,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DF,0.0, NOTIFY_REG);

        //checking timing for control signals

        $hold(posedge   OCLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge OCLK,0,  0, NOTIFY_REG);
        $width(negedge OCLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

        $setup(posedge E,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge E,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge E,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge E,0.0, NOTIFY_REG);

   endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OD_ERC ----

//---- MODULE FIFO4K18 ----
/*---------------------------------------------------------------
 CELL NAME : FIFO4K18
 CELL TYPE : FIFO
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 100 ps / 10 ps

module FIFO4K18 (AEVAL11, AEVAL10, AEVAL9, AEVAL8, AEVAL7, AEVAL6, 
                 AEVAL5, AEVAL4, AEVAL3, AEVAL2, AEVAL1, AEVAL0, 
                 AFVAL11, AFVAL10, AFVAL9, AFVAL8, AFVAL7, AFVAL6, 
                 AFVAL5, AFVAL4, AFVAL3, AFVAL2, AFVAL1, AFVAL0, 
                 REN, RBLK, RCLK, RESET, RPIPE, WEN, WBLK, WCLK,
                 RW2, RW1, RW0, WW2, WW1, WW0, ESTOP, FSTOP,
                 WD17, WD16, WD15, WD14, WD13, WD12, WD11, WD10, 
                 WD9, WD8, WD7, WD6, WD5, WD4, WD3, WD2, WD1, WD0, 
                 RD17, RD16, RD15, RD14, RD13, RD12, RD11, RD10, 
                 RD9, RD8, RD7, RD6, RD5, RD4, RD3, RD2, RD1, RD0, 
                 FULL, AFULL, EMPTY, AEMPTY
                );
`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif

input AEVAL11, AEVAL10, AEVAL9, AEVAL8, AEVAL7, AEVAL6;
input AEVAL5, AEVAL4, AEVAL3, AEVAL2, AEVAL1, AEVAL0;
input AFVAL11, AFVAL10, AFVAL9, AFVAL8, AFVAL7, AFVAL6;
input AFVAL5, AFVAL4, AFVAL3, AFVAL2, AFVAL1, AFVAL0;
input REN, RBLK, RCLK, RESET, RPIPE, WEN, WBLK, WCLK;
input RW2, RW1, RW0, WW2, WW1, WW0, ESTOP, FSTOP;
input WD17, WD16, WD15, WD14, WD13, WD12, WD11, WD10;
input WD9, WD8, WD7, WD6, WD5, WD4, WD3, WD2, WD1, WD0;

output RD17, RD16, RD15, RD14, RD13, RD12, RD11, RD10;
output RD9, RD8, RD7, RD6, RD5, RD4, RD3, RD2, RD1, RD0;
output FULL, AFULL, EMPTY, AEMPTY;

reg FULLP, AFULLP, EMPTYP, AEMPTYP;
reg [18:0] FIFO[0:512];
reg NOTIFY_REG;

wire AEVAL11_int, AEVAL10_int, AEVAL9_int, AEVAL8_int, AEVAL7_int;
wire AEVAL6_int, AEVAL5_int, AEVAL4_int, AEVAL3_int, AEVAL2_int;
wire AEVAL1_int, AEVAL0_int;
wire AFVAL11, AFVAL10_int, AFVAL9_int, AFVAL8_int, AFVAL7_int;
wire AFVAL6_int, AFVAL5_int, AFVAL4_int, AFVAL3_int, AFVAL2_int;
wire AFVAL1_int, AFVAL0_int;
wire REN_int, RBLK_int, RCLK_int, RESET_int, RPIPE_int;
wire WEN_int, WBLK_int, WCLK_int;
wire RW2_int, RW1_int, RW0_int;
wire WW2_int, WW1_int, WW0_int;
wire ESTOP_int, FSTOP_int;  
wire WD17_int, WD16_int, WD15_int, WD14_int, WD13_int, WD12_int;
wire WD11_int, WD10_int, WD9_int, WD8_int, WD7_int, WD6_int;
wire WD5_int, WD4_int, WD3_int, WD2_int, WD1_int, WD0_int;

reg RDP17, RDP16, RDP15, RDP14, RDP13, RDP12, RDP11, RDP10, RDP9;
reg RDP8, RDP7, RDP6, RDP5, RDP4, RDP3, RDP2, RDP1, RDP0;

reg RD17_stg, RD16_stg, RD15_stg, RD14_stg, RD13_stg, RD12_stg;
reg RD11_stg, RD10_stg, RD9_stg, RD8_stg, RD7_stg;
reg RD6_stg, RD5_stg, RD4_stg, RD3_stg, RD2_stg, RD1_stg, RD0_stg;

`define RDATAP_WIDTH_18 {RDP17, RDP16, RDP15, RDP14, RDP13, RDP12, RDP11, RDP10, RDP9, RDP8, RDP7, RDP6, RDP5, RDP4, RDP3, RDP2, RDP1, RDP0}
`define RWIDTH_CFG_VECTOR {RW2_int, RW1_int, RW0_int}
`define WWIDTH_CFG_VECTOR {WW2_int, WW1_int, WW0_int}
`define AEMPTY_CFG_VECTOR {AEVAL11_int, AEVAL10_int, AEVAL9_int, AEVAL8_int, AEVAL7_int, AEVAL6_int, AEVAL5_int, AEVAL4_int, AEVAL3_int, AEVAL2_int, AEVAL1_int, AEVAL0_int}
`define AFULL_CFG_VECTOR  {AFVAL11_int, AFVAL10_int, AFVAL9_int, AFVAL8_int, AFVAL7_int, AFVAL6_int, AFVAL5_int, AFVAL4_int, AFVAL3_int, AFVAL2_int, AFVAL1_int, AFVAL0_int}

integer MAX_DEPTH;

reg [4095:0] MEM;
reg [511 :0] MEM9;

wire WENABLE; 
wire RENABLE; 

buf AFU0  (AFVAL0_int,  AFVAL0);
buf AFU1  (AFVAL1_int,  AFVAL1);
buf AFU2  (AFVAL2_int,  AFVAL2);
buf AFU3  (AFVAL3_int,  AFVAL3);
buf AFU4  (AFVAL4_int,  AFVAL4);
buf AFU5  (AFVAL5_int,  AFVAL5);
buf AFU6  (AFVAL6_int,  AFVAL6);
buf AFU7  (AFVAL7_int,  AFVAL7);
buf AFU8  (AFVAL8_int,  AFVAL8);
buf AFU9  (AFVAL9_int,  AFVAL9);
buf AFU10 (AFVAL10_int, AFVAL10);
buf AFU11 (AFVAL11_int, AFVAL11);

buf AEU0  (AEVAL0_int,  AEVAL0);
buf AEU1  (AEVAL1_int,  AEVAL1);
buf AEU2  (AEVAL2_int,  AEVAL2);
buf AEU3  (AEVAL3_int,  AEVAL3);
buf AEU4  (AEVAL4_int,  AEVAL4);
buf AEU5  (AEVAL5_int,  AEVAL5);
buf AEU6  (AEVAL6_int,  AEVAL6);
buf AEU7  (AEVAL7_int,  AEVAL7);
buf AEU8  (AEVAL8_int,  AEVAL8);
buf AEU9  (AEVAL9_int,  AEVAL9);
buf AEU10 (AEVAL10_int, AEVAL10);
buf AEU11 (AEVAL11_int, AEVAL11);

buf WDU0  (WD0_int,     WD0);
buf WDU1  (WD1_int,     WD1);
buf WDU2  (WD2_int,     WD2);
buf WDU3  (WD3_int,     WD3);
buf WDU4  (WD4_int,     WD4);
buf WDU5  (WD5_int,     WD5);
buf WDU6  (WD6_int,     WD6);
buf WDU7  (WD7_int,     WD7);
buf WDU8  (WD8_int,     WD8);
buf WDU9  (WD9_int,     WD9);
buf WDU10 (WD10_int,    WD10);
buf WDU11 (WD11_int,    WD11);
buf WDU12 (WD12_int,    WD12);
buf WDU13 (WD13_int,    WD13);
buf WDU14 (WD14_int,    WD14);
buf WDU15 (WD15_int,    WD15);
buf WDU16 (WD16_int,    WD16);
buf WDU17 (WD17_int,    WD17);

buf WWU2  (WW2_int,     WW2);
buf WWU1  (WW1_int,     WW1);
buf WWU0  (WW0_int,     WW0);

buf RWU2  (RW2_int,     RW2);
buf RWU1  (RW1_int,     RW1);
buf RWU0  (RW0_int,     RW0);

buf RENU  (REN_int,     REN);
buf WENU  (WEN_int,     WEN);
buf RBLKU (RBLK_int,    RBLK);
buf WBLKU (WBLK_int,    WBLK);

buf WCLKU (WCLK_int,    WCLK);
buf RCLKU (RCLK_int,    RCLK);

buf RESETU (RESET_int,  RESET);
buf ESTOPU (ESTOP_int,  ESTOP);
buf FSTOPU (FSTOP_int,  FSTOP);
buf RPIPEU (RPIPE_int,  RPIPE);


pmos RDU0  (RD0,  RDP0,  0);
pmos RDU1  (RD1,  RDP1,  0);
pmos RDU2  (RD2,  RDP2,  0);
pmos RDU3  (RD3,  RDP3,  0);
pmos RDU4  (RD4,  RDP4,  0);
pmos RDU5  (RD5,  RDP5,  0);
pmos RDU6  (RD6,  RDP6,  0);
pmos RDU7  (RD7,  RDP7,  0);
pmos RDU8  (RD8,  RDP8,  0);
pmos RDU9  (RD9,  RDP9,  0);
pmos RDU10 (RD10, RDP10, 0);
pmos RDU11 (RD11, RDP11, 0);
pmos RDU12 (RD12, RDP12, 0);
pmos RDU13 (RD13, RDP13, 0);
pmos RDU14 (RD14, RDP14, 0);
pmos RDU15 (RD15, RDP15, 0);
pmos RDU16 (RD16, RDP16, 0);
pmos RDU17 (RD17, RDP17, 0);

pmos AEMPTYU (AEMPTY, AEMPTYP, 0);
pmos EMPTYU  (EMPTY,  EMPTYP,  0);
pmos AFULLU  (AFULL,  AFULLP,  0);
pmos FULLU   (FULL,   FULLP,   0);

integer MAX_ADDR;
integer WADDR;
integer WADDR_P1;
integer WADDR_P2;
integer RADDR;
integer RADDR_P1;
integer RADDR_P2;
integer BIT_WADDR;
integer BIT_RADDR;
integer WADDR_wrap;
integer WADDR_wrap_P1;
integer WADDR_wrap_P2;
integer RADDR_wrap;
integer RADDR_wrap_P1;
integer RADDR_wrap_P2;

integer AEVAL;
integer AFVAL;

integer wdepth;
integer rdepth;

initial begin
  MAX_DEPTH     <= 4096;
  WADDR         <= 0;
  WADDR_P1      <= 0;
  WADDR_P2      <= 0;
  RADDR         <= 0;
  RADDR_P1      <= 0;
  RADDR_P2      <= 0;
  WADDR_wrap    <= 0;
  WADDR_wrap_P1 <= 0;
  WADDR_wrap_P2 <= 0;
  RADDR_wrap    <= 0;
  RADDR_wrap_P1 <= 1;
  RADDR_wrap_P2 <= 1;
  EMPTYP        <= 1'bx;
  AEMPTYP       <= 1'bx;
  FULLP         <= 1'bx;
  AFULLP        <= 1'bx;
  `RDATAP_WIDTH_18 <= 18'bx;
end

assign WENABLE = RESET_int & ~WEN_int & ~WBLK_int; 
assign RENABLE = RESET_int &  REN_int & ~RBLK_int; 

always @(WCLK_int === 1'bx ) begin
  if ($time > 0) begin
    if (WENABLE == 1'b1) begin
            if ( WARNING_MSGS_ON )
      $display("Warning : WCLK went unknown at time %0.1f\n", $realtime);
    end
  end
end

always @(RCLK_int === 1'bx ) begin
  if ($time > 0) begin
    if (RENABLE == 1'b1) begin
            if ( WARNING_MSGS_ON )
      $display("Warning : RCLK went unknown at time %0.1f\n", $realtime);
    end
  end
end

// FIFO RESET behavior section

always @(RESET_int) begin
  if (RESET_int == 1'b0) begin
    WADDR         <= 0;
    WADDR_P1      <= 0;
    WADDR_P2      <= 0;
    WADDR_wrap    <= 0;
    WADDR_wrap_P1 <= 0;
    WADDR_wrap_P2 <= 0;
    RADDR         <= 0;
    RADDR_P1      <= 0;
    RADDR_P2      <= 0;
    RADDR_wrap    <= 0;
    RADDR_wrap_P1 <= 1;
    RADDR_wrap_P2 <= 1;
    FULLP         <= 1'b0;
    EMPTYP        <= 1'b1;
    AFULLP        <= 1'b0;
    AEMPTYP       <= 1'b1;
    `RDATAP_WIDTH_18 <= 18'b0;
    RD0_stg       <= 1'b0;
    RD1_stg       <= 1'b0;
    RD2_stg       <= 1'b0;
    RD3_stg       <= 1'b0;
    RD4_stg       <= 1'b0;
    RD5_stg       <= 1'b0;
    RD6_stg       <= 1'b0;
    RD7_stg       <= 1'b0;
    RD8_stg       <= 1'b0;
    RD9_stg       <= 1'b0;
    RD10_stg      <= 1'b0;
    RD11_stg      <= 1'b0;
    RD12_stg      <= 1'b0;
    RD13_stg      <= 1'b0;
    RD14_stg      <= 1'b0;
    RD15_stg      <= 1'b0;
    RD16_stg      <= 1'b0;
    RD17_stg      <= 1'b0;
  end else if (RESET_int == 1'bx) begin
    if ($time > 0) begin
            if ( WARNING_MSGS_ON )
      $display("Warning : RESET went unknown at time %0.1f\n", $realtime);
    end
  end
end

// FIFO WRITE behavior section

always @(posedge WCLK_int ) begin
  if (RESET_int == 1'b1) begin
    // Synchronizer needs two WCLKs to generate empty flag
    RADDR_P2 = RADDR_P1;
    RADDR_P1 = RADDR;
    RADDR_wrap_P2 = RADDR_wrap_P1;
    if (RADDR_wrap == 0) 
      RADDR_wrap_P1 = 1;
    else
      RADDR_wrap_P1 = 0;

    if ((WBLK_int == 1'b0) && (WEN_int == 1'b0)) begin
      if ( ! ((FULLP == 1'b1) && (FSTOP_int == 1'b1))) begin
        case (`WWIDTH_CFG_VECTOR)
          3'b000 : begin
            MEM[WADDR] <= WD0_int;
            wdepth = 4096;
            if (WADDR < wdepth - 1 ) begin
              WADDR = #0 WADDR + 1;
            end else begin
              WADDR = #0 0;
              WADDR_wrap = 1 - WADDR_wrap;
            end
          end
          3'b001 : begin
            MEM[(WADDR * 2) + 0] <= WD0_int;
            MEM[(WADDR * 2) + 1] <= WD1_int;
            wdepth = 2048;
            if (WADDR < wdepth - 1 ) begin
              WADDR = #0 WADDR + 1;
            end else begin
              WADDR = #0 0;
              WADDR_wrap = 1 - WADDR_wrap;
            end
          end
          3'b010 : begin
            MEM[(WADDR * 4) + 0] <= WD0_int;
            MEM[(WADDR * 4) + 1] <= WD1_int;
            MEM[(WADDR * 4) + 2] <= WD2_int;
            MEM[(WADDR * 4) + 3] <= WD3_int;
            wdepth = 1024; 
            if (WADDR < wdepth - 1 ) begin
              WADDR = #0 WADDR + 1;
            end else begin
              WADDR = #0 0;
              WADDR_wrap = 1 - WADDR_wrap;
            end
          end
          3'b011 : begin
            MEM[(WADDR * 8) + 0] <= WD0_int;
            MEM[(WADDR * 8) + 1] <= WD1_int;
            MEM[(WADDR * 8) + 2] <= WD2_int;
            MEM[(WADDR * 8) + 3] <= WD3_int;
            MEM[(WADDR * 8) + 4] <= WD4_int;
            MEM[(WADDR * 8) + 5] <= WD5_int;
            MEM[(WADDR * 8) + 6] <= WD6_int;
            MEM[(WADDR * 8) + 7] <= WD7_int;
            MEM9[WADDR] = WD8_int;
            wdepth = 512; 
            if (WADDR < wdepth - 1 ) begin
              WADDR = #0 WADDR + 1;
            end else begin
              WADDR = #0 0;
              WADDR_wrap = 1 - WADDR_wrap;
            end
          end
          3'b100 : begin
            MEM[(WADDR * 16) + 0] <= WD0_int;
            MEM[(WADDR * 16) + 1] <= WD1_int;
            MEM[(WADDR * 16) + 2] <= WD2_int;
            MEM[(WADDR * 16) + 3] <= WD3_int;
            MEM[(WADDR * 16) + 4] <= WD4_int;
            MEM[(WADDR * 16) + 5] <= WD5_int;
            MEM[(WADDR * 16) + 6] <= WD6_int;
            MEM[(WADDR * 16) + 7] <= WD7_int;
            MEM9[WADDR *   2 + 0] <= WD8_int;
            MEM[(WADDR * 16) + 8] <= WD9_int;
            MEM[(WADDR * 16) + 9] <= WD10_int;
            MEM[(WADDR * 16) + 10] <= WD11_int;
            MEM[(WADDR * 16) + 11] <= WD12_int;
            MEM[(WADDR * 16) + 12] <= WD13_int;
            MEM[(WADDR * 16) + 13] <= WD14_int;
            MEM[(WADDR * 16) + 14] <= WD15_int;
            MEM[(WADDR * 16) + 15] <= WD16_int;
            MEM9[WADDR * 2 + 1] <= WD17_int;
            wdepth = 256; 
            if (WADDR < wdepth - 1 ) begin
              WADDR = #0 WADDR + 1;
            end else begin
              WADDR = #0 0;
              WADDR_wrap = 1 - WADDR_wrap;
            end
          end
          default: begin
            if ( WARNING_MSGS_ON )
            $display("Warning: Illegal Write port width configuration");
          end
        endcase
      end // not (FULL and FSTOP)
    end // WBLK = 0 and WEN = 0
    else if (WBLK_int == 1'bx) begin
            if ( WARNING_MSGS_ON )
      $display("Warning: WBLK signal unknown.");
    end else if (WEN_int == 1'bx) begin
            if ( WARNING_MSGS_ON )
      $display("Warning: WEN signal unknown.");
    end
    fifo_flags(`AFULL_CFG_VECTOR, `AEMPTY_CFG_VECTOR, `RWIDTH_CFG_VECTOR,
               `WWIDTH_CFG_VECTOR);
  end // if RESET deasserted
end  // Write section

// FIFO READ behavior section

always @(posedge RCLK_int) begin
  if (RESET_int == 1'b1) begin
    // Synchronizer needs two RCLKs to generate empty flag
    WADDR_P2 = WADDR_P1;
    WADDR_P1 = WADDR;
    WADDR_wrap_P2 = WADDR_wrap_P1;
    WADDR_wrap_P1 = WADDR_wrap;

    if (RPIPE_int == 1'b1) begin // Pipelining on
      RDP0  <= RD0_stg;
      RDP1  <= RD1_stg;
      RDP2  <= RD2_stg;
      RDP3  <= RD3_stg;
      RDP4  <= RD4_stg;
      RDP5  <= RD5_stg;
      RDP6  <= RD6_stg;
      RDP7  <= RD7_stg;
      RDP8  <= RD8_stg;
      RDP9  <= RD9_stg;
      RDP10 <= RD10_stg;
      RDP11 <= RD11_stg;
      RDP12 <= RD12_stg;
      RDP13 <= RD13_stg;
      RDP14 <= RD14_stg;
      RDP15 <= RD15_stg;
      RDP16 <= RD16_stg;
      RDP17 <= RD17_stg;
    end
    else if (RPIPE_int === 1'bx ) begin // RPIPE unknown
            if ( WARNING_MSGS_ON )
      $display("Warning: RPIPE signal unknown.");
      RDP0  <= 1'bx;
      RDP1  <= 1'bx;
      RDP2  <= 1'bx;
      RDP3  <= 1'bx;
      RDP4  <= 1'bx;
      RDP5  <= 1'bx;
      RDP6  <= 1'bx;
      RDP7  <= 1'bx;
      RDP8  <= 1'bx;
      RDP9  <= 1'bx;
      RDP10 <= 1'bx;
      RDP11 <= 1'bx;
      RDP12 <= 1'bx;
      RDP13 <= 1'bx;
      RDP14 <= 1'bx;
      RDP15 <= 1'bx;
      RDP16 <= 1'bx;
      RDP17 <= 1'bx;
    end

    if ((RBLK_int == 1'b0) && (REN_int == 1'b1)) begin
      if ( ! ((EMPTYP == 1'b1) && (ESTOP_int == 1'b1))) begin // OK to Read
        if (RPIPE_int == 1'b0) begin // Pipelining off 
          case (`RWIDTH_CFG_VECTOR)
            3'b000 : begin
              RDP0  <= MEM[RADDR];
              rdepth = 4096;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b001 : begin
              RDP0  <= MEM[(RADDR * 2) + 0];
              RDP1  <= MEM[(RADDR * 2) + 1];
              rdepth = 2048;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b010 : begin
              RDP0  <= MEM[(RADDR * 4) + 0];
              RDP1  <= MEM[(RADDR * 4) + 1];
              RDP2  <= MEM[(RADDR * 4) + 2];
              RDP3  <= MEM[(RADDR * 4) + 3];
              rdepth = 1024;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b011 : begin
              RDP0  <= MEM[(RADDR * 8) + 0];
              RDP1  <= MEM[(RADDR * 8) + 1];
              RDP2  <= MEM[(RADDR * 8) + 2];
              RDP3  <= MEM[(RADDR * 8) + 3];
              RDP4  <= MEM[(RADDR * 8) + 4];
              RDP5  <= MEM[(RADDR * 8) + 5];
              RDP6  <= MEM[(RADDR * 8) + 6];
              RDP7  <= MEM[(RADDR * 8) + 7];
              RDP8  <= MEM9[RADDR];
              rdepth = 512;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b100 : begin
              RDP0  <= MEM[(RADDR * 16) + 0];
              RDP1  <= MEM[(RADDR * 16) + 1];
              RDP2  <= MEM[(RADDR * 16) + 2];
              RDP3  <= MEM[(RADDR * 16) + 3];
              RDP4  <= MEM[(RADDR * 16) + 4];
              RDP5  <= MEM[(RADDR * 16) + 5];
              RDP6  <= MEM[(RADDR * 16) + 6];
              RDP7  <= MEM[(RADDR * 16) + 7];
              RDP8  <= MEM9[RADDR*2 +0];
              RDP9  <= MEM[(RADDR * 16) + 8];
              RDP10 <= MEM[(RADDR * 16) + 9];
              RDP11 <= MEM[(RADDR * 16) + 10];
              RDP12 <= MEM[(RADDR * 16) + 11];
              RDP13 <= MEM[(RADDR * 16) + 12];
              RDP14 <= MEM[(RADDR * 16) + 13];
              RDP15 <= MEM[(RADDR * 16) + 14];
              RDP16 <= MEM[(RADDR * 16) + 15];
              RDP17 <= MEM9[RADDR * 2 + 1];
              rdepth = 256;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            default: begin
            if ( WARNING_MSGS_ON )
              $display("Warning: Illegal Read port width configuration");
            end
          endcase
        end else if (RPIPE_int == 1'b1) begin // Pipelining on
          case (`RWIDTH_CFG_VECTOR)
            3'b000 : begin
              RD0_stg  <= MEM[RADDR];
              rdepth = 4096;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b001 : begin
              RD0_stg  <= MEM[(RADDR * 2) + 0];
              RD1_stg  <= MEM[(RADDR * 2) + 1];
              rdepth = 2048;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b010 : begin
              RD0_stg  <= MEM[(RADDR * 4) + 0];
              RD1_stg  <= MEM[(RADDR * 4) + 1];
              RD2_stg  <= MEM[(RADDR * 4) + 2];
              RD3_stg  <= MEM[(RADDR * 4) + 3];
              rdepth = 1024;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b011 : begin
              RD0_stg  <= MEM[(RADDR * 8) + 0];
              RD1_stg  <= MEM[(RADDR * 8) + 1];
              RD2_stg  <= MEM[(RADDR * 8) + 2];
              RD3_stg  <= MEM[(RADDR * 8) + 3];
              RD4_stg  <= MEM[(RADDR * 8) + 4];
              RD5_stg  <= MEM[(RADDR * 8) + 5];
              RD6_stg  <= MEM[(RADDR * 8) + 6];
              RD7_stg  <= MEM[(RADDR * 8) + 7];
              RD8_stg  <= MEM9[RADDR];
              rdepth = 512;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b100 : begin
              RD0_stg  <= MEM[(RADDR * 16) + 0];
              RD1_stg  <= MEM[(RADDR * 16) + 1];
              RD2_stg  <= MEM[(RADDR * 16) + 2];
              RD3_stg  <= MEM[(RADDR * 16) + 3];
              RD4_stg  <= MEM[(RADDR * 16) + 4];
              RD5_stg  <= MEM[(RADDR * 16) + 5];
              RD6_stg  <= MEM[(RADDR * 16) + 6];
              RD7_stg  <= MEM[(RADDR * 16) + 7];
              RD8_stg  <= MEM9[RADDR*2 +0];
              RD9_stg  <= MEM[(RADDR * 16) + 8];
              RD10_stg <= MEM[(RADDR * 16) + 9];
              RD11_stg <= MEM[(RADDR * 16) + 10];
              RD12_stg <= MEM[(RADDR * 16) + 11];
              RD13_stg <= MEM[(RADDR * 16) + 12];
              RD14_stg <= MEM[(RADDR * 16) + 13];
              RD15_stg <= MEM[(RADDR * 16) + 14];
              RD16_stg <= MEM[(RADDR * 16) + 15];
              RD17_stg <= MEM9[RADDR * 2 + 1];
              rdepth = 256;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            default: begin
            if ( WARNING_MSGS_ON )
              $display("Warning: Illegal Write port width configuration");
            end
          endcase
        end // RPIPE == 1
      end // if (EMPTY and ESTOP)
    end // if REN = 1 and RBLK = 0
    else if (RBLK_int == 1'bx) begin
            if ( WARNING_MSGS_ON )
      $display("Warning: RBLK signal unknown.");
    end else if (REN_int == 1'bx) begin
            if ( WARNING_MSGS_ON )
      $display("Warning: REN signal unknown.");
    end
    fifo_flags(`AFULL_CFG_VECTOR, `AEMPTY_CFG_VECTOR, `RWIDTH_CFG_VECTOR,
               `WWIDTH_CFG_VECTOR);
  end // if RESET deasserted
end // Read section
  

function integer get_Almost_Empty_value;
    input [11:0] addr_signal;
    integer value;
  begin
    value =  addr_signal[11] * 2048 + addr_signal[10] * 1024 
           + addr_signal[9] *  512  + addr_signal[8]  * 256
           + addr_signal[7] *  128  + addr_signal[6]  * 64 
           + addr_signal[5] *  32   + addr_signal[4]  * 16
           + addr_signal[3] *  8    + addr_signal[2]  * 4 
           + addr_signal[1] *  2    + addr_signal[0] * 1;

    get_Almost_Empty_value = value;
  end
endfunction

 
function integer get_Almost_FULL_value;
    input [11:0] addr_signal;
    integer value;
  begin
    value =  addr_signal[11] * 2048 + addr_signal[10] * 1024 
           + addr_signal[9] *  512  + addr_signal[8]  * 256
           + addr_signal[7] *  128  + addr_signal[6]  * 64 
           + addr_signal[5] *  32   + addr_signal[4]  * 16
           + addr_signal[3] *  8    + addr_signal[2]  * 4 
           + addr_signal[1] *  2    + addr_signal[0] * 1;
 
    get_Almost_FULL_value = value;
  end
endfunction


task fifo_flags;

  input [11:0] afval_cfg_bus;
  input [11:0] aeval_cfg_bus;
  input [2:0]  rwidth_cfg_bus; 
  input [2:0]  wwidth_cfg_bus;
 
  integer rbit_add;
  integer rbit_p2;
  integer wbit_add;
  integer wbit_p2;
  integer AFVAL, AEVAL;
  
  begin

    rbit_add = bit_raddress(RADDR, rwidth_cfg_bus);
    rbit_p2  = bit_raddress(RADDR_P2, rwidth_cfg_bus);
    wbit_add = bit_waddress(WADDR, wwidth_cfg_bus);
    wbit_p2  = bit_waddress(WADDR_P2, wwidth_cfg_bus);
    AEVAL    = get_Almost_Empty_value(aeval_cfg_bus);
    AFVAL    = get_Almost_FULL_value(afval_cfg_bus);

    // Pipelined addresses used for FULL and EMPTY calculations

    if ((WADDR_wrap == RADDR_wrap_P2) && (wbit_add == rbit_p2))
      FULLP = 1'b1;
    else
      FULLP = 1'b0;

    if ((RADDR_wrap == WADDR_wrap_P2) && (wbit_p2 == rbit_add))
      EMPTYP = 1'b1;
    else
      EMPTYP = 1'b0;
      
    // Non-pipelined addresses used for AFULL and AEMPTY calculations

    if (FULLP == 1'b1)
      AEMPTYP = 1'b0;
    else if (wbit_add >= rbit_add) begin
      if ((wbit_add - rbit_add) > AEVAL) 
        AEMPTYP = 1'b0;
      else
        AEMPTYP = 1'b1;
    end else begin
      if ((MAX_DEPTH + wbit_add - rbit_add) > AEVAL)  
        AEMPTYP = 1'b0;
      else
        AEMPTYP = 1'b1;
    end

    if (EMPTYP == 1'b1) 
      AFULLP = 1'b0;
    else if (FULLP == 1'b1) 
      AFULLP = 1'b1;
    else if (wbit_add >= rbit_add) begin
      if ((wbit_add - rbit_add) < AFVAL) 
        AFULLP = 1'b0;
      else
        AFULLP = 1'b1;
    end else begin
      if ((MAX_DEPTH + wbit_add - rbit_add) < AFVAL) 
        AFULLP = 1'b0;
      else
        AFULLP = 1'b1;
    end

  end

endtask

/*
task increment_waddress_counter; // not used - why???
  inout WADDR;
  inout waddr_wrap;
  input [2:0] wwidth_cfg_bus;
  input fflag;
  input fstop;

  integer WADDR;
  integer wdepth;

  begin
    wdepth = get_max_address(wwidth_cfg_bus);
    if (fflag == 1'b0) begin
      if (WADDR < wdepth -1 ) begin
        WADDR <= WADDR + 1;
      end else begin
        WADDR <= (WADDR + 1) % wdepth;
        waddr_wrap =1- waddr_wrap;
      end
    end else if ((fflag == 1'b1) && (fstop == 1'b0)) begin
      if (WADDR < wdepth-1 ) begin
        WADDR <= WADDR + 1;
      end else begin
        WADDR <= (WADDR + 1) % wdepth;
        waddr_wrap =1 - waddr_wrap;
      end
    end
  end
endtask


task increment_raddress_counter; // not used - why???
  input [2:0] width_cfg_bus;
  input flag;
  input stop;

  integer depth;

  begin
    depth = get_max_address(width_cfg_bus);
    if (flag == 1'b0) begin
      if (RADDR < depth -1 ) begin
        RADDR <= RADDR + 1;
      end else begin
        RADDR <= (RADDR + 1) % depth;
        RADDR_wrap =1-RADDR_wrap;
      end
    end else if ((flag == 1'b1) && (stop == 1'b0)) begin
      if (RADDR < depth-1 ) begin
        RADDR <= RADDR + 1;
      end else begin
        RADDR <= (RADDR + 1) % depth;
        RADDR_wrap =1 - RADDR_wrap;
      end
    end
  end
endtask
*/

function integer bit_waddress;
  input WADDR;
  input [2:0] width_cfg_bus;
  integer BIT_WADDR;
  integer WADDR;
  
  begin
  
    case(width_cfg_bus)
      3'b000 : begin
           BIT_WADDR = 1 * WADDR;
           end
      3'b001  : begin
           BIT_WADDR = 2 * WADDR;
           end
      3'b010 : begin
           BIT_WADDR = 4 * WADDR;
           end
      3'b011 : begin
           BIT_WADDR = 8 * WADDR;
           end
      3'b100 : begin
           BIT_WADDR = 16 * WADDR;
           end
      default: begin
            if ( WARNING_MSGS_ON )
           $display("Warning: Illegal port width configuration");
           BIT_WADDR = 0;
           end
    endcase
    bit_waddress = BIT_WADDR;
  end
endfunction


function integer bit_raddress;
  input RADDR;
  input [2:0] width_cfg_bus;
  integer BIT_RADDR;
  integer RADDR;

  begin
 
    case(width_cfg_bus)
      3'b000 : begin
           BIT_RADDR = 1 * RADDR;
           end
      3'b001  : begin
           BIT_RADDR = 2 * RADDR;
           end
      3'b010 : begin
           BIT_RADDR = 4 * RADDR;
           end
      3'b011 : begin
           BIT_RADDR = 8 * RADDR;
           end
      3'b100 : begin
           BIT_RADDR = 16 * RADDR;
           end
      default: begin
            if ( WARNING_MSGS_ON )
            $display("Warning: Illegal port width configuration");
            BIT_RADDR = 0;
           end
    endcase
    bit_raddress = BIT_RADDR;
  end
endfunction


function integer get_max_address;
  input [2:0] width_cfg_bus;
  integer max_address;

  begin
    case(width_cfg_bus)
       3'b000 : begin
                  max_address = 4096;
                end
       3'b001 : begin
                  max_address = 2048;
                end
       3'b010 : begin
                  max_address = 1024;
                end
       3'b011 : begin
                  max_address = 512;
                end
       3'b100 : begin
                  max_address = 256;
                end
       default: begin
            if ( WARNING_MSGS_ON )
                 $display("Warning: Illegal port width configuration");
                 max_address = 0;
                end
    endcase
    get_max_address = max_address;
  end
endfunction

 
specify

      specparam   LibName     = "fusion";
      
      (posedge RCLK => (RD0+:RD0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD1+:RD1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD2+:RD2) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD3+:RD3) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD4+:RD4) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD5+:RD5) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD6+:RD6) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD7+:RD7) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD8+:RD8) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD9+:RD9) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD10+:RD10) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD11+:RD11) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD12+:RD12) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD13+:RD13) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD14+:RD14) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD15+:RD15) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD16+:RD16) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD17+:RD17) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (posedge RCLK => (EMPTY +: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (AEMPTY+: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (AFULL +: 1'b0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (posedge WCLK => (AEMPTY+: 1'b0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge WCLK => (FULL  +: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge WCLK => (AFULL +: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge RESET => (RD0+:RD0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD1+:RD1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD2+:RD2) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD3+:RD3) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD4+:RD4) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD5+:RD5) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD6+:RD6) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD7+:RD7) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD8+:RD8) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD9+:RD9) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD10+:RD10) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD11+:RD11) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD12+:RD12) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD13+:RD13) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD14+:RD14) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD15+:RD15) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD16+:RD16) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD17+:RD17) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge RESET => (EMPTY +: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (AEMPTY+: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (FULL  +: 1'b0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (AFULL +: 1'b0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      $setup(posedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD17, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD17, 0.0, NOTIFY_REG);
      $setup(posedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD16, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD16, 0.0, NOTIFY_REG);
      $setup(posedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD15, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD15, 0.0, NOTIFY_REG);
      $setup(posedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD14, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD14, 0.0, NOTIFY_REG);
      $setup(posedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD13, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD13, 0.0, NOTIFY_REG);
      $setup(posedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD12, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD12, 0.0, NOTIFY_REG);
      $setup(posedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD11, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD11, 0.0, NOTIFY_REG);
      $setup(posedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD10, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD10, 0.0, NOTIFY_REG);
      $setup(posedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD9, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD9, 0.0, NOTIFY_REG);

      $setup(posedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD8, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD8, 0.0, NOTIFY_REG);
      $setup(posedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD7, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD7, 0.0, NOTIFY_REG);
      $setup(posedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD6, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD6, 0.0, NOTIFY_REG);
      $setup(posedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD5, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD5, 0.0, NOTIFY_REG);
      $setup(posedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD4, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD4, 0.0, NOTIFY_REG);
      $setup(posedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD3, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD3, 0.0, NOTIFY_REG);
      $setup(posedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD2, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD2, 0.0, NOTIFY_REG);
      $setup(posedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD1, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD1, 0.0, NOTIFY_REG);
      $setup(posedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD0, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD0, 0.0, NOTIFY_REG);

      $setup(posedge WEN, posedge WCLK &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WEN, posedge WCLK &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& RESET, posedge WEN, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& RESET, negedge WEN, 0.0, NOTIFY_REG);
      $setup(posedge WBLK, posedge WCLK &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WBLK, posedge WCLK &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& RESET, posedge WBLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& RESET, negedge WBLK, 0.0, NOTIFY_REG);

      $setup(posedge FSTOP, posedge WCLK, 0.0, NOTIFY_REG);
      $setup(negedge FSTOP, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, posedge FSTOP, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, negedge FSTOP, 0.0, NOTIFY_REG);

      $setup(posedge WW2, posedge WCLK, 0.0, NOTIFY_REG);
      $setup(negedge WW2, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, posedge WW2, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, negedge WW2, 0.0, NOTIFY_REG);
      $setup(posedge WW1, posedge WCLK, 0.0, NOTIFY_REG);
      $setup(negedge WW1, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, posedge WW1, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, negedge WW1, 0.0, NOTIFY_REG);
      $setup(posedge WW0, posedge WCLK, 0.0, NOTIFY_REG);
      $setup(negedge WW0, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, posedge WW0, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, negedge WW0, 0.0, NOTIFY_REG);

      $setup(posedge REN, posedge RCLK &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge REN, posedge RCLK &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RESET, posedge REN, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RESET, negedge REN, 0.0, NOTIFY_REG);
      $setup(posedge RBLK, posedge RCLK &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge RBLK, posedge RCLK &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RESET, posedge RBLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RESET, negedge RBLK, 0.0, NOTIFY_REG);

      $setup(posedge ESTOP, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge ESTOP, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge ESTOP, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge ESTOP, 0.0, NOTIFY_REG);

      $setup(posedge RW2, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge RW2, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge RW2, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge RW2, 0.0, NOTIFY_REG);
      $setup(posedge RW1, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge RW1, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge RW1, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge RW1, 0.0, NOTIFY_REG);
      $setup(posedge RW0, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge RW0, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge RW0, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge RW0, 0.0, NOTIFY_REG);

      $width(posedge WCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge WCLK, 0.0, 0, NOTIFY_REG);
      $width(posedge RCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge RCLK, 0.0, 0, NOTIFY_REG);

      $recovery(posedge RESET, posedge WCLK, 0.0, NOTIFY_REG);
      $recovery(posedge RESET, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, posedge RESET, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge RESET, 0.0, NOTIFY_REG);

      $width(negedge RESET, 0.0, 0, NOTIFY_REG);

endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE FIFO4K18 ----

//---- MODULE UFROM ----
/*---------------------------------------------------------------
 CELL NAME : UFROM
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module UFROM( ADDR6, ADDR5, ADDR4, ADDR3, ADDR2, ADDR1, ADDR0, CLK,
              DO7, DO6, DO5, DO4, DO3, DO2, DO1, DO0 );

`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif
input     ADDR6, ADDR5, ADDR4, ADDR3, ADDR2, ADDR1, ADDR0, CLK;
output    DO7, DO6, DO5, DO4, DO3, DO2, DO1, DO0;

reg [7:0] memory_array [0:127];

wire      ADDR6_int, ADDR5_int, ADDR4_int, ADDR3_int, ADDR2_int, ADDR1_int, ADDR0_int;
reg       DO7_int, DO6_int, DO5_int, DO4_int, DO3_int, DO2_int, DO1_int, DO0_int;

reg [6:0] ADDR;
reg       addr_is_x;
reg       NOTIFY_REG;

`define   ADDR_BUS    {ADDR6_int, ADDR5_int, ADDR4_int, ADDR3_int, ADDR2_int, ADDR1_int, ADDR0_int}
`define   ROM_DO_BUS  {DO7_int, DO6_int, DO5_int, DO4_int, DO3_int, DO2_int, DO1_int, DO0_int}

buf BUF_U0 (ADDR0_int, ADDR0);
buf BUF_U1 (ADDR1_int, ADDR1);
buf BUF_U2 (ADDR2_int, ADDR2);
buf BUF_U3 (ADDR3_int, ADDR3);
buf BUF_U4 (ADDR4_int, ADDR4);
buf BUF_U5 (ADDR5_int, ADDR5);
buf BUF_U6 (ADDR6_int, ADDR6);
buf BUF_U7 (CLK_int, CLK);

buf OUTBUF_U34 (DO0, DO0_int);
buf OUTBUF_U35 (DO1, DO1_int);
buf OUTBUF_U36 (DO2, DO2_int);
buf OUTBUF_U37 (DO3, DO3_int);
buf OUTBUF_U38 (DO4, DO4_int);
buf OUTBUF_U39 (DO5, DO5_int);
buf OUTBUF_U40 (DO6, DO6_int);
buf OUTBUF_U41 (DO7, DO7_int);

parameter MEMORYFILE = "";
parameter DATA_X     = 1;

  initial
    begin
      if ( MEMORYFILE != "" )
        $readmemb ( MEMORYFILE, memory_array );
      else
        begin
            if ( WARNING_MSGS_ON )
          $display ( "Error: Module %m, memory initialization file parameter MEMORYFILE not defined" );
          $finish;
        end
    end

  // latch input address on rising edge of CLK_int

  always @( posedge CLK_int )
    begin
      ADDR      = `ADDR_BUS;   
      addr_is_x = address_is_x ( ADDR );
      // users can turn-off data being driven to "X" on posedge CLK_ipd, by setting DATA_X to 0
      if ( DATA_X == 1 )
        `ROM_DO_BUS = 8'bx;
    end

  // updated DO only on the falling edge of CLK

  always @ ( negedge CLK_int )
    begin
      read_memory ( `ROM_DO_BUS, ADDR );
    end

  // task to read the contents of an addressed memory location.

  task  read_memory;

    output   [7:0] data_out;
    input    [6:0] address;
    reg      [7:0] temp_reg;
    reg      [7:0] data_out;

    begin
      if ( addr_is_x == 1'b0)
        begin
          temp_reg = memory_array[address];
          data_out = temp_reg;
        end
      else
        data_out = 8'bx;
    end

  endtask

  // function to check if any of the address bits is unknown

  function address_is_x;

    input    [6:0] address;
    integer        i;

    begin
      address_is_x = 1'b0;
      begin : CHECK_ADDRESS
        for ( i = 0; i <= 6; i = i+1 )
          if ( address[i] === 1'bx )
            begin
              // generate warning message only if input address is previously at known state
              if ( addr_is_x !== 1'b1 )
            if ( WARNING_MSGS_ON )
                $display("Warning : Address (%b) unknown at time %10g", address, $realtime);
              address_is_x = 1'b1;
              disable CHECK_ADDRESS;
            end
      end // CHECK_ADDRESS
    end

  endfunction // address_is_x

//--------------------------------------------------------------
//              Timing Checking Section
//-------------------------------------------------------------

  specify

    //checking setup and hold timing for inputs

    $setup ( posedge ADDR6, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR6, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR6, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR6, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR5, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR5, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR5, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR5, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR4, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR4, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR4, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR4, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR3, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR3, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR3, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR3, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR2, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR2, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR2, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR2, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR1, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR1, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR1, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR1, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR0, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR0, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR0, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR0, 0.0, NOTIFY_REG );

    //checking the pulse width on CLK pin

    $width ( posedge CLK, 0, 0, NOTIFY_REG );
    $width ( negedge CLK, 0, 0, NOTIFY_REG );

    //IOPATH delay from CLK to DO

    ( CLK => DO7 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );   
    ( CLK => DO6 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO5 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO4 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO3 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO2 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO1 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO0 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );

    specparam PATHPULSE$CLK$DO7 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO6 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO5 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO4 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO3 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO2 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO1 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO0 = ( 0.1 , 0.1 );

  endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE UFROM ----

//---- MODULE UFROMH ----
/*---------------------------------------------------------------
 CELL NAME : UFROMH
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module UFROMH( ADDR6, ADDR5, ADDR4, ADDR3, ADDR2, ADDR1, ADDR0, CLK,
              DO7, DO6, DO5, DO4, DO3, DO2, DO1, DO0 );
`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif

input     ADDR6, ADDR5, ADDR4, ADDR3, ADDR2, ADDR1, ADDR0, CLK;
output    DO7, DO6, DO5, DO4, DO3, DO2, DO1, DO0;

reg [7:0] memory_array [0:127];

wire      ADDR6_int, ADDR5_int, ADDR4_int, ADDR3_int, ADDR2_int, ADDR1_int, ADDR0_int;
reg       DO7_int, DO6_int, DO5_int, DO4_int, DO3_int, DO2_int, DO1_int, DO0_int;

reg [6:0] ADDR;
reg       addr_is_x;
reg       NOTIFY_REG;

`define   ADDR_BUS    {ADDR6_int, ADDR5_int, ADDR4_int, ADDR3_int, ADDR2_int, ADDR1_int, ADDR0_int}
`define   ROM_DO_BUS  {DO7_int, DO6_int, DO5_int, DO4_int, DO3_int, DO2_int, DO1_int, DO0_int}

buf BUF_U0 (ADDR0_int, ADDR0);
buf BUF_U1 (ADDR1_int, ADDR1);
buf BUF_U2 (ADDR2_int, ADDR2);
buf BUF_U3 (ADDR3_int, ADDR3);
buf BUF_U4 (ADDR4_int, ADDR4);
buf BUF_U5 (ADDR5_int, ADDR5);
buf BUF_U6 (ADDR6_int, ADDR6);
buf BUF_U7 (CLK_int, CLK);

buf OUTBUF_U34 (DO0, DO0_int);
buf OUTBUF_U35 (DO1, DO1_int);
buf OUTBUF_U36 (DO2, DO2_int);
buf OUTBUF_U37 (DO3, DO3_int);
buf OUTBUF_U38 (DO4, DO4_int);
buf OUTBUF_U39 (DO5, DO5_int);
buf OUTBUF_U40 (DO6, DO6_int);
buf OUTBUF_U41 (DO7, DO7_int);

parameter MEMORYFILE = "";
parameter DATA_X     = 1;

  initial
    begin
      if ( MEMORYFILE != "" )
        $readmemb ( MEMORYFILE, memory_array );
      else
        begin
            if ( WARNING_MSGS_ON )
          $display ( "Error: Module %m, memory initialization file parameter MEMORYFILE not defined" );
          $finish;
        end
    end

  // latch input address on rising edge of CLK_int

  always @( posedge CLK_int )
    begin
      ADDR      = `ADDR_BUS;   
      addr_is_x = address_is_x ( ADDR );
      // users can turn-off data being driven to "X" on posedge CLK_ipd, by setting DATA_X to 0
      if ( DATA_X == 1 )
        `ROM_DO_BUS = 8'bx;
    end

  // updated DO only on the falling edge of CLK

  always @ ( negedge CLK_int )
    begin
      read_memory ( `ROM_DO_BUS, ADDR );
    end

  // task to read the contents of an addressed memory location.

  task  read_memory;

    output   [7:0] data_out;
    input    [6:0] address;
    reg      [7:0] temp_reg;
    reg      [7:0] data_out;

    begin
      if ( addr_is_x == 1'b0)
        begin
          temp_reg = memory_array[address];
          data_out = temp_reg;
        end
      else
        data_out = 8'bx;
    end

  endtask

  // function to check if any of the address bits is unknown

  function address_is_x;

    input    [6:0] address;
    integer        i;

    begin
      address_is_x = 1'b0;
      begin : CHECK_ADDRESS
        for ( i = 0; i <= 6; i = i+1 )
          if ( address[i] === 1'bx )
            begin
              // generate warning message only if input address is previously at known state
              if ( addr_is_x !== 1'b1 )
            if ( WARNING_MSGS_ON )
                $display("Warning : Address (%b) unknown at time %10g", address, $realtime);
              address_is_x = 1'b1;
              disable CHECK_ADDRESS;
            end
      end // CHECK_ADDRESS
    end

  endfunction // address_is_x

//--------------------------------------------------------------
//              Timing Checking Section
//-------------------------------------------------------------

  specify

    //checking setup and hold timing for inputs

    $setup ( posedge ADDR6, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR6, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR6, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR6, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR5, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR5, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR5, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR5, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR4, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR4, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR4, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR4, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR3, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR3, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR3, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR3, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR2, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR2, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR2, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR2, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR1, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR1, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR1, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR1, 0.0, NOTIFY_REG );

    $setup ( posedge ADDR0, posedge CLK, 0.0, NOTIFY_REG );
    $setup ( negedge ADDR0, posedge CLK, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, posedge ADDR0, 0.0, NOTIFY_REG );
    $hold  ( posedge CLK, negedge ADDR0, 0.0, NOTIFY_REG );

    //checking the pulse width on CLK pin

    $width ( posedge CLK, 0, 0, NOTIFY_REG );
    $width ( negedge CLK, 0, 0, NOTIFY_REG );

    //IOPATH delay from CLK to DO

    ( CLK => DO7 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );   
    ( CLK => DO6 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO5 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO4 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO3 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO2 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO1 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( CLK => DO0 ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );

    specparam PATHPULSE$CLK$DO7 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO6 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO5 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO4 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO3 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO2 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO1 = ( 0.1 , 0.1 );
    specparam PATHPULSE$CLK$DO0 = ( 0.1 , 0.1 );

  endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE UFROMH ----

//---- MODULE UJTAG ----
//------------------------
// CELL NAME: UJTAG
//------------------------

/*
 * Simple TAP for simulation of designs using the ProASIC user JTAG interface
 * Note:
 * 1. This TAP is not a model of the actual TAP used in the ProASIC. The
 *    only instruction implemented is BYPASS. An instruction scan operation
 *    will capture the pattern 8'bxxxxxx01
 * 2. This model should not be used for the A500K family, as it uses
 *    a different set of interface signals.
 *
 */

`timescale 1ns/10ps

`define Bypass            8'hff

`define Test_Logic_Reset  4'hf
`define Run_Test_Idle     4'hc
`define Select_DR         4'h7
`define Capture_DR        4'h6
`define Shift_DR          4'h2
`define Exit1_DR          4'h1
`define Pause_DR          4'h3
`define Exit2_DR          4'h0
`define Update_DR         4'h5
`define Select_IR         4'h4
`define Capture_IR        4'he
`define Shift_IR          4'ha
`define Exit1_IR          4'h9
`define Pause_IR          4'hb
`define Exit2_IR          4'h8
`define Update_IR         4'hd

module UJTAG ( UIREG0, UIREG1, UIREG2, UIREG3, UIREG4, UIREG5, UIREG6, UIREG7,
               URSTB, UDRCK, UDRCAP, UDRSH, UDRUPD, UTDI, UTDO,
               TDO, TMS, TDI, TCK, TRSTB );

`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif
output  UIREG0, UIREG1, UIREG2, UIREG3, UIREG4, UIREG5, UIREG6, UIREG7;

output  UTDI, URSTB, UDRCK, UDRCAP, UDRSH, UDRUPD;
input   UTDO;

input   TMS, TDI, TCK, TRSTB;
output  TDO;

reg [3:0] STATE;
reg [7:0] IR, SHREG;
//reg       TDO, UDRUPD, UDRCAP, UDRSH;
reg       TDO_zd, UDRUPD_zd, UDRCAP_zd, UDRSH_zd, URSTB_zd;
reg       NOTIFY_REG;

buf  buf_tdi      ( TDI_int,   TDI   );
buf  buf_tms      ( TMS_int,   TMS   );
buf  buf_tck      ( TCK_int,   TCK   );
buf  buf_trstb    ( TRSTB_int, TRSTB );
buf  buf_utdo     ( UTDO_int,  UTDO  );

pmos pmos_uireg0  ( UIREG0, UIREG0_zd, 0 );
pmos pmos_uireg1  ( UIREG1, UIREG1_zd, 0 );
pmos pmos_uireg2  ( UIREG2, UIREG2_zd, 0 );
pmos pmos_uireg3  ( UIREG3, UIREG3_zd, 0 );
pmos pmos_uireg4  ( UIREG4, UIREG4_zd, 0 );
pmos pmos_uireg5  ( UIREG5, UIREG5_zd, 0 );
pmos pmos_uireg6  ( UIREG6, UIREG6_zd, 0 );
pmos pmos_uireg7  ( UIREG7, UIREG7_zd, 0 );

pmos pmos_tdo     ( TDO,    TDO_zd,    0 );
pmos pmos_urstb   ( URSTB,  URSTB_zd,  0 );
//pmos pmos_udrck   ( UDRCK,  UDRCK_zd,  0 );
pmos pmos_udrcap  ( UDRCAP, UDRCAP_zd, 0 );
pmos pmos_udrsh   ( UDRSH,  UDRSH_zd,  0 );
pmos pmos_udrupd  ( UDRUPD, UDRUPD_zd, 0 );
//pmos pmos_utdi    ( UTDI,   UTDI_zd,   0 );

//assign { UIREG7, UIREG6, UIREG5, UIREG4, UIREG3, UIREG2, UIREG1, UIREG0 } = IR;
assign { UIREG7_zd, UIREG6_zd, UIREG5_zd, UIREG4_zd, UIREG3_zd, UIREG2_zd, UIREG1_zd, UIREG0_zd } = IR;
assign UTDI  = TDI_int;
assign UDRCK = TCK_int;
//assign URSTB = STATE != `Test_Logic_Reset;

always @( negedge TCK_int or negedge TRSTB_int )
begin
        if ( !TRSTB_int ) begin
                UDRUPD_zd <= 0;
                UDRSH_zd  <= 0;
                UDRCAP_zd <= 0;
                URSTB_zd  <= 0;
        end else begin
                UDRUPD_zd <= ( STATE == `Update_DR        );
                UDRSH_zd  <= ( STATE == `Shift_DR         );
                UDRCAP_zd <= ( STATE == `Capture_DR       );
                URSTB_zd  <= ( STATE != `Test_Logic_Reset );
        end
end

always @( posedge TCK_int or negedge TRSTB_int )
begin
        if ( !TRSTB_int ) begin
                STATE <= `Test_Logic_Reset;
        end
        else begin
             case ( STATE )
                `Test_Logic_Reset: STATE <= TMS_int ? `Test_Logic_Reset : `Run_Test_Idle;
                `Run_Test_Idle   : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
                `Select_DR       : STATE <= TMS_int ? `Select_IR : `Capture_DR;
                `Capture_DR,
                `Shift_DR        : STATE <= TMS_int ? `Exit1_DR : `Shift_DR;
                `Exit1_DR        : STATE <= TMS_int ? `Update_DR : `Pause_DR;
                `Pause_DR        : STATE <= TMS_int ? `Exit2_DR : `Pause_DR;
                `Exit2_DR        : STATE <= TMS_int ? `Update_DR : `Shift_DR;
                `Select_IR       : STATE <= TMS_int ? `Test_Logic_Reset :  `Capture_IR;
                `Capture_IR,
                `Shift_IR        : STATE <= TMS_int ? `Exit1_IR : `Shift_IR;
                `Exit1_IR        : STATE <= TMS_int ? `Update_IR : `Pause_IR;
                `Pause_IR        : STATE <= TMS_int ? `Exit2_IR : `Pause_IR;
                `Exit2_IR        : STATE <= TMS_int ? `Update_IR : `Shift_IR;
                `Update_DR,
                `Update_IR       : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
             endcase
        end
end

always @( posedge TCK_int )
begin
        case ( STATE )
                `Capture_IR : SHREG <=  8'bxxxxxx01;
                `Capture_DR : SHREG <=  8'b00000000;
                `Shift_IR,
                `Shift_DR   : SHREG <= { TDI_int, SHREG[7:1] };
        endcase
end

always @( negedge TCK_int or negedge TRSTB_int )
begin
       if ( !TRSTB_int ) begin
         IR  <= `Bypass;
         TDO_zd <= 'bz;
       end else if ( STATE == `Shift_IR )
         TDO_zd <= SHREG[0];
       else if ( STATE == `Shift_DR ) begin
         casez ( IR )
           8'b01??????,
           8'b0?1?????,
           8'b0??1????: TDO_zd <= UTDO;
           default    : TDO_zd <= SHREG[7];
         endcase
       end
       else if ( STATE == `Update_IR ) begin
         TDO_zd <= 'bz;
         IR  <= SHREG;
       end else begin
         TDO_zd <= 'bz;
       end
end

    specify

      specparam   LibName     = "fusion";

      (negedge TCK   => (UIREG0+:UIREG0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG1+:UIREG1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG2+:UIREG2) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG3+:UIREG3) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG4+:UIREG4) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG5+:UIREG5) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG6+:UIREG6) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG7+:UIREG7) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (posedge TCK   => (UDRCK +:1'b1  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UDRCK +:1'b0  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (posedge TDI   => (UTDI +:1'b1   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TDI   => (UTDI +:1'b0   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge TCK   => (URSTB +:URSTB ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UDRSH +:UDRSH ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UDRCAP+:UDRCAP) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UDRUPD+:UDRUPD) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge TCK   => (TDO+:TDO ) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge TRSTB => (UIREG0+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG1+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG2+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG3+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG4+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG5+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG6+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG7+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge TRSTB => (URSTB +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UDRSH +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UDRCAP+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UDRUPD+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge TRSTB => (TDO+:1'b0) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

      $setup(posedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $setup(negedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $hold(posedge TCK &&& TRSTB, posedge TDI, 0.0, NOTIFY_REG);
      $hold(posedge TCK &&& TRSTB, negedge TDI, 0.0, NOTIFY_REG);

      $setup(posedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $setup(negedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $hold(posedge TCK &&& TRSTB, posedge TMS, 0.0, NOTIFY_REG);
      $hold(posedge TCK &&& TRSTB, negedge TMS, 0.0, NOTIFY_REG);

      $setup(posedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $setup(negedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $hold(negedge TCK &&& TRSTB, posedge UTDO, 0.0, NOTIFY_REG);
      $hold(negedge TCK &&& TRSTB, negedge UTDO, 0.0, NOTIFY_REG);

      $recovery(posedge TRSTB, posedge TCK, 0.0, NOTIFY_REG);
      $hold(posedge TCK,posedge TRSTB, 0.0, NOTIFY_REG);

      $width(negedge TRSTB, 0.0, 0, NOTIFY_REG);
      $width(posedge TCK, 0.0, 0, NOTIFY_REG);
      $width(negedge TCK, 0.0, 0, NOTIFY_REG);

    endspecify

endmodule
//---- END MODULE UJTAG ----

//---- MODULE CLKDIVDLY ----
/*--------------------------------------------------------------------
 CELL NAME : CLKDIVDLY
---------------------------------------------------------------------*/
`timescale 1 ps /1 ps

module CLKDIVDLY 
  (
  CLK,
  RESET,    // Active rising-edge triggered RESET.
  ODIVHALF, // Active high.
  ODIV0,
  ODIV1,
  ODIV2,
  ODIV3,
  ODIV4,
  DLYGL0,
  DLYGL1,
  DLYGL2,
  DLYGL3,
  DLYGL4,
  GL
  );

`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif
  output GL;
  input  CLK; 
  input  RESET; 
  input  ODIVHALF;
  input  ODIV0;
  input  ODIV1;
  input  ODIV2;
  input  ODIV3;
  input  ODIV4;
  input  DLYGL0;
  input  DLYGL1;
  input  DLYGL2;
  input  DLYGL3;
  input  DLYGL4;

  parameter INTRINSIC_DELAY     = 2393;
  parameter PROG_INIT_DELAY     = 535;
  parameter PROG_STEP_INCREMENT = 200;

  time      GLDELAY;
  time      CLK_re;
  time      CLK_prev_re;
  integer   CLK_period;

  reg       CLK_int; // Internal clock - runs at 2X CLK frequency
  reg       Q;

  integer   num_edges;
  integer   res_post_reset1;
  integer   fes_post_reset1;
  integer   res_post_reset0;
  integer   fes_post_reset0;
  integer   i;
  integer   DivVal;
  integer   DIV;

  wire       RESET_ipd;
  wire       ODIVHALF_ipd;
  wire [4:0] ODIV_ipd;
  wire [4:0] DLYGL_ipd;
  wire       CLK_ipd;

  reg        GL_int;

  reg        CLK_ipd_last_value;
  reg        RESET_ipd_last_value;
  reg        CLK_int_last_value;
  reg        force_0;

  reg        dlygl_xor;
  integer    dlygl_step;

  buf U0 ( CLK_ipd, CLK );
  buf BUF_DLY_0( GL, GL_int );

  assign RESET_ipd     = RESET;
  assign ODIVHALF_ipd  = ODIVHALF;
  assign ODIV_ipd[0]   = ODIV0;
  assign ODIV_ipd[1]   = ODIV1;
  assign ODIV_ipd[2]   = ODIV2;
  assign ODIV_ipd[3]   = ODIV3;
  assign ODIV_ipd[4]   = ODIV4;
  assign DLYGL_ipd[0]  = DLYGL0;
  assign DLYGL_ipd[1]  = DLYGL1;
  assign DLYGL_ipd[2]  = DLYGL2;
  assign DLYGL_ipd[3]  = DLYGL3;
  assign DLYGL_ipd[4]  = DLYGL4;
  
  //
  // get GL delay
  //
  always @ ( DLYGL_ipd )
  begin
    dlygl_xor = ^ DLYGL_ipd;
    if ( dlygl_xor === 1'bX )
    begin
      GLDELAY <= 0;
    end else
    begin
      dlygl_step = DLYGL_ipd;
      GLDELAY <= ( dlygl_step == 0 ) ?
                 INTRINSIC_DELAY :
                 ( INTRINSIC_DELAY + ( dlygl_step * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY );
    end
  end


  //
  // Get DIV value Block
  //
  always @ ( ODIV_ipd or ODIVHALF_ipd )
  begin

    for ( i = 0; i <= 4; i = i + 1 ) begin
      if ( ODIV_ipd [ i ] == 1 )
        DivVal = DivVal + ( 1 << i );
    end
    if ( ODIVHALF_ipd == 1'b1 ) begin
      if (( DivVal == 0 ) || ( DivVal % 2 )) begin
            if ( WARNING_MSGS_ON )
        $display ( "Warning: Illegal ODIVHALF ODIV configuration %b %b.",
                    ODIVHALF_ipd, ODIV_ipd );
            if ( WARNING_MSGS_ON )
        $display ( "Only even, non-zero ODIV values allowed with ODIVHALF." );
        $display ( "ODIVHALF ignored." );
      end
    end else if ( ODIVHALF_ipd === 1'bx ) begin
            if ( WARNING_MSGS_ON )
      $display ( "Warning: Illegal ODIVHALF value %b.  Assumed 0.", ODIVHALF_ipd );
    end
    DIV <= DivVal + 1; // DIV unchanged by ODIVHALF.  Accounted for elsewhere.
    DivVal <= 0;

  end

  //
  // Generate internal CLK signal
  //
  always @ ( CLK_ipd )
  begin
    if ( ODIVHALF_ipd == 1'b1 ) begin
      // Half divide active - multiply CLK by 2 before dividing by DIV
      if ( CLK_ipd === 1'bx ) begin
        CLK_int <= # 0 1'bx;
      end else if ( CLK_ipd == 1'b1 ) begin
        CLK_prev_re = CLK_re;
        CLK_re = $time;
        CLK_period = ( CLK_re - CLK_prev_re );
        if ( CLK_period > 0 ) begin
          // First CLK_ipd cycle dropped
          CLK_int <= # 0 1'b1;
          CLK_int <= # ( CLK_period / 4.0 ) 1'b0;
          CLK_int <= # ( CLK_period / 2.0 ) 1'b1;
          CLK_int <= # ( CLK_period * 3.0 / 4.0 ) 1'b0;
        end
      end
    end else begin
      // Half divide not active - divide CLK by DIV
      CLK_int <= # 0 CLK_ipd;
    end
  end

  //
  // Generate output
  //
  always @ ( CLK_ipd or RESET_ipd or CLK_int )
  begin

    if ( CLK_ipd !== CLK_ipd_last_value ) begin
      if ( ( CLK_ipd === 1'b1 ) && ( CLK_ipd_last_value === 1'b0 ) ) begin
        res_post_reset1 = res_post_reset1 + 1;
        res_post_reset0 = res_post_reset0 + 1;
        if ( res_post_reset1 == 3 ) begin
          force_0 = 1'b0;
          num_edges = -1;
        end
      end else if ( ( CLK_ipd === 1'b0 ) && ( CLK_ipd_last_value === 1'b1 ) ) begin
        fes_post_reset1 = fes_post_reset1 + 1;
        fes_post_reset0 = fes_post_reset0 + 1;
        if ( fes_post_reset1 == 1 ) begin
          force_0 = 1'b1;
        end
      end
      CLK_ipd_last_value = CLK_ipd;
    end

    if ( RESET_ipd !== RESET_ipd_last_value ) begin
      if ( RESET_ipd === 1'b1 ) begin
        if ( ( RESET_ipd_last_value === 1'b0 ) &&
             ( ( res_post_reset0 < 1 ) || ( fes_post_reset0 < 1 ) ) ) begin
            if ( WARNING_MSGS_ON )
          $display( "RESET must be held low for at least one CLK period for the reset operation to work correctly: reset operation may not be successful, edge alignment unpredictable" );
        end
        res_post_reset1 = 0;
        fes_post_reset1 = 0;
      end else if ( RESET_ipd === 1'b0 ) begin
        if ( ( RESET_ipd_last_value === 1'b1 ) &&
             ( ( res_post_reset1 < 3 ) || ( fes_post_reset1 < 3 ) ) ) begin
            if ( WARNING_MSGS_ON )
          $display( "RESET must be held high for at least three CLK periods for the reset operation to work correctly: reset operation may not be succesful, edge alignment unpredictable" );
        end
        res_post_reset0 = 0;
        fes_post_reset0 = 0;
      end else begin
            if ( WARNING_MSGS_ON )
        $display( "RESET is unknown. Edge alignment unpredictable." );
      end
      RESET_ipd_last_value = RESET_ipd;
    end

    if ( CLK_int !== CLK_int_last_value ) begin
      num_edges = num_edges + 1;
      if ( force_0 === 1'b1 ) begin
        Q <= 1'b0;
      end else if ( CLK_int === 1'bx ) begin
        Q <= 1'bx;
      end else if ( ( num_edges % DIV ) == 0 ) begin
        if ( Q === 1'bx ) begin
          Q <= CLK_int;
        end else begin
          Q <= !Q;
        end
      end
      CLK_int_last_value = CLK_int;
    end

  end

  always @( GLDELAY or Q )
  begin
     GL_int <= #( GLDELAY ) Q;
  end

  initial
  begin
    DIV                  = 1;
    DivVal               = 0;
    GLDELAY              = 0;
    Q                    = 1'bx;
    num_edges            = -1;
    res_post_reset0      = 0;
    fes_post_reset0      = 0;
    res_post_reset1      = 0;
    fes_post_reset1      = 0;
    CLK_prev_re          = 0;
    CLK_re               = 0;
    CLK_period           = 0;
    CLK_ipd_last_value   = 1'bx;
    RESET_ipd_last_value = 1'bx;
    CLK_int_last_value   = 1'bx;
    force_0              = 1'b1;
  end

endmodule
//---- END MODULE CLKDIVDLY ----

//---- MODULE CLKDIVDLY1 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKDIVDLY1
---------------------------------------------------------------------*/
`timescale 1 ps /1 ps

module CLKDIVDLY1 
  (
  CLK,
  RESET,    // Active rising-edge triggered RESET.
  ODIVHALF, // Active high.
  ODIV0,
  ODIV1,
  ODIV2,
  ODIV3,
  ODIV4,
  DLYY0,
  DLYY1,
  DLYY2,
  DLYY3,
  DLYY4,
  DLYGL0,
  DLYGL1,
  DLYGL2,
  DLYGL3,
  DLYGL4,
  GL,
  Y
  );

`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif
  output GL;
  output Y;
  input  CLK; 
  input  RESET; 
  input  ODIVHALF;
  input  ODIV0;
  input  ODIV1;
  input  ODIV2;
  input  ODIV3;
  input  ODIV4;
  input  DLYY0;
  input  DLYY1;
  input  DLYY2;
  input  DLYY3;
  input  DLYY4;
  input  DLYGL0;
  input  DLYGL1;
  input  DLYGL2;
  input  DLYGL3;
  input  DLYGL4;

  parameter GL_INTRINSIC_DELAY  = 2393;
  parameter PROG_INIT_DELAY     = 535;
  parameter PROG_STEP_INCREMENT = 200;
  parameter Y_INTRINSIC_DELAY   = 2578;

  time      GLDELAY;
  time      YDELAY;
  time      CLK_re;
  time      CLK_prev_re;
  integer   CLK_period;

  reg       CLK_int; // Internal clock - runs at 2X CLK frequency
  reg       Q;

  integer   num_edges;
  integer   res_post_reset1;
  integer   fes_post_reset1;
  integer   res_post_reset0;
  integer   fes_post_reset0;
  integer   i;
  integer   DivVal;
  integer   DIV;

  wire       RESET_ipd;
  wire       ODIVHALF_ipd;
  wire [4:0] ODIV_ipd;
  wire [4:0] DLYY_ipd;
  wire [4:0] DLYGL_ipd;
  wire       CLK_ipd;

  reg        GL_int;
  reg        Y_int;

  reg        CLK_ipd_last_value;
  reg        RESET_ipd_last_value;
  reg        CLK_int_last_value;
  reg        force_0;

  reg        dlygl_xor;
  integer    dlygl_step;
  reg        dlyy_xor;
  integer    dlyy_step;

  buf U0 ( CLK_ipd, CLK );
  buf BUF_DLY_0( GL, GL_int );
  buf BUF_DLY_1( Y,  Y_int );

  assign RESET_ipd     = RESET;
  assign ODIVHALF_ipd  = ODIVHALF;
  assign ODIV_ipd[0]   = ODIV0;
  assign ODIV_ipd[1]   = ODIV1;
  assign ODIV_ipd[2]   = ODIV2;
  assign ODIV_ipd[3]   = ODIV3;
  assign ODIV_ipd[4]   = ODIV4;
  assign DLYY_ipd[0]   = DLYY0;
  assign DLYY_ipd[1]   = DLYY1;
  assign DLYY_ipd[2]   = DLYY2;
  assign DLYY_ipd[3]   = DLYY3;
  assign DLYY_ipd[4]   = DLYY4;
  assign DLYGL_ipd[0]  = DLYGL0;
  assign DLYGL_ipd[1]  = DLYGL1;
  assign DLYGL_ipd[2]  = DLYGL2;
  assign DLYGL_ipd[3]  = DLYGL3;
  assign DLYGL_ipd[4]  = DLYGL4;
  
  //
  // get GL delay
  //

  always @ ( DLYGL_ipd )
  begin
    dlygl_xor = ^ DLYGL_ipd;
    if ( dlygl_xor === 1'bX )
    begin
      GLDELAY <= 0;
    end else
    begin
      dlygl_step = DLYGL_ipd;
      GLDELAY <= ( dlygl_step == 0 ) ?
                 GL_INTRINSIC_DELAY :
                 ( GL_INTRINSIC_DELAY + ( dlygl_step * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY );
    end
  end

  //
  // get Y delay
  //

  always @ ( DLYY_ipd )
  begin
    dlyy_xor = ^ DLYY_ipd;
    if ( dlyy_xor === 1'bX )
    begin
      YDELAY <= 0;
    end else
    begin
      dlyy_step = DLYY_ipd;
      YDELAY <= ( Y_INTRINSIC_DELAY + ( dlyy_step * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY );
    end
  end

  //
  // Get DIV value Block
  //
  always @ ( ODIV_ipd or ODIVHALF_ipd )
  begin

    for ( i = 0; i <= 4; i = i + 1 ) begin
      if ( ODIV_ipd [ i ] == 1 )
        DivVal = DivVal + ( 1 << i );
    end
    if ( ODIVHALF_ipd == 1'b1 ) begin
      if (( DivVal == 0 ) || ( DivVal % 2 )) begin
            if ( WARNING_MSGS_ON )
        $display ( "Warning: Illegal ODIVHALF ODIV configuration %b %b.",
                    ODIVHALF_ipd, ODIV_ipd );
            if ( WARNING_MSGS_ON )
        $display ( "Only even, non-zero ODIV values allowed with ODIVHALF." );
            if ( WARNING_MSGS_ON )
        $display ( "ODIVHALF ignored." );
      end
    end else if ( ODIVHALF_ipd === 1'bx ) begin
            if ( WARNING_MSGS_ON )
      $display ( "Warning: Illegal ODIVHALF value %b.  Assumed 0.", ODIVHALF_ipd );
    end
    DIV <= DivVal + 1; // DIV unchanged by ODIVHALF.  Accounted for elsewhere.
    DivVal <= 0;

  end

  //
  // Generate internal CLK signal
  //
  always @ ( CLK_ipd )
  begin
    if ( ODIVHALF_ipd == 1'b1 ) begin
      // Half divide active - multiply CLK by 2 before dividing by DIV
      if ( CLK_ipd === 1'bx ) begin
        CLK_int <= # 0 1'bx;
      end else if ( CLK_ipd == 1'b1 ) begin
        CLK_prev_re = CLK_re;
        CLK_re = $time;
        CLK_period = ( CLK_re - CLK_prev_re );
        if ( CLK_period > 0 ) begin
          // First CLK_ipd cycle dropped
          CLK_int <= # 0 1'b1;
          CLK_int <= # ( CLK_period / 4.0 ) 1'b0;
          CLK_int <= # ( CLK_period / 2.0 ) 1'b1;
          CLK_int <= # ( CLK_period * 3.0 / 4.0 ) 1'b0;
        end
      end
    end else begin
      // Half divide not active - divide CLK by DIV
      CLK_int <= # 0 CLK_ipd;
    end
  end

  //
  // Generate output
  //
  always @ ( CLK_ipd or RESET_ipd or CLK_int )
  begin

    if ( CLK_ipd !== CLK_ipd_last_value ) begin
      if ( ( CLK_ipd === 1'b1 ) && ( CLK_ipd_last_value === 1'b0 ) ) begin
        res_post_reset1 = res_post_reset1 + 1;
        res_post_reset0 = res_post_reset0 + 1;
        if ( res_post_reset1 == 3 ) begin
          force_0 = 1'b0;
          num_edges = -1;
        end
      end else if ( ( CLK_ipd === 1'b0 ) && ( CLK_ipd_last_value === 1'b1 ) ) begin
        fes_post_reset1 = fes_post_reset1 + 1;
        fes_post_reset0 = fes_post_reset0 + 1;
        if ( fes_post_reset1 == 1 ) begin
          force_0 = 1'b1;
        end
      end
      CLK_ipd_last_value = CLK_ipd;
    end

    if ( RESET_ipd !== RESET_ipd_last_value ) begin
      if ( RESET_ipd === 1'b1 ) begin
        if ( ( RESET_ipd_last_value === 1'b0 ) &&
             ( ( res_post_reset0 < 1 ) || ( fes_post_reset0 < 1 ) ) ) begin
            if ( WARNING_MSGS_ON )
          $display( "RESET must be held low for at least one CLK period for the reset operation to work correctly: reset operation may not be successful, edge alignment unpredictable" );
        end
        res_post_reset1 = 0;
        fes_post_reset1 = 0;
      end else if ( RESET_ipd === 1'b0 ) begin
        if ( ( RESET_ipd_last_value === 1'b1 ) &&
             ( ( res_post_reset1 < 3 ) || ( fes_post_reset1 < 3 ) ) ) begin
            if ( WARNING_MSGS_ON )
          $display( "RESET must be held high for at least three CLK periods for the reset operation to work correctly: reset operation may not be succesful, edge alignment unpredictable" );
        end
        res_post_reset0 = 0;
        fes_post_reset0 = 0;
      end else begin
            if ( WARNING_MSGS_ON )
        $display( "RESET is unknown. Edge alignment unpredictable." );
      end
      RESET_ipd_last_value = RESET_ipd;
    end

    if ( CLK_int !== CLK_int_last_value ) begin
      num_edges = num_edges + 1;
      if ( force_0 === 1'b1 ) begin
        Q <= 1'b0;
      end else if ( CLK_int === 1'bx ) begin
        Q <= 1'bx;
      end else if ( ( num_edges % DIV ) == 0 ) begin
        if ( Q === 1'bx ) begin
          Q <= CLK_int;
        end else begin
          Q <= !Q;
        end
      end
      CLK_int_last_value = CLK_int;
    end

  end

  always @( GLDELAY or Q )
  begin
     GL_int <= #( GLDELAY ) Q;
  end

  always @( YDELAY or Q )
  begin
     Y_int <= #( YDELAY ) Q;
  end

  initial
  begin
    DIV                  = 1;
    DivVal               = 0;
    YDELAY               = 0;
    GLDELAY              = 0;
    Q                    = 1'bx;
    num_edges            = -1;
    res_post_reset0      = 0;
    fes_post_reset0      = 0;
    res_post_reset1      = 0;
    fes_post_reset1      = 0;
    CLK_prev_re          = 0;
    CLK_re               = 0;
    CLK_period           = 0;
    CLK_ipd_last_value   = 1'bx;
    RESET_ipd_last_value = 1'bx;
    CLK_int_last_value   = 1'bx;
    force_0              = 1'b1;
  end

endmodule
//---- END MODULE CLKDIVDLY1 ----

//---- MODULE CLKDIV_SDF ----
/*--------------------------------------------------------------------
 CELL NAME : CLKDIV_SDF
 AFL macro used in conjunction with CLKDIVDLY_SDF in place of CLKDIVDLY.
 CLKDIV_SDF handles only division and PORT delays.
 CLKDIVDLY_SDF handles IOPATH delays.
---------------------------------------------------------------------*/
`timescale 1 ps /1 ps

module CLKDIV_SDF
  (
  CLK,
  RESET,    // Active rising-edge triggered RESET.
  ODIVHALF, // Active high.
  ODIV0,
  ODIV1,
  ODIV2,
  ODIV3,
  ODIV4,
  GL
  );

`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif
  output GL;
  input  CLK; 
  input  RESET; 
  input  ODIVHALF;
  input  ODIV0;
  input  ODIV1;
  input  ODIV2;
  input  ODIV3;
  input  ODIV4;

  time      CLK_re;
  time      CLK_prev_re;
  integer   CLK_period;

  reg       CLK_int; // Internal clock - runs at 2X CLK frequency
  reg       Q;

  integer   num_edges;
  integer   res_post_reset1;
  integer   fes_post_reset1;
  integer   res_post_reset0;
  integer   fes_post_reset0;
  integer   i;
  integer   DivVal;
  integer   DIV;

  wire       RESET_ipd;
  wire       ODIVHALF_ipd;
  wire [4:0] ODIV_ipd;
  wire       CLK_ipd;

  reg        CLK_ipd_last_value;
  reg        RESET_ipd_last_value;
  reg        CLK_int_last_value;
  reg        force_0;

  // These bufs handle PORT delays
  buf U0 ( CLK_ipd,      CLK      ); 
  buf U1 ( RESET_ipd,    RESET    );
  buf U2 ( ODIVHALF_ipd, ODIVHALF );

  assign ODIV_ipd[0]   = ODIV0;
  assign ODIV_ipd[1]   = ODIV1;
  assign ODIV_ipd[2]   = ODIV2;
  assign ODIV_ipd[3]   = ODIV3;
  assign ODIV_ipd[4]   = ODIV4;
  
  buf U3 ( GL, Q );

 //
  // Get DIV value Block
  //
  always @ ( ODIV_ipd or ODIVHALF_ipd )
  begin

    for ( i = 0; i <= 4; i = i + 1 ) begin
      if ( ODIV_ipd [ i ] == 1 )
        DivVal = DivVal + ( 1 << i );
    end
    if ( ODIVHALF_ipd == 1'b1 ) begin
      if (( DivVal == 0 ) || ( DivVal % 2 )) begin
            if ( WARNING_MSGS_ON )
        $display ( "Warning: Illegal ODIVHALF ODIV configuration %b %b.",
                    ODIVHALF_ipd, ODIV_ipd );
            if ( WARNING_MSGS_ON )
        $display ( "Only even, non-zero ODIV values allowed with ODIVHALF." );
            if ( WARNING_MSGS_ON )
        $display ( "ODIVHALF ignored." );
      end
    end else if ( ODIVHALF_ipd === 1'bx ) begin
            if ( WARNING_MSGS_ON )
      $display ( "Warning: Illegal ODIVHALF value %b.  Assumed 0.", ODIVHALF_ipd );
    end
    DIV <= DivVal + 1; // DIV unchanged by ODIVHALF.  Accounted for elsewhere.
    DivVal <= 0;

  end

  //
  // Generate internal CLK signal
  //
  always @ ( CLK_ipd )
  begin
    if ( ODIVHALF_ipd == 1'b1 ) begin
      // Half divide active - multiply CLK by 2 before dividing by DIV
      if ( CLK_ipd === 1'bx ) begin
        CLK_int <= # 0 1'bx;
      end else if ( CLK_ipd == 1'b1 ) begin
        CLK_prev_re = CLK_re;
        CLK_re = $time;
        CLK_period = ( CLK_re - CLK_prev_re );
        if ( CLK_period > 0 ) begin
          // First CLK_ipd cycle dropped
          CLK_int <= # 0 1'b1;
          CLK_int <= # ( CLK_period / 4.0 ) 1'b0;
          CLK_int <= # ( CLK_period / 2.0 ) 1'b1;
          CLK_int <= # ( CLK_period * 3.0 / 4.0 ) 1'b0;
        end
      end
    end else begin
      // Half divide not active - divide CLK by DIV
      CLK_int <= # 0 CLK_ipd;
    end
  end

  //
  // Generate output
  //
  always @ ( CLK_ipd or RESET_ipd or CLK_int )
  begin

    if ( CLK_ipd !== CLK_ipd_last_value ) begin
      if ( ( CLK_ipd === 1'b1 ) && ( CLK_ipd_last_value === 1'b0 ) ) begin
        res_post_reset1 = res_post_reset1 + 1;
        res_post_reset0 = res_post_reset0 + 1;
        if ( res_post_reset1 == 3 ) begin
          force_0 = 1'b0;
          num_edges = -1;
        end
      end else if ( ( CLK_ipd === 1'b0 ) && ( CLK_ipd_last_value === 1'b1 ) ) begin
        fes_post_reset1 = fes_post_reset1 + 1;
        fes_post_reset0 = fes_post_reset0 + 1;
        if ( fes_post_reset1 == 1 ) begin
          force_0 = 1'b1;
        end
      end
      CLK_ipd_last_value = CLK_ipd;
    end

    if ( RESET_ipd !== RESET_ipd_last_value ) begin
      if ( RESET_ipd === 1'b1 ) begin
        if ( ( RESET_ipd_last_value === 1'b0 ) &&
             ( ( res_post_reset0 < 1 ) || ( fes_post_reset0 < 1 ) ) ) begin
            if ( WARNING_MSGS_ON )
          $display( "RESET must be held low for at least one CLK period for the reset operation to work correctly: reset operation may not be successful, edge alignment unpredictable" );
        end
        res_post_reset1 = 0;
        fes_post_reset1 = 0;
      end else if ( RESET_ipd === 1'b0 ) begin
        if ( ( RESET_ipd_last_value === 1'b1 ) &&
             ( ( res_post_reset1 < 3 ) || ( fes_post_reset1 < 3 ) ) ) begin
            if ( WARNING_MSGS_ON )
          $display( "RESET must be held high for at least three CLK periods for the reset operation to work correctly: reset operation may not be succesful, edge alignment unpredictable" );
        end
        res_post_reset0 = 0;
        fes_post_reset0 = 0;
      end else begin
            if ( WARNING_MSGS_ON )
        $display( "RESET is unknown. Edge alignment unpredictable." );
      end
      RESET_ipd_last_value = RESET_ipd;
    end

    if ( CLK_int !== CLK_int_last_value ) begin
      num_edges = num_edges + 1;
      if ( force_0 === 1'b1 ) begin
        Q <= 1'b0;
      end else if ( CLK_int === 1'bx ) begin
        Q <= 1'bx;
      end else if ( ( num_edges % DIV ) == 0 ) begin
        if ( Q === 1'bx ) begin
          Q <= CLK_int;
        end else begin
          Q <= !Q;
        end
      end
      CLK_int_last_value = CLK_int;
    end

  end

  initial
  begin
    DIV                  = 1;
    DivVal               = 0;
    Q                    = 1'bx;
    num_edges            = -1;
    res_post_reset0      = 0;
    fes_post_reset0      = 0;
    res_post_reset1      = 0;
    fes_post_reset1      = 0;
    CLK_prev_re          = 0;
    CLK_re               = 0;
    CLK_period           = 0;
    CLK_ipd_last_value   = 1'bx;
    RESET_ipd_last_value = 1'bx;
    CLK_int_last_value   = 1'bx;
    force_0              = 1'b1;
  end

  specify

    // No pin to pin path delays used in this model.

  endspecify

endmodule
//---- END MODULE CLKDIV_SDF ----

//---- MODULE CLKDIVDLY_SDF ----
/*--------------------------------------------------------------------
 CELL NAME : CLKDIVDLY_SDF 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module CLKDIVDLY_SDF (
  CLK,
  DLYGL0,
  DLYGL1,
  DLYGL2,
  DLYGL3,
  DLYGL4,
  GL
  );

  output GL;
  input  CLK; 
  input  DLYGL0;
  input  DLYGL1;
  input  DLYGL2;
  input  DLYGL3;
  input  DLYGL4;

  buf U0 ( GL, CLK );

  specify

    specparam tpdLH_CLK_to_GL = ( 100 : 100 : 100 );
    specparam tpdHL_CLK_to_GL = ( 100 : 100 : 100 );

    // pin to pin path delay

    ( CLK => GL ) = ( tpdLH_CLK_to_GL, tpdHL_CLK_to_GL );
    specparam PATHPULSE$CLK$GL = ( 100, 100 );

  endspecify


endmodule
//---- END MODULE CLKDIVDLY_SDF ----

//---- MODULE CLKDIVDLY1_SDF ----
/*--------------------------------------------------------------------
 CELL NAME : CLKDIVDLY1_SDF 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module CLKDIVDLY1_SDF (
  CLK,
  DLYY0,
  DLYY1,
  DLYY2,
  DLYY3,
  DLYY4,
  DLYGL0,
  DLYGL1,
  DLYGL2,
  DLYGL3,
  DLYGL4,
  GL,
  Y
  );

  output GL;
  output Y;
  input  CLK; 
  input  DLYY0;
  input  DLYY1;
  input  DLYY2;
  input  DLYY3;
  input  DLYY4;
  input  DLYGL0;
  input  DLYGL1;
  input  DLYGL2;
  input  DLYGL3;
  input  DLYGL4;

  buf U0 ( GL, CLK );
  buf U1 ( Y,  CLK );

  specify

    specparam tpdLH_CLK_to_GL = ( 100 : 100 : 100 );
    specparam tpdHL_CLK_to_GL = ( 100 : 100 : 100 );
    specparam tpdLH_CLK_to_Y  = ( 100 : 100 : 100 );
    specparam tpdHL_CLK_to_Y  = ( 100 : 100 : 100 );

    // pin to pin path delay

    ( CLK => GL ) = ( tpdLH_CLK_to_GL, tpdHL_CLK_to_GL );
    ( CLK => Y  ) = ( tpdLH_CLK_to_Y,  tpdHL_CLK_to_Y  );
    specparam PATHPULSE$CLK$GL = ( 100, 100 );
    specparam PATHPULSE$CLK$Y  = ( 100, 100 );

  endspecify


endmodule
//---- END MODULE CLKDIVDLY1_SDF ----

//---- MODULE CLKDLY ----
/*--------------------------------------------------------------------
 CELL NAME : CLKDLY 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module CLKDLY (
  CLK,
  DLYGL0,
  DLYGL1,
  DLYGL2,
  DLYGL3,
  DLYGL4,
  GL
  );

  output GL;
  input  CLK; 
  input  DLYGL0;
  input  DLYGL1;
  input  DLYGL2;
  input  DLYGL3;
  input  DLYGL4;

  parameter INTRINSIC_DELAY     = 528;
  parameter PROG_INIT_DELAY     = 535;
  parameter PROG_STEP_INCREMENT = 200;

  time       GLDELAY;

  wire [4:0] DLYGL_ipd;
  wire       CLK_ipd;

  reg        CLK_ipd_delayed;

  reg        dlygl_xor;
  integer    dlygl_step;

  buf U0 ( CLK_ipd, CLK );

  assign DLYGL_ipd[0]  = DLYGL0;
  assign DLYGL_ipd[1]  = DLYGL1;
  assign DLYGL_ipd[2]  = DLYGL2;
  assign DLYGL_ipd[3]  = DLYGL3;
  assign DLYGL_ipd[4]  = DLYGL4;

  buf BUF_DLY_0( GL, CLK_ipd_delayed );

  always @ ( DLYGL_ipd )
  begin
    dlygl_xor = ^ DLYGL_ipd;
    if ( dlygl_xor === 1'bX )
    begin
      GLDELAY <= 0;
    end else
    begin
      dlygl_step = DLYGL_ipd;
      GLDELAY <= ( dlygl_step == 0 ) ?
                 INTRINSIC_DELAY :
                 ( INTRINSIC_DELAY + ( dlygl_step * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY );
    end
  end

  always @( GLDELAY or CLK_ipd)
  begin
     CLK_ipd_delayed <= #(GLDELAY) CLK_ipd;
  end

  initial
  begin
    GLDELAY = 0;
  end
  
endmodule
//---- END MODULE CLKDLY ----

//---- MODULE CLKDLY_SDF ----
/*--------------------------------------------------------------------
 CELL NAME : CLKDLY_SDF 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module CLKDLY_SDF (
  CLK,
  DLYGL0,
  DLYGL1,
  DLYGL2,
  DLYGL3,
  DLYGL4,
  GL
  );

  output GL;
  input  CLK; 
  input  DLYGL0;
  input  DLYGL1;
  input  DLYGL2;
  input  DLYGL3;
  input  DLYGL4;

  buf U0( GL, CLK );

  specify

    specparam tpdLH_CLK_to_GL = ( 100 : 100 : 100 );
    specparam tpdHL_CLK_to_GL = ( 100 : 100 : 100 );

    // pin to pin path delay
    ( CLK => GL ) = ( tpdLH_CLK_to_GL, tpdHL_CLK_to_GL );
    specparam PATHPULSE$CLK$GL = ( 100 , 100 );

  endspecify


endmodule
//---- END MODULE CLKDLY_SDF ----

//---- MODULE PLLINT ----
/*--------------------------------------------------------------------
 CELL NAME : PLLINT 
 CELL TYPE : comb
 CELL LOGIC : Y=A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module PLLINT(Y,A);
 input A;
 output Y;

 buf    BUF_U_00(Y,A);

       specify

                specparam tpdLH_A_to_Y = (0.0:0.0:0.0);
                specparam tpdHL_A_to_Y = (0.0:0.0:0.0);
                specparam MacroType = "comb";

                //pin to pin path delay

                (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE PLLINT ----

//---- MODULE INBUF_A ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_A
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_A(Y,PAD);
 input PAD;
 output Y;

 assign Y = PAD;

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_A ----

//---- MODULE INBUF_DA ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_DA
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_DA(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 assign Y = PAD;

       specify

    specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
    specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
    specparam MacroType = "comb";

    //pin to pin path delay

    (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

    specparam PATHPULSE$PAD$Y = (0.1, 0.1);
    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_DA ----

//---- MODULE OUTBUF_A ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_A
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_A(PAD,D);
 input D;
 output PAD;

 assign PAD = D;

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_A ----

//---- MODULE CLKSRC ----
/*--------------------------------------------------------------------
 CELL NAME : CLKSRC
 CELL TYPE : comb
 CELL LOGIC : Y=A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKSRC ( Y, A );
 input  A;
 output Y;

 buf    BUF_U_00 ( Y, A );

       specify

                specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
                specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
                specparam MacroType = "comb";

                //pin to pin path delay

                (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKSRC ----

//---- MODULE XTLOSC ----
/*--------------------------------------------------------------------
 CELL NAME : XTLOSC 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module XTLOSC 
  (
  XTL,
  SELMODE,
  RTCMODE,
  MODE,
  CLKOUT
  );
`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif

  output CLKOUT;
  input  XTL;
  input  SELMODE;
  input [ 1 : 0 ] RTCMODE;
  input [ 1 : 0 ] MODE;

  `define PW_limit0 15625000
  `define PW_limit1  2500000
  `define PW_limit2   250000
  `define PW_limit3    25000

  wire XTL_int;
  wire SELMODE_int;
  wire [ 1 : 0 ] RTCMODE_int;
  wire [ 1 : 0 ] MODE_int;
  reg  CLKOUT_int;
  reg  XTL_last_value = 1'bx;

  wire [ 1 : 0 ] xtl_mode;
  reg  chk_PW  = 1'b0;
  time min_PW;
  time max_PW;
  time PW;
  time XTL_last_change = 0;

  buf U0 ( XTL_int, XTL );
  buf U1 ( SELMODE_int, SELMODE );
  buf U2 ( RTCMODE_int[ 1 ], RTCMODE[ 1 ] );
  buf U3 ( RTCMODE_int[ 0 ], RTCMODE[ 0 ] );
  buf U4 ( MODE_int[ 1 ], MODE[ 1 ] );
  buf U5 ( MODE_int[ 0 ], MODE[ 0 ] );
  buf U6 ( CLKOUT, CLKOUT_int );

  assign xtl_mode = SELMODE_int ? RTCMODE_int : MODE_int;

  always @( xtl_mode )
  begin
    case ( xtl_mode )
      2'b00 :
      begin
        chk_PW = 1'b0;
      end
      2'b01 :
      begin
        chk_PW = 1'b1;
        max_PW = `PW_limit0;
        min_PW = `PW_limit1;
      end
      2'b10 :
      begin
        chk_PW = 1'b1;
        max_PW = `PW_limit1;
        min_PW = `PW_limit2;
      end
      2'b11 :
      begin
        chk_PW = 1'b1;
        max_PW = `PW_limit2;
        min_PW = `PW_limit3;
      end
      default:
      begin
        chk_PW = 1'b1;
        max_PW = 0;
            if ( WARNING_MSGS_ON )
        $display( "Mode is unknown, unable to determine acceptable frequency range - no acceptable input frequencies at time %10g", $realtime);
      end
    endcase
  end

  always @( XTL_int )
  begin
    PW = $time - XTL_last_change;
    if ( XTL_int === 1'bx )
    begin
      CLKOUT_int = 1'bx;
    end else if ( chk_PW === 1'b1 &&
                  ( ( PW > max_PW ) || ( PW < min_PW ) ) &&
                  ( XTL_last_change > 0 ) )
    begin
      CLKOUT_int = 1'b0;
            if ( WARNING_MSGS_ON )
      $display( "XTL frequency not within acceptable frequency range at time %10g", $realtime);
    end else
    begin
      CLKOUT_int = XTL_int;
    end
    XTL_last_change = $time;
    XTL_last_value = XTL_int;
  end

  specify

    specparam tpdLH_XTL_to_CLKOUT = ( 100 : 100 : 100 );
    specparam tpdHL_XTL_to_CLKOUT = ( 100 : 100 : 100 );

    // pin to pin path delay

    ( XTL => CLKOUT ) = ( tpdLH_XTL_to_CLKOUT, tpdHL_XTL_to_CLKOUT );
  
  endspecify

endmodule
//---- END MODULE XTLOSC ----

//*****************************************************************************
//
//     Copyright (C) 2002. Actel Corporation  - All Rights Reserved.
//     
//                      PROPRIETARY INFORMATION
//
//     This document is CONFIDENATIAL and PROPRIETARY and is for
//     the use of Actel Corporation personnel only, except to the 
//     extent that permission is expressly granted elsewhere.
//
//
//
// File Name   :        ab.v
// Authors     :        Manish Dharod / Cyril Gaillard
//
// Function    :        Analog Block for G3SOC
//
// Assumptions :     1. 
//                   2.
//                   3.
//                   4.
//                   5.
//                   6.
//
//*****************************************************************************
//
// Detailed Revision History:
//
// Version  Date(YY/MM/DD)   Who              Description   
//
// 1.0      03/23/04         Manish Dharod.   First Version
// 1.1      09/21/04         Cyril Gaillard   Update based on the CAE spec version 2.2
// 1.2      07/13/05         Cyril Gaillard   Validated serializer/deserializer with ModelSim
//                                             - ATRETURN pads are now handled in deserialization
//                                             - Digital Inputs enable conditions supported in 
//                                               deserialization
//                                             -> serialization/deserialization now identical to 
//                                                VHDL model
//                                             Limitations: 
//                                              - Still not NC-Vlog compliant.
//                                              - Vector to Real conv not consistent with VHDL model
//                                                for vin_quad[0], vin_quad[2], cin_quad[9] and
//                                                tin_quad[9] when using tb_ab.vhd test-bench. 
//                                                            
// 1.3                      Cyril Gaillard 
//
// 1.4     07/06/06         Sreeni Angitapalli   Implemented counter for asserting CALIBRATE for 3840
//                                               ADC clock cycles
// 1.5     08/10/06         Sreeni Angitapalli   Update ACM configuration checking logic
//                                               (signals replaced with variables)
//
//*****************************************************************************

`timescale 1 ps/1 ps

 // module declaration ----

module AB (
	   inout VAREF,
	   input wire GNDREF,
	   input wire AV0,
	   input wire AC0,
	   input wire AT0,
	   input wire AV1,
	   input wire AC1,
	   input wire AT1,
	   input wire AV2,
	   input wire AC2,
	   input wire AT2,
	   input wire AV3,
	   input wire AC3,
	   input wire AT3,
	   input wire AV4,
	   input wire AC4,
	   input wire AT4,
	   input wire AV5,
	   input wire AC5,
	   input wire AT5,
	   input wire AV6,
	   input wire AC6,
	   input wire AT6,
	   input wire AV7,
	   input wire AC7,
	   input wire AT7,
	   input wire AV8,
	   input wire AC8,
	   input wire AT8,
	   input wire AV9,
	   input wire AC9,
           input wire AT9,
           input wire ATRETURN01,
           input wire ATRETURN23,
           input wire ATRETURN45,
           input wire ATRETURN67,
           input wire ATRETURN89,
	   input wire CMSTB0,
	   input wire CMSTB1,
	   input wire CMSTB2,
	   input wire CMSTB3,
	   input wire CMSTB4,
	   input wire CMSTB5,
	   input wire CMSTB6,
	   input wire CMSTB7,
	   input wire CMSTB8,
	   input wire CMSTB9,
	   input wire GDON0,
	   input wire GDON1,
	   input wire GDON2,
	   input wire GDON3,
	   input wire GDON4,
	   input wire GDON5,
	   input wire GDON6,
	   input wire GDON7,
	   input wire GDON8,
	   input wire GDON9,
	   input wire TMSTB0,
	   input wire TMSTB1,
	   input wire TMSTB2,
	   input wire TMSTB3,
	   input wire TMSTB4,
	   input wire TMSTB5,
	   input wire TMSTB6,
	   input wire TMSTB7,
	   input wire TMSTB8,
	   input wire TMSTB9,
           input wire TMSTBINT,
	   input wire DENAV0,
	   input wire DENAC0,
	   input wire DENAT0,
	   input wire DENAV1,
	   input wire DENAC1,
	   input wire DENAT1,
	   input wire DENAV2,
	   input wire DENAC2,
	   input wire DENAT2,
	   input wire DENAV3,
	   input wire DENAC3,
	   input wire DENAT3,
	   input wire DENAV4,
	   input wire DENAC4,
	   input wire DENAT4,
	   input wire DENAV5,
	   input wire DENAC5,
	   input wire DENAT5,
	   input wire DENAV6,
	   input wire DENAC6,
	   input wire DENAT6,
	   input wire DENAV7,
	   input wire DENAC7,
	   input wire DENAT7,
	   input wire DENAV8,
	   input wire DENAC8,
	   input wire DENAT8,
	   input wire DENAV9,
	   input wire DENAC9,
	   input wire DENAT9,
	   input wire [3:0] MODE,
	   input wire SYSCLK,
           input wire RTCCLK,
	   input wire [7:0] TVC,
	   input wire [7:0] STC,
	   input wire VAREFSEL,
	   input wire [4:0] CHNUMBER,
	   input wire ADCSTART,
	   input wire PWRDWN,
	   input wire ADCRESET,
           input wire ACMCLK,
	   input wire ACMWEN,
	   input wire ACMRESET,
	   input wire [7:0] ACMWDATA,
	   input wire [7:0] ACMADDR,
	   output wire DAVOUT0,
	   output wire DACOUT0,
	   output wire DATOUT0,
	   output wire DAVOUT1,
	   output wire DACOUT1,
	   output wire DATOUT1,
	   output wire DAVOUT2,
	   output wire DACOUT2,
	   output wire DATOUT2,
	   output wire DAVOUT3,
	   output wire DACOUT3,
	   output wire DATOUT3,
	   output wire DAVOUT4,
	   output wire DACOUT4,
	   output wire DATOUT4,
	   output wire DAVOUT5,
	   output wire DACOUT5,
	   output wire DATOUT5,
	   output wire DAVOUT6,
	   output wire DACOUT6,
	   output wire DATOUT6,
	   output wire DAVOUT7,
	   output wire DACOUT7,
	   output wire DATOUT7,
	   output wire DAVOUT8,
	   output wire DACOUT8,
	   output wire DATOUT8,
	   output wire DAVOUT9,
	   output wire DACOUT9,
	   output wire DATOUT9,
	   output wire AG0,
	   output wire AG1,
	   output wire AG2,
	   output wire AG3,
	   output wire AG4,
	   output wire AG5,
	   output wire AG6,
	   output wire AG7,
	   output wire AG8,
	   output wire AG9,
	   output      BUSY,
	   output      CALIBRATE,
	   output      DATAVALID,
	   output      SAMPLE,
	   output      [11:0] RESULT,
           output wire [1:0] RTCXTLMODE,
           output wire RTCXTLSEL,
           output wire RTCMATCH,
           output wire RTCPSMMATCH, 
	   output      [7:0] ACMRDATA
          );
  
  parameter WIDTH              = 32;
  parameter MEMORYFILE         = "";
`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif

  // Used to turn off warnings messages.
  // Default = ON.  Set to 0 to turn them OFF.

  parameter FAST_ADC_CONV_SIM  = 0;

  // Setting FAST_ADC_CONV_SIM to True will allow much faster ADC conversion time:
  // In this fast simulation mode, the time for latching input and output data (one SYSCLK period each),
  // and the time for sampling the analog input signal ((2 + STC) * ADCCLK period) are not accounted for.
  // Default = OFF.  Set to 0 to turn it ON.  
  // ** Important: This is a simulation mode *only*. There is no equivalent mode on silicon.


  real                           va_ref_i;
  real                           va_ref_ext;

  real                           SCALING_FACTOR0; 
  real                           SCALING_FACTOR1;
  real                           SCALING_FACTOR2;
  real                           SCALING_FACTOR3;
  real                           SCALING_FACTOR4;
  real                           SCALING_FACTOR5;
  real                           SCALING_FACTOR6;
  real                           SCALING_FACTOR7;
  integer                        SYSCLK_CYCLES_PCAL;

  wire signed [2 * WIDTH-1:0]    AV0_VECTOR;
  wire signed [2 * WIDTH-1:0]    AV1_VECTOR;
  wire signed [2 * WIDTH-1:0]    AV2_VECTOR;
  wire signed [2 * WIDTH-1:0]    AV3_VECTOR;
  wire signed [2 * WIDTH-1:0]    AV4_VECTOR;
  wire signed [2 * WIDTH-1:0]    AV5_VECTOR;
  wire signed [2 * WIDTH-1:0]    AV6_VECTOR;
  wire signed [2 * WIDTH-1:0]    AV7_VECTOR;
  wire signed [2 * WIDTH-1:0]    AV8_VECTOR;
  wire signed [2 * WIDTH-1:0]    AV9_VECTOR;
  wire signed [2 * WIDTH-1:0]    AC0_VECTOR;
  wire signed [2 * WIDTH-1:0]    AC1_VECTOR;
  wire signed [2 * WIDTH-1:0]    AC2_VECTOR;
  wire signed [2 * WIDTH-1:0]    AC3_VECTOR;
  wire signed [2 * WIDTH-1:0]    AC4_VECTOR;
  wire signed [2 * WIDTH-1:0]    AC5_VECTOR;
  wire signed [2 * WIDTH-1:0]    AC6_VECTOR;
  wire signed [2 * WIDTH-1:0]    AC7_VECTOR;
  wire signed [2 * WIDTH-1:0]    AC8_VECTOR;
  wire signed [2 * WIDTH-1:0]    AC9_VECTOR;
  wire signed [2 * WIDTH-1:0]    AT0_VECTOR;
  wire signed [2 * WIDTH-1:0]    AT1_VECTOR;
  wire signed [2 * WIDTH-1:0]    AT2_VECTOR;
  wire signed [2 * WIDTH-1:0]    AT3_VECTOR;
  wire signed [2 * WIDTH-1:0]    AT4_VECTOR;
  wire signed [2 * WIDTH-1:0]    AT5_VECTOR;
  wire signed [2 * WIDTH-1:0]    AT6_VECTOR;
  wire signed [2 * WIDTH-1:0]    AT7_VECTOR;
  wire signed [2 * WIDTH-1:0]    AT8_VECTOR;
  wire signed [2 * WIDTH-1:0]    AT9_VECTOR;
  wire signed [2 * WIDTH-1:0]    VA_REF_VECTOR, GND_REF_VECTOR;
  reg  signed [2 * WIDTH-1:0]    AV_VECTOR[9:0];
  reg  signed [2 * WIDTH-1:0]    AC_VECTOR[9:0];
  reg  signed [2 * WIDTH-1:0]    AT_VECTOR[9:0];

  real 	                         va_ref_real, gnd_ref_real, va_ref_real_out;
  reg 	                         bit;
  real 	                         MUXOUT;
  integer                        SYSCLK_previous, SYSCLK_period, ADC_CLK_period;
  reg [7:0]                      MEMORY[0:89];
  reg 	                         ADC_CLK;

  reg [3:0]                      MODE_i;
  reg [7:0]                      STC_i, TVC_i;
  reg [4:0]                      CHNUMBER_i;

  wire signed [2 * WIDTH-1:0]    vin_quad_prescaled0, cin_quad_prescaled0, tin_quad_prescaled0;
  wire signed [2 * WIDTH-1:0]    vin_quad_prescaled1, cin_quad_prescaled1, tin_quad_prescaled1;
  wire signed [2 * WIDTH-1:0]    vin_quad_prescaled2, cin_quad_prescaled2, tin_quad_prescaled2;
  wire signed [2 * WIDTH-1:0]    vin_quad_prescaled3, cin_quad_prescaled3, tin_quad_prescaled3;
  wire signed [2 * WIDTH-1:0]    vin_quad_prescaled4, cin_quad_prescaled4, tin_quad_prescaled4;
  wire signed [2 * WIDTH-1:0]    vin_quad_prescaled5, cin_quad_prescaled5, tin_quad_prescaled5;
  wire signed [2 * WIDTH-1:0]    vin_quad_prescaled6, cin_quad_prescaled6, tin_quad_prescaled6;
  wire signed [2 * WIDTH-1:0]    vin_quad_prescaled7, cin_quad_prescaled7, tin_quad_prescaled7;
  wire signed [2 * WIDTH-1:0]    vin_quad_prescaled8, cin_quad_prescaled8, tin_quad_prescaled8;
  wire signed [2 * WIDTH-1:0]    vin_quad_prescaled9, cin_quad_prescaled9, tin_quad_prescaled9;

  wire signed [2 * WIDTH-1:0]    v_muxout0, c_muxout0, t_muxout0;
  wire signed [2 * WIDTH-1:0]    v_muxout1, c_muxout1, t_muxout1;
  wire signed [2 * WIDTH-1:0]    v_muxout2, c_muxout2, t_muxout2;
  wire signed [2 * WIDTH-1:0]    v_muxout3, c_muxout3, t_muxout3;
  wire signed [2 * WIDTH-1:0]    v_muxout4, c_muxout4, t_muxout4;
  wire signed [2 * WIDTH-1:0]    v_muxout5, c_muxout5, t_muxout5;
  wire signed [2 * WIDTH-1:0]    v_muxout6, c_muxout6, t_muxout6;
  wire signed [2 * WIDTH-1:0]    v_muxout7, c_muxout7, t_muxout7;
  wire signed [2 * WIDTH-1:0]    v_muxout8, c_muxout8, t_muxout8;
  wire signed [2 * WIDTH-1:0]    v_muxout9, c_muxout9, t_muxout9;

  wire signed [2 * WIDTH-1:0]    curr_monitor0, temp_monitor0;
  wire signed [2 * WIDTH-1:0]    curr_monitor1, temp_monitor1;
  wire signed [2 * WIDTH-1:0]    curr_monitor2, temp_monitor2;
  wire signed [2 * WIDTH-1:0]    curr_monitor3, temp_monitor3;
  wire signed [2 * WIDTH-1:0]    curr_monitor4, temp_monitor4;
  wire signed [2 * WIDTH-1:0]    curr_monitor5, temp_monitor5;
  wire signed [2 * WIDTH-1:0]    curr_monitor6, temp_monitor6;
  wire signed [2 * WIDTH-1:0]    curr_monitor7, temp_monitor7;
  wire signed [2 * WIDTH-1:0]    curr_monitor8, temp_monitor8;
  wire signed [2 * WIDTH-1:0]    curr_monitor9, temp_monitor9;

  wire [9:0]    gd_ctrl;
  real 		v1, v2;
  time          t_conv, t_sync_read, t_sample, t_distrib, t_cal;
  time   	t_powerup_cal, t_sync_write, busy_start_time;
  time          sample_start_time, calibration_start_time, busy_elapsed_time;
  reg 		ad_res_int;
  reg           acm_wen;
  reg [39:0]    aq_byte;
  reg [7:0]     acm_address_lat;
  reg [7:0]     aq_wdata;
  reg           aq_wen, byte_en;
  reg           osc_clk;
  integer 	calibration_started, busy_int, conversion_started, fper_cal_count, sysclk_count;
  integer       oscp_count, oscn_count, count1;
  //real        interrupt_cal, adc_input, vref;
  real          adc_input, vref;
  reg           sysclk_check, adcclk_check;
  reg           check1, check2;
  reg           VA_REF_out;
  reg           interrupt_cal;
  integer       CALIBRATE_cnt;
  reg           CALIBRATE_reg;
  reg           BUSY_reg;
  reg           DATAVALID_reg;
  reg           SAMPLE_reg;
  reg [11:0]    RESULT_reg;
  reg [7:0]     ACMRDATA_reg;
  wire 		AV0_ipd, AC0_ipd, AT0_ipd, AV1_ipd, AC1_ipd, AT1_ipd, AV2_ipd, AC2_ipd, AT2_ipd;
  wire          AV3_ipd, AC3_ipd, AT3_ipd, AV4_ipd, AC4_ipd, AT4_ipd, AV5_ipd, AC5_ipd, AT5_ipd;
  wire          AV6_ipd, AC6_ipd, AT6_ipd, AV7_ipd, AC7_ipd, AT7_ipd, AV8_ipd, AC8_ipd, AT8_ipd;
  wire          AV9_ipd, AC9_ipd, AT9_ipd;
  wire          CMSTB0_ipd, CMSTB1_ipd, CMSTB2_ipd, CMSTB3_ipd, CMSTB4_ipd;
  wire          CMSTB5_ipd, CMSTB6_ipd, CMSTB7_ipd, CMSTB8_ipd, CMSTB9_ipd;
  wire          GDON0_ipd,  GDON1_ipd,  GDON2_ipd,  GDON3_ipd,  GDON4_ipd;
  wire          GDON5_ipd,  GDON6_ipd,  GDON7_ipd,  GDON8_ipd,  GDON9_ipd;
  wire          TMSTB0_ipd, TMSTB1_ipd, TMSTB2_ipd, TMSTB3_ipd, TMSTB4_ipd;
  wire          TMSTB5_ipd, TMSTB6_ipd, TMSTB7_ipd, TMSTB8_ipd, TMSTB9_ipd;
  wire          DENAV0_ipd, DENAC0_ipd, DENAT0_ipd, DENAV1_ipd, DENAC1_ipd, DENAT1_ipd;
  wire          DENAV2_ipd, DENAC2_ipd, DENAT2_ipd, DENAV3_ipd, DENAC3_ipd, DENAT3_ipd;
  wire          DENAV4_ipd, DENAC4_ipd, DENAT4_ipd, DENAV5_ipd, DENAC5_ipd, DENAT5_ipd;
  wire          DENAV6_ipd, DENAC6_ipd, DENAT6_ipd, DENAV7_ipd, DENAC7_ipd, DENAT7_ipd;
  wire          DENAV8_ipd, DENAC8_ipd, DENAT8_ipd, DENAV9_ipd, DENAC9_ipd, DENAT9_ipd;
  wire [3:0]    MODE_ipd;
  wire          SYSCLK_ipd, ACMCLK_ipd;
  wire [7:0]    TVC_ipd;
  wire [7:0]    STC_ipd;
  wire          VAREF_in;
  wire          VAREF_out;
  wire          VAREFSEL_ipd;
  wire [4:0]    CHNUMBER_ipd;
  wire 	        ADCSTART_ipd, PWRDWN_ipd, ADCRESET_ipd, ACMWEN_ipd;
  wire [7:0]    ACMWDATA_ipd;
  wire [7:0]    ACMADDR_ipd;

  wire          v_prescale_enable0, v_prescale_enable1, v_prescale_enable2, v_prescale_enable3, v_prescale_enable4;
  wire          v_prescale_enable5, v_prescale_enable6, v_prescale_enable7, v_prescale_enable8, v_prescale_enable9;

  wire          volt_polarity0, volt_polarity1, volt_polarity2, volt_polarity3, volt_polarity4;
  wire          volt_polarity5, volt_polarity6, volt_polarity7, volt_polarity8, volt_polarity9;

  wire          v_direct_switch0, v_direct_switch1, v_direct_switch2, v_direct_switch3, v_direct_switch4;
  wire          v_direct_switch5, v_direct_switch6, v_direct_switch7, v_direct_switch8, v_direct_switch9;
  wire          c_direct_switch0, c_direct_switch1, c_direct_switch2, c_direct_switch3, c_direct_switch4;
  wire          c_direct_switch5, c_direct_switch6, c_direct_switch7, c_direct_switch8, c_direct_switch9;
  wire          t_direct_switch0, t_direct_switch1, t_direct_switch2, t_direct_switch3, t_direct_switch4;
  wire          t_direct_switch5, t_direct_switch6, t_direct_switch7, t_direct_switch8, t_direct_switch9;

  wire          curr_monitor_switch0, curr_monitor_switch1, curr_monitor_switch2, curr_monitor_switch3;
  wire          curr_monitor_switch4, curr_monitor_switch5, curr_monitor_switch6, curr_monitor_switch7;
  wire          curr_monitor_switch8, curr_monitor_switch9;
  wire          v_mux_select0, v_mux_select1, v_mux_select2, v_mux_select3, v_mux_select4;
  wire          v_mux_select5, v_mux_select6, v_mux_select7, v_mux_select8, v_mux_select9;
  wire [1:0]    c_mux_select0, c_mux_select1, c_mux_select2, c_mux_select3, c_mux_select4;
  wire [1:0]    c_mux_select5, c_mux_select6, c_mux_select7, c_mux_select8, c_mux_select9;
  wire [1:0]    t_mux_select0, t_mux_select1, t_mux_select2, t_mux_select3, t_mux_select4;
  wire [1:0]    t_mux_select5, t_mux_select6, t_mux_select7, t_mux_select8, t_mux_select9;

  wire [2:0]    v_prescale_select0, v_prescale_select1, v_prescale_select2, v_prescale_select3, v_prescale_select4;
  wire [2:0]    v_prescale_select5, v_prescale_select6, v_prescale_select7, v_prescale_select8, v_prescale_select9;
  wire [2:0]    c_prescale_select0, c_prescale_select1, c_prescale_select2, c_prescale_select3, c_prescale_select4;
  wire [2:0]    c_prescale_select5, c_prescale_select6, c_prescale_select7, c_prescale_select8, c_prescale_select9;
  wire [2:0]    t_prescale_select0, t_prescale_select1, t_prescale_select2, t_prescale_select3, t_prescale_select4;
  wire [2:0]    t_prescale_select5, t_prescale_select6, t_prescale_select7, t_prescale_select8, t_prescale_select9;


  genvar        i;
  integer       m, n, o, p, q;
  reg [11:0]    result_temp, comparator_output_8, comparator_output_10;
  reg [11:0]    comparator_output_12, comparator_output_12_temp;
  
  reg   [7:0]   AQ_ACM_ADDR, RTC_ADDR;
  wire [39:0]   ind_match_bits; 
  reg  [39:0]   rtc_counter_bits, rtc_match_reg_bits; 
  reg  [39:0]   capture_reg;
  wire          rstb_cnt, rtm_rst, cntr_en, vr_en_match, rst_cnt_on_match;
  reg           prescaler_clk;
  integer       prescaler_xtl_count;

  // ACM memory access variables
  reg           INIT_MEM, reset_memory, write_acm_aq_wdata_to_memory, read_ctrl_stat_reg;
  reg           read_rtc_counter_byte0, read_rtc_counter_byte1, read_rtc_counter_byte2;
  reg           read_rtc_counter_byte3, read_rtc_counter_byte4, read_match_reg_byte0;
  reg           read_match_reg_byte1, read_match_reg_byte2, read_match_reg_byte3;
  reg           read_match_reg_byte4, read_ind_match_byte0, read_ind_match_byte1;
  reg           read_ind_match_byte2, read_ind_match_byte3, read_ind_match_byte4, read_ind_match_byt;

  // edge detection variables
  reg           INIT_MEM_prev, ACMCLK_mem_prev, reset_memory_prev, write_acm_aq_wdata_to_memory_prev;
  reg           ADCRESET_tvc_prev, ADCSTART_tvc_prev, SYSCLK_tvc_prev, RTCCLK_prev, ACMCLK_prev;
  reg           prescaler_clk_prev, SYSCLK_adc_prev; 
  reg           read_rtc_counter_byte0_prev, read_rtc_counter_byte1_prev;
  reg           read_rtc_counter_byte2_prev, read_rtc_counter_byte3_prev, read_rtc_counter_byte4_prev;
  reg           read_match_reg_byte0_prev, read_match_reg_byte1_prev, read_match_reg_byte2_prev;
  reg           read_match_reg_byte3_prev, read_match_reg_byte4_prev, read_ind_match_byte0_prev;
  reg           read_ind_match_byte1_prev, read_ind_match_byte2_prev, read_ind_match_byte3_prev;
  reg           read_ind_match_byte4_prev, read_ctrl_stat_reg_prev;

  reg           NOTIFY_REG;
  
  buf U31 (ATRETURN01_ipd, ATRETURN01);
  buf U32 (ATRETURN23_ipd, ATRETURN23);
  buf U33 (ATRETURN45_ipd, ATRETURN45);
  buf U34 (ATRETURN67_ipd, ATRETURN67);
  buf U35 (ATRETURN89_ipd, ATRETURN89);
  buf U36 (CMSTB0_ipd, CMSTB0);
  buf U37 (CMSTB1_ipd, CMSTB1);
  buf U38 (CMSTB2_ipd, CMSTB2);
  buf U39 (CMSTB3_ipd, CMSTB3);
  buf U40 (CMSTB4_ipd, CMSTB4);
  buf U41 (CMSTB5_ipd, CMSTB5);
  buf U42 (CMSTB6_ipd, CMSTB6);
  buf U43 (CMSTB7_ipd, CMSTB7);
  buf U44 (CMSTB8_ipd, CMSTB8);
  buf U45 (CMSTB9_ipd, CMSTB9);
  buf U46 (TMSTB0_ipd, TMSTB0);
  buf U47 (TMSTB1_ipd, TMSTB1);
  buf U48 (TMSTB2_ipd, TMSTB2);
  buf U49 (TMSTB3_ipd, TMSTB3);
  buf U50 (TMSTB4_ipd, TMSTB4);
  buf U51 (TMSTB5_ipd, TMSTB5);
  buf U52 (TMSTB6_ipd, TMSTB6);
  buf U53 (TMSTB7_ipd, TMSTB7);
  buf U54 (TMSTB8_ipd, TMSTB8);
  buf U55 (TMSTB9_ipd, TMSTB9);
  buf U56 (GDON0_ipd,  GDON0);
  buf U57 (GDON1_ipd,  GDON1);
  buf U58 (GDON2_ipd,  GDON2);
  buf U59 (GDON3_ipd,  GDON3);
  buf U60 (GDON4_ipd,  GDON4);
  buf U61 (GDON5_ipd,  GDON5);
  buf U62 (GDON6_ipd,  GDON6);
  buf U63 (GDON7_ipd,  GDON7);
  buf U64 (GDON8_ipd,  GDON8);
  buf U65 (GDON9_ipd,  GDON9);
  buf U66 (DENAV0_ipd, DENAV0);
  buf U67 (DENAV1_ipd, DENAV1);
  buf U68 (DENAV2_ipd, DENAV2);
  buf U69 (DENAV3_ipd, DENAV3);
  buf U70 (DENAV4_ipd, DENAV4);
  buf U71 (DENAV5_ipd, DENAV5);
  buf U72 (DENAV6_ipd, DENAV6);
  buf U73 (DENAV7_ipd, DENAV7);
  buf U74 (DENAV8_ipd, DENAV8);
  buf U75 (DENAV9_ipd, DENAV9);
  buf U76 (DENAC0_ipd, DENAC0);
  buf U77 (DENAC1_ipd, DENAC1);
  buf U78 (DENAC2_ipd, DENAC2);
  buf U79 (DENAC3_ipd, DENAC3);
  buf U80 (DENAC4_ipd, DENAC4);
  buf U81 (DENAC5_ipd, DENAC5);
  buf U82 (DENAC6_ipd, DENAC6);
  buf U83 (DENAC7_ipd, DENAC7);
  buf U84 (DENAC8_ipd, DENAC8);
  buf U85 (DENAC9_ipd, DENAC9);
  buf U86 (DENAT0_ipd, DENAT0);
  buf U87 (DENAT1_ipd, DENAT1);
  buf U88 (DENAT2_ipd, DENAT2);
  buf U89 (DENAT3_ipd, DENAT3);
  buf U90 (DENAT4_ipd, DENAT4);
  buf U91 (DENAT5_ipd, DENAT5);
  buf U92 (DENAT6_ipd, DENAT6);
  buf U93 (DENAT7_ipd, DENAT7);
  buf U94 (DENAT8_ipd, DENAT8);
  buf U95 (DENAT9_ipd, DENAT9);
  buf U96 (SYSCLK_ipd, SYSCLK);

  buf U97  (ADCSTART_ipd, ADCSTART);
  buf U98  (PWRDWN_ipd,   PWRDWN);
  buf U99  (ADCRESET_ipd, ADCRESET);
  buf U102 (ACMCLK_ipd,   ACMCLK);
  buf U103 (ACMWEN_ipd,   ACMWEN);
  buf U105 (ACMRESET_ipd, ACMRESET);
  buf U106 (VAREFSEL_ipd, VAREFSEL);

  generate
    for (i = 0; i <= 3; i = i+1)
      begin:mode_wiredelay
      	buf U107 (MODE_ipd[i], MODE[i]);
      end
  endgenerate

  generate
    for (i = 0; i <= 7; i = i+1)
      begin:div_wiredelay
      	buf U108 (TVC_ipd[i], TVC[i]);
      end
  endgenerate

  generate
    for (i = 0; i <= 7; i = i+1)
      begin:stc_wiredelay
      	buf U109 (STC_ipd[i], STC[i]);
      end
  endgenerate

  generate
    for (i = 0; i <= 4; i = i+1)
      begin:chsel_wiredelay
      	buf U110 (CHNUMBER_ipd[i], CHNUMBER[i]);
      end
  endgenerate

  generate
    for (i = 0; i <= 7; i = i+1)
      begin:wdata_wiredelay
      	buf U111 (ACMWDATA_ipd[i], ACMWDATA[i]);
      end
  endgenerate

  generate
    for (i = 0; i <= 7; i = i+1)
      begin:addr_wiredelay
      	buf U112 (ACMADDR_ipd[i], ACMADDR[i]);
      end
  endgenerate

   buf U155 (RTCCLK_ipd, RTCCLK);   

  generate 
    for (i = 0; i <= 39; i = i+1)
      begin:ind_match_bits_generate
        xnor U156 (ind_match_bits[i], rtc_counter_bits[i], rtc_match_reg_bits[i]);
      end
  endgenerate

   //
   // Digital Inputs
   //

    and U114 (DAVOUT0, AV0, DENAV0_ipd);
    and U115 (DACOUT0, AC0, DENAC0_ipd);
    and U116 (DATOUT0, AT0, DENAT0_ipd);
    and U117 (DAVOUT1, AV1, DENAV1_ipd);
    and U118 (DACOUT1, AC1, DENAC1_ipd);
    and U119 (DATOUT1, AT1, DENAT1_ipd);
    and U120 (DAVOUT2, AV2, DENAV2_ipd);
    and U121 (DACOUT2, AC2, DENAC2_ipd);
    and U122 (DATOUT2, AT2, DENAT2_ipd);
    and U123 (DAVOUT3, AV3, DENAV3_ipd);
    and U124 (DACOUT3, AC3, DENAC3_ipd);
    and U125 (DATOUT3, AT3, DENAT3_ipd);
    and U126 (DAVOUT4, AV4, DENAV4_ipd);
    and U127 (DACOUT4, AC4, DENAC4_ipd);
    and U128 (DATOUT4, AT4, DENAT4_ipd);
    and U129 (DAVOUT5, AV5, DENAV5_ipd);
    and U130 (DACOUT5, AC5, DENAC5_ipd);
    and U131 (DATOUT5, AT5, DENAT5_ipd);
    and U132 (DAVOUT6, AV6, DENAV6_ipd);
    and U134 (DACOUT6, AC6, DENAC6_ipd);
    and U135 (DATOUT6, AT6, DENAT6_ipd);
    and U136 (DAVOUT7, AV7, DENAV7_ipd);
    and U137 (DACOUT7, AC7, DENAC7_ipd);
    and U138 (DATOUT7, AT7, DENAT7_ipd);
    and U139 (DAVOUT8, AV8, DENAV8_ipd);
    and U140 (DACOUT8, AC8, DENAC8_ipd);
    and U141 (DATOUT8, AT8, DENAT8_ipd);
    and U142 (DAVOUT9, AV9, DENAV9_ipd);
    and U143 (DACOUT9, AC9, DENAC9_ipd);
    and U144 (DATOUT9, AT9, DENAT9_ipd);

   //
   // Gate Drive Quads
   //

    bufif1 (weak0, weak1)     (AG0, 1'b0, GDON0 & ~gd_ctrl[0]);
    bufif1 (weak0, weak1)     (AG1, 1'b0, GDON1 & ~gd_ctrl[1]);
    bufif1 (weak0, weak1)     (AG2, 1'b0, GDON2 & ~gd_ctrl[2]);
    bufif1 (weak0, weak1)     (AG3, 1'b0, GDON3 & ~gd_ctrl[3]);
    bufif1 (weak0, weak1)     (AG4, 1'b0, GDON4 & ~gd_ctrl[4]);
    bufif1 (weak0, weak1)     (AG5, 1'b0, GDON5 & ~gd_ctrl[5]);
    bufif1 (weak0, weak1)     (AG6, 1'b0, GDON6 & ~gd_ctrl[6]);
    bufif1 (weak0, weak1)     (AG7, 1'b0, GDON7 & ~gd_ctrl[7]);
    bufif1 (weak0, weak1)     (AG8, 1'b0, GDON8 & ~gd_ctrl[8]);
    bufif1 (weak0, weak1)     (AG9, 1'b0, GDON9 & ~gd_ctrl[9]);

    bufif1 (strong0, strong1) (AG0, 1'b0, GDON0 & gd_ctrl[0]);
    bufif1 (strong0, strong1) (AG1, 1'b0, GDON1 & gd_ctrl[1]);
    bufif1 (strong0, strong1) (AG2, 1'b0, GDON2 & gd_ctrl[2]);
    bufif1 (strong0, strong1) (AG3, 1'b0, GDON3 & gd_ctrl[3]);
    bufif1 (strong0, strong1) (AG4, 1'b0, GDON4 & gd_ctrl[4]);
    bufif1 (strong0, strong1) (AG5, 1'b0, GDON5 & gd_ctrl[5]);
    bufif1 (strong0, strong1) (AG6, 1'b0, GDON6 & gd_ctrl[6]);
    bufif1 (strong0, strong1) (AG7, 1'b0, GDON7 & gd_ctrl[7]);
    bufif1 (strong0, strong1) (AG8, 1'b0, GDON8 & gd_ctrl[8]);
    bufif1 (strong0, strong1) (AG9, 1'b0, GDON9 & gd_ctrl[9]);

    // Pmos switch to drive output signals
    // (NCVerilog does not allow reg in specify block)
    
    pmos   U167 (BUSY     , BUSY_reg     , 0);
    pmos   U168 (CALIBRATE, CALIBRATE_reg, 0);
    pmos   U169 (DATAVALID, DATAVALID_reg, 0);
    pmos   U170 (SAMPLE   , SAMPLE_reg   , 0);

    generate
      for (i = 0; i <= 11; i = i+1)
        begin : result_pmos_gen
          pmos   U171 (RESULT[i]  , RESULT_reg[i]  , 0);
        end
    endgenerate

    generate
      for (i = 0; i <= 7; i = i+1)
        begin : acmrdata_pmos_gen
          pmos   U172 (ACMRDATA[i], ACMRDATA_reg[i], 0);
        end
    endgenerate


  /* -- PROCEDURES & FUNCTIONS -- */

  ///

  // Verilog uses IEEE-754 Floating Point Double Precision standard for its $realtobits and $bitstoreal conversions
  // In IEEE-754 Floating Point Double Precision, bit 64 is the sign bit: 0 for positive and 1 for negative values.

  function [63:0] generate_quad_prescaled;

  input  [15:0]   pad_type;
  input  integer  pad_number;
  input  [63:0]   quad;
  input           polarity;
  input           prescale_en;
  input  [2:0]    prescale_sel;
  input  [63:0]   varef;

  real        quad_real; 
  reg  [63:0] quad_prescaled_temp;

  begin
    if ( prescale_en )
      begin
        if ( ( ( polarity == 1'b1 ) && ( quad[63] == 1'b0 ) ) || ( ( polarity == 1'b0 ) && ( quad[63] == 1'b1 ) ) ) 
          begin
            generate_quad_prescaled = 64'b0000000000000000000000000000000000000000000000000000000000000000;
            if ( WARNING_MSGS_ON )
              $display ("Polarity error: The sign and polarity bit are not consistent. The prescaler output will be 0.0 - %s %d, at time %0.1f\n",pad_type, pad_number[3:0], $realtime);
          end
        else
          begin
            quad_real = $bitstoreal ( quad );
            case ( prescale_sel )
              0       : quad_prescaled_temp = $realtobits ( quad_real * SCALING_FACTOR0 );
              1       : quad_prescaled_temp = $realtobits ( quad_real * SCALING_FACTOR1 );
              2       : quad_prescaled_temp = $realtobits ( quad_real * SCALING_FACTOR2 );
              3       : quad_prescaled_temp = $realtobits ( quad_real * SCALING_FACTOR3 );
              4       : quad_prescaled_temp = $realtobits ( quad_real * SCALING_FACTOR4 );
              5       : quad_prescaled_temp = $realtobits ( quad_real * SCALING_FACTOR5 );
              6       : quad_prescaled_temp = $realtobits ( quad_real * SCALING_FACTOR6 );
              7       : quad_prescaled_temp = $realtobits ( quad_real * SCALING_FACTOR7 );
              default : quad_prescaled_temp = $realtobits ( quad_real * SCALING_FACTOR0 );
            endcase 
            if ( $bitstoreal ( get_abs_val ( quad_prescaled_temp ) ) > $bitstoreal ( varef ) )
              begin
                generate_quad_prescaled = varef; // Saturation
                if ( WARNING_MSGS_ON )
                  $display ( "Warning : Prescaler output saturation - The internal reference voltage is the Prescaler maximum output value - %s %d, at time %0.1f\n", pad_type, pad_number[3:0], $realtime );
              end
            else 
              generate_quad_prescaled = get_abs_val ( quad_prescaled_temp );
          end
      end
    else
      generate_quad_prescaled = 64'b0000000000000000000000000000000000000000000000000000000000000000;
  end
  endfunction

  ///

  function [63:0] generate_tin_quad_prescaled;

  input  integer  pad_number;
  input  [63:0]   quad;
  input           polarity;
  input           prescale_en;
  input  [2:0]    prescale_sel;
  input  [63:0]   varef;

  real        quad_real; 
  reg  [63:0] quad_prescaled_temp;

  begin
    if ( prescale_en )
      begin
        if ( ( polarity == 1'b1 ) || ( quad[63] == 1'b1  ) )
          begin
            generate_tin_quad_prescaled = 64'b0000000000000000000000000000000000000000000000000000000000000000;
            if ( WARNING_MSGS_ON )
              $display ( "AT quad only accepts positive voltages, and T-pad polarity has to be set to 0 (Positive) - AT %d, at time %0.1f\n", pad_number[3:0], $realtime);
          end
        else
          begin
            quad_real = $bitstoreal ( quad );
            case ( prescale_sel )
              0       : quad_prescaled_temp = $realtobits ( quad_real * SCALING_FACTOR0 ); 
              2       : quad_prescaled_temp = $realtobits ( quad_real * SCALING_FACTOR2 );
              default : begin
                          quad_prescaled_temp = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                          if ( WARNING_MSGS_ON )
                            $display ( "Warning : Invalid Prescaler control value for Temperature Monitor block - AT %d, at time %0.1f\n", pad_number[3:0], $realtime ) ;
                        end
            endcase 
            if ( $bitstoreal ( get_abs_val ( quad_prescaled_temp ) ) > $bitstoreal ( varef ) )
              begin
                generate_tin_quad_prescaled = varef; // Saturation
                if ( WARNING_MSGS_ON )
                  $display ( "Warning : Temperature Prescaler output saturation - The internal reference voltage is the Temperature Prescaler maximum output value - AT %d, at time %0.1f\n", pad_number[3:0], $realtime );
              end
            else
              generate_tin_quad_prescaled = get_abs_val ( quad_prescaled_temp );
          end
      end
    else
      generate_tin_quad_prescaled = 64'b0000000000000000000000000000000000000000000000000000000000000000;
  end
  endfunction 

  ///

  function [63:0] curr_monitor_fct;

  input  integer  pad_number;
  input  [63:0]   ac_vect;
  input           curr_polarity;
  input  [63:0]   av_vect;
  input           volt_polarity;
  input           cmen;
  input           cm_switch;
  input  [63:0]   varef;

  begin
   if ( ( cmen == 1'b1 ) && ( cm_switch == 1'b1 ) )
     begin
       if ( ( !ac_vect[63] && curr_polarity ) || ( ac_vect[63] && !curr_polarity ) || ( !av_vect[63] && volt_polarity ) || ( av_vect[63] && !volt_polarity ) )
          begin
            curr_monitor_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
            if ( WARNING_MSGS_ON )
              $display ("Polarity error: AV and/or AC sign and polarity bit are not consistent. The Current Monitor output will be 0.0 - AV/AC %d, at time  %0.1f\n", pad_number[3:0], $realtime );
          end
       else if ( ( curr_polarity != volt_polarity ) || ( ac_vect[63] != av_vect[63] ) )
         begin
         curr_monitor_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
           if ( WARNING_MSGS_ON )
             $display ( "Warning : Invalid Current Monitor inputs - AV and AC need to have same sign and polarity - AV/AC %d, at time %0.1f\n", pad_number[3:0], $realtime);
         end
       else if ( ( $bitstoreal ( get_abs_val( av_vect ) ) - ( $bitstoreal ( get_abs_val( ac_vect ) ) ) ) * 10.0 > $bitstoreal ( varef ) )
         begin
           curr_monitor_fct = varef; // Saturation
           if ( WARNING_MSGS_ON ) 
             $display ( "Warning : Current Monitor output saturation - The internal reference voltage is the Current Monitor maximum output value - AC %d, at time %0.1f\n", pad_number[3:0], $realtime );
         end
       else if ( ( $bitstoreal ( get_abs_val( av_vect ) ) - ( $bitstoreal ( get_abs_val( ac_vect ) ) ) ) < 0.0 )
         begin
           curr_monitor_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
           if ( WARNING_MSGS_ON )
             $display ( "Warning : Absolute value of AC should not be greater than absolute value of AV. Current monitor output will be 0.0 - AV/AC %d, at time %0.1f\n", pad_number[3:0], $realtime );
         end
       else
         curr_monitor_fct = $realtobits ( ( $bitstoreal ( get_abs_val( av_vect ) ) - $bitstoreal ( get_abs_val( ac_vect ) ) ) * 10.0 );
     end
   else curr_monitor_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
  end
  endfunction

  ///

  function [63:0] temp_monitor_fct;

  input  integer  pad_number;
  input  [63:0]   at_vect;
  input           temp_polarity;
  input           tmen;
  input  [63:0]   varef;

  begin
   if ( tmen == 1'b1 )
     begin
       if ( at_vect[63] || temp_polarity ) 
         begin
           temp_monitor_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
           if ( WARNING_MSGS_ON ) 
             $display ( "Warning : AT quad only accepts positive voltages, and T-pad polarity has to be set to 0 (Positive) - AT %d, at time %0.1f\n", pad_number[3:0], $realtime);
         end
       else if ( !temp_polarity && ( ( ( $bitstoreal ( get_abs_val ( at_vect ) ) ) * 12.5 ) > $bitstoreal ( varef ) ) )
         begin
           temp_monitor_fct = varef; // Saturation
           if ( WARNING_MSGS_ON ) 
             $display ( "Warning : Temperature Monitor output saturation: The internal reference voltage is the Temperature Monitor maximum output value - AT %d, at time %0.1f\n", pad_number[3:0], $realtime);
         end
       else 
         temp_monitor_fct = $realtobits ( ( $bitstoreal ( get_abs_val ( at_vect ) ) ) * 12.5 );
     end
   else temp_monitor_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
  end
  endfunction

  ///

  function [63:0] v_muxout_fct;

  input  integer  pad_number;
  input           v_mux_select;
  input           v_direct_switch;
  input           v_prescale_en;
  input  [63:0]   vin_quad_prescaled;
  input   [2:0]   v_prescale_sel;
  input  [63:0]   av_vect;
  input           cm_switch;

  begin
    case ( v_mux_select )
       1'b0    : if ( ( v_prescale_en ) && ( !v_direct_switch ) )
                   v_muxout_fct = vin_quad_prescaled;
                 else
                   begin
                     v_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                     if ( ( $time > 0 ) && ( av_vect[63:1] !== 63'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ) && ( ! ( ( cm_switch == 1'b1 ) && ( v_direct_switch == 1'b0 ) && ( v_prescale_en == 1'b0 ) && ( v_prescale_sel == 3'b000 ) ) ) )
                       // In the above conditions: Current Monitor is selected and AV is driven (required for C.M. purposes). 
                       // Still, Voltage Monitoring is unused (the AV-quad settings are the SOCGen default settings for unused quad).
            if ( WARNING_MSGS_ON )
                         $display ( "Error : When using the Voltage Prescaler, the AV Prescaler Opamp mode needs to be powered up, and the AV direct analog input switch needs to be switched OFF - AV %d, at time %0.1f\n", pad_number[3:0], $realtime);
                   end

       1'b1    : if ( ( !v_prescale_en ) && ( v_direct_switch ) )
                   begin
                     if ( av_vect[63] == 1'b1 ) // if AV < 0
                       begin
                         v_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                         if ( WARNING_MSGS_ON )
                           $display ( "Warning : When the Voltage Direct Analog Input is selected, the voltage on AV can not be negative, at time %0.1f\n", $realtime);
                       end
                     else if ( v_prescale_sel != 3'b0 )
                       begin
                         v_muxout_fct = av_vect;
                         if ( WARNING_MSGS_ON )
                           $display ( "Warning : When the Voltage Direct Analog Input is selected, the scaling factor needs to be 100 or higher, otherwise this can lead to ADC conversion inaccuracy, at time %0.1f\n", $realtime);
            if ( WARNING_MSGS_ON )
                           $display ( "Warning : When the Voltage Direct Analog Input is selected, the scaling factor needs to be 000 to protect prescaler from accidental higher voltages - AV %d, at time %0.1f\n", pad_number[3:0], $realtime);
                       end
                     else
                       v_muxout_fct = av_vect;
                   end
                 else
                   begin
                     v_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                     if ( $time > 0 )
            if ( WARNING_MSGS_ON )
                       $display ( "Error : When using the Voltage Direct Analog Input, the AV direct analog input switch needs to be switched on, and the AV Prescaler Opamp mode needs to be powerdown - AV %d, at time %0.1f\n", pad_number[3:0], $realtime);
                   end
       default : if ( ( v_prescale_en ) && ( !v_direct_switch ) )
                   v_muxout_fct = vin_quad_prescaled;
                 else
                   begin
                     v_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                     if ( ( $time > 0 ) && ( av_vect[63:1] !== 63'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ) && ( ! ( ( cm_switch == 1'b1 ) && ( v_direct_switch == 1'b0 ) && ( v_prescale_en == 1'b0 ) && ( v_prescale_sel == 3'b000 ) ) ) )
            if ( WARNING_MSGS_ON )
                       $display ( "Error : When using the Voltage Prescaler, the AV Prescaler Opamp mode needs to be powered up, and the AV direct analog input switch needs to be switched OFF - AV %d, at time %0.1f\n", pad_number[3:0], $realtime);
                   end

     endcase
  end
  endfunction

  ///

  function [63:0] c_muxout_fct;

  input  integer  pad_number;
  input  [1:0]    c_mux_select;
  input           c_direct_switch;
  input           c_prescale_en;
  input           curr_mon_switch;
  input           v_direct_switch;
  input  [63:0]   cin_quad_prescaled;
  input   [2:0]   c_prescale_sel;
  input  [63:0]   ac_vect;
  input  [63:0]   av_vect;
  input  [63:0]   varef_vect;
  input  [63:0]   curr_monitor;

  begin
    case ( c_mux_select )
       2'b00   : if ( ( c_prescale_en ) && ( !c_direct_switch ) && ( !curr_mon_switch ) )
                   c_muxout_fct = cin_quad_prescaled;
                 else
                   begin
                     c_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                     if ( ( $time > 0 ) && ( ac_vect[63:1] !== 63'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ) )
            if ( WARNING_MSGS_ON )
                       $display ( "Error : When using the Current Prescaler, the AC Prescaler Opamp mode needs to be powered up, and the AC direct analog input and Current Monitor switches need to be switched OFF - AC %d, at time %0.1f\n", pad_number[3:0], $realtime);
                   end
       2'b01   : if ( ( !c_prescale_en ) && ( c_direct_switch ) && ( !curr_mon_switch ) )
                   begin
                     if ( ac_vect[63] == 1'b1 ) // if AC < 0
                       begin
                         c_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                         if ( WARNING_MSGS_ON )
                           $display ( "Warning : When the Current Direct Analog Input is selected, the voltage on AC can not be negative - AC %d, at time %0.1f\n", pad_number[3:0], $realtime);
                       end
                     else if ( c_prescale_sel != 0 )
                       begin
                         c_muxout_fct = ac_vect;
                         if ( WARNING_MSGS_ON )
                           $display ( "Warning : When the Current Direct Analog Input is selected, the scaling factor needs to be 100 or higher, otherwise this can lead to ADC conversion inaccuracy - AC %d, at time %0.1f\n", pad_number[3:0], $realtime);
                         if ( WARNING_MSGS_ON )
                           $display ( "Warning : When the Current Direct Analog Input is selected, the scaling factor needs to be 000 to protect prescaler from accidental higher voltages - AC %d, at time %0.1f\n", pad_number[3:0], $realtime);
                       end
                     else
                       c_muxout_fct = ac_vect;
                   end
                 else
                   begin
                     c_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                     if ( $time > 0 )
                       if ( WARNING_MSGS_ON )
                       $display ( "Error : When using the Current Direct Analog Input, the AC direct analog input switch needs to be switched on, the AC Prescaler Opamp mode needs to be powerdown, and the Current Monitor switch needs to be switched OFF - AC %d, at time %0.1f\n", pad_number[3:0], $realtime);
                   end
       2'b10   : if ( ( !c_prescale_en ) && ( !c_direct_switch ) && ( curr_mon_switch ) && ( ( !v_direct_switch ) || ( ( v_direct_switch ) && ( $bitstoreal(av_vect) >= 0.0 ) && ( $bitstoreal(av_vect) < $bitstoreal(varef_vect) ) ) ) )
                   c_muxout_fct = curr_monitor;
                 else
                   begin
                     c_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                     if ( $time > 0 )
                       if ( WARNING_MSGS_ON )
                       $display ( "Error : When using the Current Monitor, the Current Monitor switch needs to be switched ON, and the AC direct analog input switch needs to be switched OFF, and the AC Prescaler Opamp mode needs to be powerdown. The AV direct analog input switch can be switched ON if AV is positive and less than the internal VAREF (default is 2.56V). Otherwise, the AV direct analog input switch needs to be OFF. At time %0.1f\n", $realtime);
                   end

       default : if ( ( c_prescale_en ) && ( !c_direct_switch ) && ( !curr_mon_switch ) )
                   c_muxout_fct = cin_quad_prescaled;
                 else
                   begin
                     c_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                     if ( ( $time > 0 ) && ( ac_vect[63:1] !== 63'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ) )
                       if ( WARNING_MSGS_ON )
                       $display ( "Error : When using the Current Prescaler, the AC Prescaler Opamp mode needs to be powered up, and the AC direct analog input and Current Monitor switches need to be switched OFF - AC %d, at time %0.1f\n", pad_number[3:0], $realtime);
                   end

     endcase
  end
  endfunction
  
  ///

  function [63:0] t_muxout_fct;

  input  integer  pad_number;
  input  [1:0]    t_mux_select;
  input           t_direct_switch;
  input           t_prescale_en;
  input  [63:0]   tin_quad_prescaled;
  input  [63:0]   at_vect;
  input  [63:0]   temp_monitor;

  begin
    case ( t_mux_select )
       2'b00   : if ( ( t_prescale_en ) && ( !t_direct_switch ) )
                   t_muxout_fct = tin_quad_prescaled;
                 else
                   begin
                     t_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                     if ( ( $time > 0 ) && ( at_vect[63:1] !== 63'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ) )
                       if ( WARNING_MSGS_ON )
                       $display ( "Error : When using the Temperature Prescaler, the AT Prescaler Opamp mode needs to be powered up, and the AT direct analog input switch needs to be switched OFF - AT %d, at time %0.1f\n", pad_number[3:0], $realtime);
                   end
       //2'b01   : if ( ( !t_prescale_en ) && ( t_direct_switch ) )
       2'b01   : if ( ( t_prescale_en ) && ( t_direct_switch ) )
                   begin
                     if ( at_vect[63] == 1'b1 )
                       begin
                         t_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                       if ( WARNING_MSGS_ON )
                         $display ( "Warning : The voltage on AT-quad can not be negative - AT %d, at time %0.1f\n", pad_number[3:0], $realtime);
                       end
                     else
                       t_muxout_fct = at_vect;
                   end
                 else
                   begin
                     t_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                     if ( $time > 0 )
                       if ( WARNING_MSGS_ON )
                       $display ( "Error : When using the Temperature Direct Analog Input, the AT direct analog input switch needs to be switched on, and the AT Prescaler Opamp mode needs to be powered up - AT %d, at time %0.1f\n", pad_number[3:0], $realtime);
                   end
       2'b10   : if ( ( !t_prescale_en ) && ( !t_direct_switch ) )
                   t_muxout_fct = temp_monitor;
                 else
                   begin
                     t_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                     if ( $time > 0 )
                       if ( WARNING_MSGS_ON )
                       $display ( "Error : When using the Temperature Monitor, the direct analog input switch needs to be switched OFF, and the AT Prescaler Opamp mode needs to be powerdown - AT %d, at time %0.1f\n", pad_number[3:0], $realtime);
                   end

       default : if ( ( t_prescale_en ) && ( !t_direct_switch ) )
                   t_muxout_fct = tin_quad_prescaled;
                 else
                   begin
                     t_muxout_fct = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                     if ( ( $time > 0 ) && ( at_vect[63:1] !== 63'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ) )
                       if ( WARNING_MSGS_ON )
                       $display ( "Error : When using the Temperature Prescaler, the AT Prescaler Opamp mode needs to be powered up, and the AT direct analog input switch needs to be switched OFF - AT %d, at time %0.1f\n", pad_number[3:0], $realtime);
                   end

     endcase
  end
  endfunction

  ///

  function [63:0] get_abs_val;

  input  [63:0]  quad_vect;

  begin
    if ( (quad_vect[63]) == 1'b0 ) // if quad_vect real positive
      get_abs_val = quad_vect;
    else
      get_abs_val = {1'b0,quad_vect[62:0]};
  end
  endfunction

  /* ---- - ---- - ---- - ---- -  */

  // Continuous assignments

    // Internal and external VAREF handling
    assign VAREF_in  = ( VAREFSEL_ipd == 1'b1 ) ? VAREF     : 1'bz;
    assign VAREF     = ( VAREFSEL_ipd == 1'b0 ) ? VAREF_out : 1'bz;

    // CTRL_STAT FPB_ADDR 0x58
    assign  rtm_rst           = MEMORY [87][7];
    assign  cntr_en           = MEMORY [87][6];
    assign  vr_en_match       = MEMORY [87][5];
    assign  RTCXTLMODE[1]     = MEMORY [87][4];
    assign  RTCXTLMODE[0]     = MEMORY [87][3];
    assign  rst_cnt_on_match  = MEMORY [87][2];
    assign  rstb_cnt          = MEMORY [87][1];
    assign  RTCXTLSEL         = MEMORY [87][0];

    // RTC MATCH and PSMMATCH
    assign  RTCMATCH    = & ind_match_bits;
    assign  RTCPSMMATCH = RTCMATCH && vr_en_match;

    // Gate Control 
    assign gd_ctrl[0] = MEMORY [2][7];
    assign gd_ctrl[1] = MEMORY [6][7];
    assign gd_ctrl[2] = MEMORY [10][7];
    assign gd_ctrl[3] = MEMORY [14][7];
    assign gd_ctrl[4] = MEMORY [18][7];
    assign gd_ctrl[5] = MEMORY [22][7];
    assign gd_ctrl[6] = MEMORY [26][7];
    assign gd_ctrl[7] = MEMORY [30][7];
    assign gd_ctrl[8] = MEMORY [34][7];
    assign gd_ctrl[9] = MEMORY [38][7];

  // #########################################################
  // # Behavior Section
  // #########################################################

  initial
    begin
      va_ref_i            = 2.56;
      va_ref_ext          = 0.00;
      va_ref_real         = 2.56;
      SCALING_FACTOR0     = 0.15625;
      SCALING_FACTOR1     = 0.3125;
      SCALING_FACTOR2     = 0.625;
      SCALING_FACTOR3     = 1.25;
      SCALING_FACTOR4     = 2.5;
      SCALING_FACTOR5     = 5.0;
      SCALING_FACTOR6     = 10.0;
      SCALING_FACTOR7     = 20.0;
      SYSCLK_CYCLES_PCAL  = 3840;
      SYSCLK_previous     = 0;
      ad_res_int          = 1'b0;
      fper_cal_count      = 0;
      busy_int            = 0;
      calibration_started = 0;
      INIT_MEM_prev       = 1'b0;
      INIT_MEM            = 1'b1;
      ACMCLK_mem_prev     = 1'b0;
      reset_memory        = 1'b0;
      reset_memory_prev   = 1'b0;
      ADCRESET_tvc_prev   = 1'b0;
      ADCSTART_tvc_prev   = 1'b0;
      SYSCLK_tvc_prev     = 1'b0;
      SYSCLK_adc_prev     = 1'b0;
      RTCCLK_prev         = 1'b0;
      ACMCLK_prev         = 1'b0;
      prescaler_clk_prev  = 1'b0;

      write_acm_aq_wdata_to_memory_prev = 1'b0;
      read_rtc_counter_byte0_prev       = 1'b0;
      read_rtc_counter_byte1_prev       = 1'b0;
      read_rtc_counter_byte2_prev       = 1'b0;
      read_rtc_counter_byte3_prev       = 1'b0;
      read_rtc_counter_byte4_prev       = 1'b0;
      read_match_reg_byte0_prev         = 1'b0;
      read_match_reg_byte1_prev         = 1'b0;
      read_match_reg_byte2_prev         = 1'b0;
      read_match_reg_byte3_prev         = 1'b0;
      read_match_reg_byte4_prev         = 1'b0;
      read_ind_match_byte0_prev         = 1'b0;
      read_ind_match_byte1_prev         = 1'b0;
      read_ind_match_byte2_prev         = 1'b0;
      read_ind_match_byte3_prev         = 1'b0;
      read_ind_match_byte4_prev         = 1'b0;
      read_ctrl_stat_reg_prev           = 1'b0;
      write_acm_aq_wdata_to_memory      = 1'b0;
      read_rtc_counter_byte0            = 1'b0;
      read_rtc_counter_byte1            = 1'b0;
      read_rtc_counter_byte2            = 1'b0;
      read_rtc_counter_byte3            = 1'b0;
      read_rtc_counter_byte4            = 1'b0;
      read_match_reg_byte0              = 1'b0;
      read_match_reg_byte1              = 1'b0;
      read_match_reg_byte2              = 1'b0;
      read_match_reg_byte3              = 1'b0;
      read_match_reg_byte4              = 1'b0;
      read_ind_match_byte0              = 1'b0;
      read_ind_match_byte1              = 1'b0;
      read_ind_match_byte2              = 1'b0;
      read_ind_match_byte3              = 1'b0;
      read_ind_match_byte4              = 1'b0;
      read_ctrl_stat_reg                = 1'b0;
    end


  // ------------------------------------------
  // --    Memory Initialization             -- 
  // --    and  RTC                          --
  // ------------------------------------------

  reg INIT_MEM_event, ACMCLK_event, RTCCLK_event, reset_memory_event, write_acm_aq_wdata_to_memory_event;

  always @ ( INIT_MEM, reset_memory,  write_acm_aq_wdata_to_memory, ACMCLK_ipd, RTCCLK_ipd, rtm_rst )

    begin

      INIT_MEM_event                     = ( INIT_MEM                     !== INIT_MEM_prev );
      ACMCLK_event                       = ( ACMCLK_ipd                   !== ACMCLK_prev );
      RTCCLK_event                       = ( RTCCLK_ipd                   !== RTCCLK_prev );
      reset_memory_event                 = ( reset_memory                 !== reset_memory_prev );
      write_acm_aq_wdata_to_memory_event = ( write_acm_aq_wdata_to_memory !== write_acm_aq_wdata_to_memory_prev );

      if ( INIT_MEM_event )
        begin
          // CTRL_STAT power-up values
          MEMORY[87] = 8'b00000000;
          if ( MEMORYFILE != "")
            $readmemb ( MEMORYFILE, MEMORY );
          else 
            begin
                       if ( WARNING_MSGS_ON )
              $display ( "Warning: No memory initialization file parameter MEMORYFILE was defined\n");
            end
        end
  
      if ( reset_memory_event ) 
        for ( o = 0; o <= 40; o = o+1)
          begin
            MEMORY[o] = 8'b00000000;
          end
      else if ( write_acm_aq_wdata_to_memory_event && ( AQ_ACM_ADDR > 0 && AQ_ACM_ADDR <= 40 ) )
        begin
          // All AQ/ACM Memory write operations
`ifdef FUSION_DEBUG
                       if ( WARNING_MSGS_ON )
          $display("FUSION_ACM: AQ WRITE - ACMWDATA %d, ACMADDR %d =? AQ_ACM_ADDR",aq_wdata,ACMADDR,AQ_ACM_ADDR);
`endif 
            MEMORY[AQ_ACM_ADDR-1][0] = aq_wdata[0];
            MEMORY[AQ_ACM_ADDR-1][1] = aq_wdata[1];
            MEMORY[AQ_ACM_ADDR-1][2] = aq_wdata[2];
            MEMORY[AQ_ACM_ADDR-1][3] = aq_wdata[3];
            MEMORY[AQ_ACM_ADDR-1][4] = aq_wdata[4];
            MEMORY[AQ_ACM_ADDR-1][5] = aq_wdata[5];
            MEMORY[AQ_ACM_ADDR-1][6] = aq_wdata[6];
            MEMORY[AQ_ACM_ADDR-1][7] = aq_wdata[7];
        end
      else if ( ACMCLK_event && ACMCLK_ipd == 1'b1 && ACMWEN_ipd == 1'b1 ) 
        begin
          `ifdef FUSION_DEBUG
                       if ( WARNING_MSGS_ON )
          $display("FUSION_ACM:RTC WRITE - ACMWDATA %d, ACMADDR %d =? AQ_ACM_ADDR",aq_wdata,ACMADDR,AQ_ACM_ADDR);
          `endif
          // All RTC Memory and RTC registers write operations
          case ( ACMADDR )
            8'b01000000 : 
                begin
                  MEMORY [63][0] = ACMWDATA_ipd [0];
                  MEMORY [63][1] = ACMWDATA_ipd [1];
                  MEMORY [63][2] = ACMWDATA_ipd [2];
                  MEMORY [63][3] = ACMWDATA_ipd [3];
                  MEMORY [63][4] = ACMWDATA_ipd [4];
                  MEMORY [63][5] = ACMWDATA_ipd [5];
                  MEMORY [63][6] = ACMWDATA_ipd [6];
                  MEMORY [63][7] = ACMWDATA_ipd [7];
                  if ( cntr_en == 1'b1 ) 
                    begin
                      if ( WARNING_MSGS_ON ) 
                        $display ( "Warning : Before writing to the counter registers, the counter must be disabled, at time %0.1f\n", $realtime);
                    end
                  else if ( rstb_cnt == 1'b1 && cntr_en == 1'b0 && rtm_rst == 1'b0 )
                    begin
                      rtc_counter_bits [0] = MEMORY [63][0];
                      rtc_counter_bits [1] = MEMORY [63][1];
                      rtc_counter_bits [2] = MEMORY [63][2];
                      rtc_counter_bits [3] = MEMORY [63][3];
                      rtc_counter_bits [4] = MEMORY [63][4];
                      rtc_counter_bits [5] = MEMORY [63][5];
                      rtc_counter_bits [6] = MEMORY [63][6];
                      rtc_counter_bits [7] = MEMORY [63][7];
                    end
                end
            8'b01000001 : 
                begin
                  MEMORY [64][0] = ACMWDATA_ipd [0];
                  MEMORY [64][1] = ACMWDATA_ipd [1];
                  MEMORY [64][2] = ACMWDATA_ipd [2];
                  MEMORY [64][3] = ACMWDATA_ipd [3];
                  MEMORY [64][4] = ACMWDATA_ipd [4];
                  MEMORY [64][5] = ACMWDATA_ipd [5];
                  MEMORY [64][6] = ACMWDATA_ipd [6];
                  MEMORY [64][7] = ACMWDATA_ipd [7];
                  if ( cntr_en == 1'b1 )
                    begin
                      if ( WARNING_MSGS_ON ) 
                       if ( WARNING_MSGS_ON )
                        $display ( "Warning : Before writing to the counter registers, the counter must be disabled, at time %0.1f\n", $realtime);
                    end
                  else if ( rstb_cnt == 1'b1 && cntr_en == 1'b0 && rtm_rst == 1'b0 )
                    begin
                      rtc_counter_bits [ 8] = MEMORY [64][0];
                      rtc_counter_bits [ 9] = MEMORY [64][1];
                      rtc_counter_bits [10] = MEMORY [64][2];
                      rtc_counter_bits [11] = MEMORY [64][3];
                      rtc_counter_bits [12] = MEMORY [64][4];
                      rtc_counter_bits [13] = MEMORY [64][5];
                      rtc_counter_bits [14] = MEMORY [64][6];
                      rtc_counter_bits [15] = MEMORY [64][7];
                    end
                end
            8'b01000010 : 
                begin
                  MEMORY [65][0] = ACMWDATA_ipd [0];
                  MEMORY [65][1] = ACMWDATA_ipd [1];
                  MEMORY [65][2] = ACMWDATA_ipd [2];
                  MEMORY [65][3] = ACMWDATA_ipd [3];
                  MEMORY [65][4] = ACMWDATA_ipd [4];
                  MEMORY [65][5] = ACMWDATA_ipd [5];
                  MEMORY [65][6] = ACMWDATA_ipd [6];
                  MEMORY [65][7] = ACMWDATA_ipd [7];
                  if ( cntr_en == 1'b1 ) 
                    begin
                      if ( WARNING_MSGS_ON ) 
                       if ( WARNING_MSGS_ON )
                        $display ( "Warning : Before writing to the counter registers, the counter must be disabled, at time %0.1f\n", $realtime); 
                    end
                  else if ( rstb_cnt == 1'b1 && cntr_en == 1'b0 && rtm_rst == 1'b0 ) 
                      begin
                        rtc_counter_bits [16] = MEMORY [65][0];
                        rtc_counter_bits [17] = MEMORY [65][1];
                        rtc_counter_bits [18] = MEMORY [65][2];
                        rtc_counter_bits [19] = MEMORY [65][3];
                        rtc_counter_bits [20] = MEMORY [65][4];
                        rtc_counter_bits [21] = MEMORY [65][5];
                        rtc_counter_bits [22] = MEMORY [65][6];
                        rtc_counter_bits [23] = MEMORY [65][7];
                      end
                end
            8'b01000011 : 
                begin
                  MEMORY [66][0] = ACMWDATA_ipd [0];
                  MEMORY [66][1] = ACMWDATA_ipd [1];
                  MEMORY [66][2] = ACMWDATA_ipd [2];
                  MEMORY [66][3] = ACMWDATA_ipd [3];
                  MEMORY [66][4] = ACMWDATA_ipd [4];
                  MEMORY [66][5] = ACMWDATA_ipd [5];
                  MEMORY [66][6] = ACMWDATA_ipd [6];
                  MEMORY [66][7] = ACMWDATA_ipd [7];
                  if ( cntr_en == 1'b1 ) 
                    begin
                      if ( WARNING_MSGS_ON )
                        $display ( "Warning : Before writing to the counter registers, the counter must be disabled, at time %0.1f\n", $realtime); 
                    end
                  else if ( rstb_cnt == 1'b1 && cntr_en == 1'b0 && rtm_rst == 1'b0 ) 
                    begin
                      rtc_counter_bits [24] = MEMORY [66][0];
                      rtc_counter_bits [25] = MEMORY [66][1];
                      rtc_counter_bits [26] = MEMORY [66][2];
                      rtc_counter_bits [27] = MEMORY [66][3];
                      rtc_counter_bits [28] = MEMORY [66][4];
                      rtc_counter_bits [29] = MEMORY [66][5];
                      rtc_counter_bits [30] = MEMORY [66][6];
                      rtc_counter_bits [31] = MEMORY [66][7];
                    end
                end
            8'b01000100 :
                begin
                  MEMORY [67][0] = ACMWDATA_ipd [0];
                  MEMORY [67][1] = ACMWDATA_ipd [1];
                  MEMORY [67][2] = ACMWDATA_ipd [2];
                  MEMORY [67][3] = ACMWDATA_ipd [3];
                  MEMORY [67][4] = ACMWDATA_ipd [4];
                  MEMORY [67][5] = ACMWDATA_ipd [5];
                  MEMORY [67][6] = ACMWDATA_ipd [6];
                  MEMORY [67][7] = ACMWDATA_ipd [7];
                  if ( cntr_en == 1'b1 )
                    begin
                      if ( WARNING_MSGS_ON )
                        $display ( "Warning : Before writing to the counter registers, the counter must be disabled, at time %0.1f\n", $realtime);
                    end
                  else if ( rstb_cnt == 1'b1 && cntr_en == 1'b0 && rtm_rst == 1'b0 )
                    begin
                      rtc_counter_bits [32] = MEMORY [67][0];
                      rtc_counter_bits [33] = MEMORY [67][1];
                      rtc_counter_bits [34] = MEMORY [67][2];
                      rtc_counter_bits [35] = MEMORY [67][3];
                      rtc_counter_bits [36] = MEMORY [67][4];
                      rtc_counter_bits [37] = MEMORY [67][5];
                      rtc_counter_bits [38] = MEMORY [67][6];
                      rtc_counter_bits [39] = MEMORY [67][7];
                    end
                end
          
            8'b01001000 :
                begin
                  MEMORY [71][0] = ACMWDATA_ipd [0];
                  MEMORY [71][1] = ACMWDATA_ipd [1];
                  MEMORY [71][2] = ACMWDATA_ipd [2];
                  MEMORY [71][3] = ACMWDATA_ipd [3];
                  MEMORY [71][4] = ACMWDATA_ipd [4];
                  MEMORY [71][5] = ACMWDATA_ipd [5];
                  MEMORY [71][6] = ACMWDATA_ipd [6];
                  MEMORY [71][7] = ACMWDATA_ipd [7];
                  if ( rtm_rst == 1'b0 )
                    begin
                      rtc_match_reg_bits [0] = MEMORY [71][0];
                      rtc_match_reg_bits [1] = MEMORY [71][1];
                      rtc_match_reg_bits [2] = MEMORY [71][2];
                      rtc_match_reg_bits [3] = MEMORY [71][3];
                      rtc_match_reg_bits [4] = MEMORY [71][4];
                      rtc_match_reg_bits [5] = MEMORY [71][5];
                      rtc_match_reg_bits [6] = MEMORY [71][6];
                      rtc_match_reg_bits [7] = MEMORY [71][7];
                    end
                end
            8'b01001001 : 
                begin
                  MEMORY [72][0] = ACMWDATA_ipd [0]; 
                  MEMORY [72][1] = ACMWDATA_ipd [1];
                  MEMORY [72][2] = ACMWDATA_ipd [2];
                  MEMORY [72][3] = ACMWDATA_ipd [3];
                  MEMORY [72][4] = ACMWDATA_ipd [4];
                  MEMORY [72][5] = ACMWDATA_ipd [5];
                  MEMORY [72][6] = ACMWDATA_ipd [6];
                  MEMORY [72][7] = ACMWDATA_ipd [7];
                  if ( rtm_rst == 1'b0 )
                    begin
                      rtc_match_reg_bits [ 8] = MEMORY [72][0];
                      rtc_match_reg_bits [ 9] = MEMORY [72][1];  
                      rtc_match_reg_bits [10] = MEMORY [72][2];  
                      rtc_match_reg_bits [11] = MEMORY [72][3];  
                      rtc_match_reg_bits [12] = MEMORY [72][4];  
                      rtc_match_reg_bits [13] = MEMORY [72][5];  
                      rtc_match_reg_bits [14] = MEMORY [72][6];  
                      rtc_match_reg_bits [15] = MEMORY [72][7];
                    end
                end
            8'b01001010 : 
                begin
                  MEMORY [73][0] = ACMWDATA_ipd [0]; 
                  MEMORY [73][1] = ACMWDATA_ipd [1];
                  MEMORY [73][2] = ACMWDATA_ipd [2];
                  MEMORY [73][3] = ACMWDATA_ipd [3];
                  MEMORY [73][4] = ACMWDATA_ipd [4];
                  MEMORY [73][5] = ACMWDATA_ipd [5];
                  MEMORY [73][6] = ACMWDATA_ipd [6];
                  MEMORY [73][7] = ACMWDATA_ipd [7];
                  if ( rtm_rst == 1'b0 ) 
                    begin
                      rtc_match_reg_bits [16] = MEMORY [73][0];
                      rtc_match_reg_bits [17] = MEMORY [73][1];
                      rtc_match_reg_bits [18] = MEMORY [73][2];
                      rtc_match_reg_bits [19] = MEMORY [73][3];
                      rtc_match_reg_bits [20] = MEMORY [73][4];
                      rtc_match_reg_bits [21] = MEMORY [73][5];
                      rtc_match_reg_bits [22] = MEMORY [73][6];
                      rtc_match_reg_bits [23] = MEMORY [73][7];
                    end
                end
            8'b01001011 : 
                begin
                  MEMORY [74][0] = ACMWDATA_ipd [0]; 
                  MEMORY [74][1] = ACMWDATA_ipd [1];
                  MEMORY [74][2] = ACMWDATA_ipd [2];
                  MEMORY [74][3] = ACMWDATA_ipd [3];
                  MEMORY [74][4] = ACMWDATA_ipd [4];
                  MEMORY [74][5] = ACMWDATA_ipd [5];
                  MEMORY [74][6] = ACMWDATA_ipd [6];
                  MEMORY [74][7] = ACMWDATA_ipd [7];
                  if ( rtm_rst == 1'b0 ) 
                    begin
                      rtc_match_reg_bits [24] = MEMORY [74][0];
                      rtc_match_reg_bits [25] = MEMORY [74][1];
                      rtc_match_reg_bits [26] = MEMORY [74][2];
                      rtc_match_reg_bits [27] = MEMORY [74][3];
                      rtc_match_reg_bits [28] = MEMORY [74][4];
                      rtc_match_reg_bits [29] = MEMORY [74][5];
                      rtc_match_reg_bits [30] = MEMORY [74][6];
                      rtc_match_reg_bits [31] = MEMORY [74][7];
                    end
                end
            8'b01001100 : 
                begin
                  MEMORY [75][0] = ACMWDATA_ipd [0]; 
                  MEMORY [75][1] = ACMWDATA_ipd [1];
                  MEMORY [75][2] = ACMWDATA_ipd [2];
                  MEMORY [75][3] = ACMWDATA_ipd [3];
                  MEMORY [75][4] = ACMWDATA_ipd [4];
                  MEMORY [75][5] = ACMWDATA_ipd [5];
                  MEMORY [75][6] = ACMWDATA_ipd [6];
                  MEMORY [75][7] = ACMWDATA_ipd [7];
                  if ( rtm_rst == 1'b0 ) 
                    begin
                      rtc_match_reg_bits [32] = MEMORY [75][0];
                      rtc_match_reg_bits [33] = MEMORY [75][1];
                      rtc_match_reg_bits [34] = MEMORY [75][2];
                      rtc_match_reg_bits [35] = MEMORY [75][3];
                      rtc_match_reg_bits [36] = MEMORY [75][4];
                      rtc_match_reg_bits [37] = MEMORY [75][5];
                      rtc_match_reg_bits [38] = MEMORY [75][6];
                      rtc_match_reg_bits [39] = MEMORY [75][7];
                    end
                end
            8'b01011000 : 
                begin
                  MEMORY [87][0] = ACMWDATA_ipd [0]; 
                  MEMORY [87][1] = ACMWDATA_ipd [1];
                  MEMORY [87][2] = ACMWDATA_ipd [2];
                  MEMORY [87][3] = ACMWDATA_ipd [3];
                  MEMORY [87][4] = ACMWDATA_ipd [4];
                  MEMORY [87][5] = ACMWDATA_ipd [5];
                  MEMORY [87][6] = ACMWDATA_ipd [6];
                  MEMORY [87][7] = ACMWDATA_ipd [7];
                end
            8'b01010000 :
              if ( WARNING_MSGS_ON ) 
                $display ( "Warning : The match bits are read-only, at time %0.1f\n", $realtime);
            8'b01010001 :
              if ( WARNING_MSGS_ON )
                $display ( "Warning : The match bits are read-only, at time %0.1f\n", $realtime);
            8'b01010010 :
              if ( WARNING_MSGS_ON )
                $display ( "Warning : The match bits are read-only, at time %0.1f\n", $realtime);
            8'b01010011 :
              if ( WARNING_MSGS_ON )
                $display ( "Warning : The match bits are read-only, at time %0.1f\n", $realtime);
            8'b01010100 :
              if ( WARNING_MSGS_ON )
                $display ( "Warning : The match bits are read-only, at time %0.1f\n", $realtime);
            default     : ;
          endcase
        end


   /* -- RTC reset -- */

   if ( rtm_rst == 1'b1 )
     begin
       for ( q = 63; q <= 84; q = q+1)
         begin
           MEMORY[q] = 8'b00000000;
         end
       prescaler_xtl_count = 0;
       rtc_counter_bits    = 40'b0000000000000000000000000000000000000000;
       rtc_match_reg_bits  = 40'b0000000000000000000000000000000000000000;
       capture_reg         = 40'b0000000000000000000000000000000000000000;
     end


   /* -- Counter reset -- */

   if ( rstb_cnt == 1'b0 ) 
     begin
       prescaler_xtl_count = 0;
       rtc_counter_bits    = 40'b0000000000000000000000000000000000000000;
     end


   /* -- Prescaler Clock -- */
   /* -- RTC Counter     -- */

   if ( RTCCLK_event && RTCCLK_ipd == 1'b1 ) 
     begin
       prescaler_xtl_count = prescaler_xtl_count + 1;
       if ( prescaler_xtl_count == 64 )
         begin
           prescaler_clk = 1'b1;
           if ( rtm_rst == 1'b0 && cntr_en == 1'b1 )
             begin
               if ( RTCMATCH && rst_cnt_on_match )
                 rtc_counter_bits = 40'b0000000000000000000000000000000000000000;
               else if ( rstb_cnt )
                // counter increment
                rtc_counter_bits = rtc_counter_bits + 1;
             end
         end
       else if ( prescaler_xtl_count % 64 == 0) 
         begin
           prescaler_clk = !prescaler_clk;
           if ( prescaler_clk == 1'b1 )
             begin
               if ( rtm_rst == 1'b0 && cntr_en == 1'b1 )
                 begin
                   if ( RTCMATCH && rst_cnt_on_match )
                     rtc_counter_bits = 40'b0000000000000000000000000000000000000000;
                   else if ( rstb_cnt )
                    // counter increment
                    rtc_counter_bits = rtc_counter_bits + 1;
                 end
             end
         end
       else if ( cntr_en == 1'b0 ) 
       // Counter is disabled (but not reset). Prescaler is reset.
           prescaler_xtl_count = 0;
     end


    /* -- Read CTRL_STAT, COUNTER, MATCHREG and MATCHBITS bytes -- */

    if ( ACMCLK_event && ACMCLK_ipd == 1'b1 ) 
      begin
        if ( ACMADDR_ipd == 8'b01011000 && ACMWEN_ipd == 1'b0 ) 
          read_ctrl_stat_reg = !read_ctrl_stat_reg;

        else if ( rtm_rst == 1'b0 && ACMWEN_ipd == 1'b0 )

          begin

            case ( ACMADDR_ipd )

            8'b01000000 :
            if ( rstb_cnt == 1'b1 )
              read_rtc_counter_byte0 = !read_rtc_counter_byte0;

            8'b01000001 : 
            if ( rstb_cnt == 1'b1 )
              read_rtc_counter_byte1 = !read_rtc_counter_byte1;

            8'b01000010 : 
            if ( rstb_cnt == 1'b1 )
              read_rtc_counter_byte2 = !read_rtc_counter_byte2;

            8'b01000011 : 
            if ( rstb_cnt == 1'b1 )
              read_rtc_counter_byte3 = !read_rtc_counter_byte3;

            8'b01000100 : 
            if ( rstb_cnt == 1'b1 )
              read_rtc_counter_byte4 = !read_rtc_counter_byte4;

            8'b01001000 : 
              read_match_reg_byte0 = !read_match_reg_byte0;

            8'b01001001 : 
              read_match_reg_byte1 = !read_match_reg_byte1;
       
            8'b01001010 : 
              read_match_reg_byte2 = !read_match_reg_byte2;
       
            8'b01001011 : 
              read_match_reg_byte3 = !read_match_reg_byte3;
       
            8'b01001100 : 
              read_match_reg_byte4 = !read_match_reg_byte4;

            8'b01010000 : 
            if ( rstb_cnt == 1'b1 )
              read_ind_match_byte0 = !read_ind_match_byte0;

            8'b01010001 : 
            if ( rstb_cnt == 1'b1 )
              read_ind_match_byte1 = !read_ind_match_byte1;
          
            8'b01010010 : 
            if ( rstb_cnt == 1'b1 )
              read_ind_match_byte2 = !read_ind_match_byte2;

            8'b01010011 : 
            if ( rstb_cnt == 1'b1 )
              read_ind_match_byte3 = !read_ind_match_byte3;

            8'b01010100 : 
            if ( rstb_cnt == 1'b1 )
              read_ind_match_byte4 = !read_ind_match_byte4;

            default     : ;

          endcase

        end

      end

      RTCCLK_prev        = RTCCLK_ipd;
      ACMCLK_prev        = ACMCLK_ipd;

      INIT_MEM_prev      = INIT_MEM;
      ACMCLK_mem_prev    = ACMCLK_ipd;
      reset_memory_prev  = reset_memory;

    end // always @ ( INIT_MEM, reset_memory,  write_acm_aq_wdata_to_memory, ACMCLK_ipd )


  // "Deserialize" / Read analog inputs for all quads
    
  read_analog_io read_analog_input_VAREF    ( VAREF_in , !VAREFSEL_ipd, VA_REF_VECTOR  );
  read_analog_io read_analog_input_GNDREF   ( GNDREF   , 1'b0   , GND_REF_VECTOR );
  read_analog_io read_analog_input_AV0      ( AV0   , DENAV0_ipd, AV0_VECTOR     );
  read_analog_io read_analog_input_AC0      ( AC0   , DENAC0_ipd, AC0_VECTOR     );
  read_analog_io read_analog_input_AT0      ( AT0   , DENAT0_ipd, AT0_VECTOR     );
  read_analog_io read_analog_input_AV1      ( AV1   , DENAV1_ipd, AV1_VECTOR     );
  read_analog_io read_analog_input_AC1      ( AC1   , DENAC1_ipd, AC1_VECTOR     );
  read_analog_io read_analog_input_AT1      ( AT1   , DENAT1_ipd, AT1_VECTOR     );
  read_analog_io read_analog_input_AV2      ( AV2   , DENAV2_ipd, AV2_VECTOR     );
  read_analog_io read_analog_input_AC2      ( AC2   , DENAC2_ipd, AC2_VECTOR     );
  read_analog_io read_analog_input_AT2      ( AT2   , DENAT2_ipd, AT2_VECTOR     );
  read_analog_io read_analog_input_AV3      ( AV3   , DENAV3_ipd, AV3_VECTOR     );
  read_analog_io read_analog_input_AC3      ( AC3   , DENAC3_ipd, AC3_VECTOR     );
  read_analog_io read_analog_input_AT3      ( AT3   , DENAT3_ipd, AT3_VECTOR     );
  read_analog_io read_analog_input_AV4      ( AV4   , DENAV4_ipd, AV4_VECTOR     );
  read_analog_io read_analog_input_AC4      ( AC4   , DENAC4_ipd, AC4_VECTOR     );
  read_analog_io read_analog_input_AT4      ( AT4   , DENAT4_ipd, AT4_VECTOR     );
  read_analog_io read_analog_input_AV5      ( AV5   , DENAV5_ipd, AV5_VECTOR     );
  read_analog_io read_analog_input_AC5      ( AC5   , DENAC5_ipd, AC5_VECTOR     );
  read_analog_io read_analog_input_AT5      ( AT5   , DENAT5_ipd, AT5_VECTOR     );
  read_analog_io read_analog_input_AV6      ( AV6   , DENAV6_ipd, AV6_VECTOR     );
  read_analog_io read_analog_input_AC6      ( AC6   , DENAC6_ipd, AC6_VECTOR     );
  read_analog_io read_analog_input_AT6      ( AT6   , DENAT6_ipd, AT6_VECTOR     );
  read_analog_io read_analog_input_AV7      ( AV7   , DENAV7_ipd, AV7_VECTOR     );
  read_analog_io read_analog_input_AC7      ( AC7   , DENAC7_ipd, AC7_VECTOR     );
  read_analog_io read_analog_input_AT7      ( AT7   , DENAT7_ipd, AT7_VECTOR     );
  read_analog_io read_analog_input_AV8      ( AV8   , DENAV8_ipd, AV8_VECTOR     );
  read_analog_io read_analog_input_AC8      ( AC8   , DENAC8_ipd, AC8_VECTOR     );
  read_analog_io read_analog_input_AT8      ( AT8   , DENAT8_ipd, AT8_VECTOR     );
  read_analog_io read_analog_input_AV9      ( AV9   , DENAV9_ipd, AV9_VECTOR     );
  read_analog_io read_analog_input_AC9      ( AC9   , DENAC9_ipd, AC9_VECTOR     );
  read_analog_io read_analog_input_AT9      ( AT9   , DENAT9_ipd, AT9_VECTOR     );

  drive_varef_out drive_analog_output_VAREF ( $realtobits(va_ref_i), !VAREFSEL_ipd, VAREF_out );

  always @ ( VA_REF_VECTOR  ) va_ref_ext   <= $bitstoreal ( VA_REF_VECTOR  );

  always @ ( GND_REF_VECTOR ) gnd_ref_real <= $bitstoreal ( GND_REF_VECTOR );

  always @ ( VAREFSEL_ipd, va_ref_ext )
    begin
      if ( VAREFSEL_ipd == 1'b1 )
        va_ref_real <= va_ref_ext;
      else
        va_ref_real <= va_ref_i;
    end


  // All Analog Quads

  // AV/AC/AT pad settings are defined by contents of ACM memory address 0 to 39

  // bit 7 is the prescale enable for AV, AC and AT pads

  assign v_prescale_enable0   = MEMORY [ 0][7];
  assign v_prescale_enable1   = MEMORY [ 4][7];
  assign v_prescale_enable2   = MEMORY [ 8][7];
  assign v_prescale_enable3   = MEMORY [12][7];
  assign v_prescale_enable4   = MEMORY [16][7];
  assign v_prescale_enable5   = MEMORY [20][7];
  assign v_prescale_enable6   = MEMORY [24][7];
  assign v_prescale_enable7   = MEMORY [28][7];
  assign v_prescale_enable8   = MEMORY [32][7];
  assign v_prescale_enable9   = MEMORY [36][7];

  assign c_prescale_enable0   = MEMORY [ 1][7];
  assign c_prescale_enable1   = MEMORY [ 5][7];
  assign c_prescale_enable2   = MEMORY [ 9][7];
  assign c_prescale_enable3   = MEMORY [13][7];
  assign c_prescale_enable4   = MEMORY [17][7];
  assign c_prescale_enable5   = MEMORY [21][7];
  assign c_prescale_enable6   = MEMORY [25][7];
  assign c_prescale_enable7   = MEMORY [29][7];
  assign c_prescale_enable8   = MEMORY [33][7];
  assign c_prescale_enable9   = MEMORY [37][7];

  assign t_prescale_enable0   = MEMORY [ 3][7];
  assign t_prescale_enable1   = MEMORY [ 7][7];
  assign t_prescale_enable2   = MEMORY [11][7];
  assign t_prescale_enable3   = MEMORY [15][7];
  assign t_prescale_enable4   = MEMORY [19][7];
  assign t_prescale_enable5   = MEMORY [23][7];
  assign t_prescale_enable6   = MEMORY [27][7];
  assign t_prescale_enable7   = MEMORY [31][7];
  assign t_prescale_enable8   = MEMORY [35][7];
  assign t_prescale_enable9   = MEMORY [39][7];

  // bit 6 is the polarity selection for AV, AC and AT pads

  assign volt_polarity0       = MEMORY [ 0][6];
  assign volt_polarity1       = MEMORY [ 4][6];
  assign volt_polarity2       = MEMORY [ 8][6];
  assign volt_polarity3       = MEMORY [12][6];
  assign volt_polarity4       = MEMORY [16][6];
  assign volt_polarity5       = MEMORY [20][6];
  assign volt_polarity6       = MEMORY [24][6];
  assign volt_polarity7       = MEMORY [28][6];
  assign volt_polarity8       = MEMORY [32][6];
  assign volt_polarity9       = MEMORY [36][6];

  assign curr_polarity0       = MEMORY [ 1][6];
  assign curr_polarity1       = MEMORY [ 5][6];
  assign curr_polarity2       = MEMORY [ 9][6];
  assign curr_polarity3       = MEMORY [13][6];
  assign curr_polarity4       = MEMORY [17][6];
  assign curr_polarity5       = MEMORY [21][6];
  assign curr_polarity6       = MEMORY [25][6];
  assign curr_polarity7       = MEMORY [29][6];
  assign curr_polarity8       = MEMORY [33][6];
  assign curr_polarity9       = MEMORY [37][6];

  assign temp_polarity0       = MEMORY [ 3][6];
  assign temp_polarity1       = MEMORY [ 7][6];
  assign temp_polarity2       = MEMORY [11][6];
  assign temp_polarity3       = MEMORY [15][6];
  assign temp_polarity4       = MEMORY [19][6];
  assign temp_polarity5       = MEMORY [23][6];
  assign temp_polarity6       = MEMORY [27][6];
  assign temp_polarity7       = MEMORY [31][6];
  assign temp_polarity8       = MEMORY [35][6];
  assign temp_polarity9       = MEMORY [39][6];

  // bit 5 is the direct analog input select for AV, AC and AT pads

  assign v_direct_switch0     = MEMORY [ 0][5];
  assign v_direct_switch1     = MEMORY [ 4][5];
  assign v_direct_switch2     = MEMORY [ 8][5];
  assign v_direct_switch3     = MEMORY [12][5];
  assign v_direct_switch4     = MEMORY [16][5];
  assign v_direct_switch5     = MEMORY [20][5];
  assign v_direct_switch6     = MEMORY [24][5];
  assign v_direct_switch7     = MEMORY [28][5];
  assign v_direct_switch8     = MEMORY [32][5];
  assign v_direct_switch9     = MEMORY [36][5];

  assign c_direct_switch0     = MEMORY [ 1][5];
  assign c_direct_switch1     = MEMORY [ 5][5];
  assign c_direct_switch2     = MEMORY [ 9][5];
  assign c_direct_switch3     = MEMORY [13][5];
  assign c_direct_switch4     = MEMORY [17][5];
  assign c_direct_switch5     = MEMORY [21][5];
  assign c_direct_switch6     = MEMORY [25][5];
  assign c_direct_switch7     = MEMORY [29][5];
  assign c_direct_switch8     = MEMORY [33][5];
  assign c_direct_switch9     = MEMORY [37][5];

  assign t_direct_switch0     = MEMORY [ 3][5];
  assign t_direct_switch1     = MEMORY [ 7][5];
  assign t_direct_switch2     = MEMORY [11][5];
  assign t_direct_switch3     = MEMORY [15][5];
  assign t_direct_switch4     = MEMORY [19][5];
  assign t_direct_switch5     = MEMORY [23][5];
  assign t_direct_switch6     = MEMORY [27][5];
  assign t_direct_switch7     = MEMORY [31][5];
  assign t_direct_switch8     = MEMORY [35][5];
  assign t_direct_switch9     = MEMORY [39][5];

  // bit 4 for AV is the current monitor switch; bit 3 is the analog mux select
  // bits 4:3 are the analog mux select for AC and AT

  assign curr_monitor_switch0 = MEMORY [ 0][4];
  assign curr_monitor_switch1 = MEMORY [ 4][4];
  assign curr_monitor_switch2 = MEMORY [ 8][4];
  assign curr_monitor_switch3 = MEMORY [12][4];
  assign curr_monitor_switch4 = MEMORY [16][4];
  assign curr_monitor_switch5 = MEMORY [20][4];
  assign curr_monitor_switch6 = MEMORY [24][4];
  assign curr_monitor_switch7 = MEMORY [28][4];
  assign curr_monitor_switch8 = MEMORY [32][4];
  assign curr_monitor_switch9 = MEMORY [36][4];

  assign v_mux_select0        = MEMORY [ 0][3];
  assign v_mux_select1        = MEMORY [ 4][3];
  assign v_mux_select2        = MEMORY [ 8][3];
  assign v_mux_select3        = MEMORY [12][3];
  assign v_mux_select4        = MEMORY [16][3];
  assign v_mux_select5        = MEMORY [20][3];
  assign v_mux_select6        = MEMORY [24][3];
  assign v_mux_select7        = MEMORY [28][3];
  assign v_mux_select8        = MEMORY [32][3];
  assign v_mux_select9        = MEMORY [36][3];

  assign c_mux_select0        = MEMORY [ 1][4:3];
  assign c_mux_select1        = MEMORY [ 5][4:3];
  assign c_mux_select2        = MEMORY [ 9][4:3];
  assign c_mux_select3        = MEMORY [13][4:3];
  assign c_mux_select4        = MEMORY [17][4:3];
  assign c_mux_select5        = MEMORY [21][4:3];
  assign c_mux_select6        = MEMORY [25][4:3];
  assign c_mux_select7        = MEMORY [29][4:3];
  assign c_mux_select8        = MEMORY [33][4:3];
  assign c_mux_select9        = MEMORY [37][4:3];

  assign t_mux_select0        = MEMORY [ 3][4:3];
  assign t_mux_select1        = MEMORY [ 7][4:3];
  assign t_mux_select2        = MEMORY [11][4:3];
  assign t_mux_select3        = MEMORY [15][4:3];
  assign t_mux_select4        = MEMORY [19][4:3];
  assign t_mux_select5        = MEMORY [23][4:3];
  assign t_mux_select6        = MEMORY [27][4:3];
  assign t_mux_select7        = MEMORY [31][4:3];
  assign t_mux_select8        = MEMORY [35][4:3];
  assign t_mux_select9        = MEMORY [39][4:3];

  // bits 2:0 are the prescaler scaling factor for AV, AC and AT pads

  assign v_prescale_select0   = MEMORY [ 0][2:0];
  assign v_prescale_select1   = MEMORY [ 4][2:0];
  assign v_prescale_select2   = MEMORY [ 8][2:0];
  assign v_prescale_select3   = MEMORY [12][2:0];
  assign v_prescale_select4   = MEMORY [16][2:0];
  assign v_prescale_select5   = MEMORY [20][2:0];
  assign v_prescale_select6   = MEMORY [24][2:0];
  assign v_prescale_select7   = MEMORY [28][2:0];
  assign v_prescale_select8   = MEMORY [32][2:0];
  assign v_prescale_select9   = MEMORY [36][2:0];

  assign c_prescale_select0   = MEMORY [ 1][2:0];
  assign c_prescale_select1   = MEMORY [ 5][2:0];
  assign c_prescale_select2   = MEMORY [ 9][2:0];
  assign c_prescale_select3   = MEMORY [13][2:0];
  assign c_prescale_select4   = MEMORY [17][2:0];
  assign c_prescale_select5   = MEMORY [21][2:0];
  assign c_prescale_select6   = MEMORY [25][2:0];
  assign c_prescale_select7   = MEMORY [29][2:0];
  assign c_prescale_select8   = MEMORY [33][2:0];
  assign c_prescale_select9   = MEMORY [37][2:0];

  assign t_prescale_select0   = MEMORY [ 3][2:0];
  assign t_prescale_select1   = MEMORY [ 7][2:0];
  assign t_prescale_select2   = MEMORY [11][2:0];
  assign t_prescale_select3   = MEMORY [15][2:0];
  assign t_prescale_select4   = MEMORY [19][2:0];
  assign t_prescale_select5   = MEMORY [23][2:0];
  assign t_prescale_select6   = MEMORY [27][2:0];
  assign t_prescale_select7   = MEMORY [31][2:0];
  assign t_prescale_select8   = MEMORY [35][2:0];
  assign t_prescale_select9   = MEMORY [39][2:0];


  // calculate prescaled analog inputs based on prescaler settings for all of AV, AC and AT pads

  assign vin_quad_prescaled0 = generate_quad_prescaled ( "AV", 0, AV0_VECTOR, volt_polarity0, v_prescale_enable0, v_prescale_select0, $realtobits(va_ref_real) );
  
  assign cin_quad_prescaled0 = generate_quad_prescaled ( "AC", 0, AC0_VECTOR, curr_polarity0, c_prescale_enable0, c_prescale_select0, $realtobits(va_ref_real) );
  
  assign tin_quad_prescaled0 = generate_tin_quad_prescaled ( 0, AT0_VECTOR, temp_polarity0, t_prescale_enable0, t_prescale_select0, $realtobits(va_ref_real) );
  
  assign vin_quad_prescaled1 = generate_quad_prescaled ( "AV", 1, AV1_VECTOR, volt_polarity1, v_prescale_enable1, v_prescale_select1, $realtobits(va_ref_real) );
  
  assign cin_quad_prescaled1 = generate_quad_prescaled ( "AC", 1, AC1_VECTOR, curr_polarity1, c_prescale_enable1, c_prescale_select1, $realtobits(va_ref_real) );
  
  assign tin_quad_prescaled1 = generate_tin_quad_prescaled ( 1, AT1_VECTOR, temp_polarity1, t_prescale_enable1, t_prescale_select1, $realtobits(va_ref_real) );
  
  assign vin_quad_prescaled2 = generate_quad_prescaled ( "AV", 2, AV2_VECTOR, volt_polarity2, v_prescale_enable2, v_prescale_select2, $realtobits(va_ref_real) );
  
  assign cin_quad_prescaled2 = generate_quad_prescaled ( "AC", 2, AC2_VECTOR, curr_polarity2, c_prescale_enable2, c_prescale_select2, $realtobits(va_ref_real) );
  
  assign tin_quad_prescaled2 = generate_tin_quad_prescaled ( 2, AT2_VECTOR, temp_polarity2, t_prescale_enable2, t_prescale_select2, $realtobits(va_ref_real) );
  
  assign vin_quad_prescaled3 = generate_quad_prescaled ( "AV", 3, AV3_VECTOR, volt_polarity3, v_prescale_enable3, v_prescale_select3, $realtobits(va_ref_real) );
  
  assign cin_quad_prescaled3 = generate_quad_prescaled ( "AC", 3, AC3_VECTOR, curr_polarity3, c_prescale_enable3, c_prescale_select3, $realtobits(va_ref_real) );
  
  assign tin_quad_prescaled3 = generate_tin_quad_prescaled ( 3, AT3_VECTOR, temp_polarity3, t_prescale_enable3, t_prescale_select3, $realtobits(va_ref_real) );
  
  assign vin_quad_prescaled4 = generate_quad_prescaled ( "AV", 4, AV4_VECTOR, volt_polarity4, v_prescale_enable4, v_prescale_select4, $realtobits(va_ref_real) );
  
  assign cin_quad_prescaled4 = generate_quad_prescaled ( "AC", 4, AC4_VECTOR, curr_polarity4, c_prescale_enable4, c_prescale_select4, $realtobits(va_ref_real) );
  
  assign tin_quad_prescaled4 = generate_tin_quad_prescaled ( 4, AT4_VECTOR, temp_polarity4, t_prescale_enable4, t_prescale_select4, $realtobits(va_ref_real) );
  
  assign vin_quad_prescaled5 = generate_quad_prescaled ( "AV", 5, AV5_VECTOR, volt_polarity5, v_prescale_enable5, v_prescale_select5, $realtobits(va_ref_real) );
  
  assign cin_quad_prescaled5 = generate_quad_prescaled ( "AC", 5, AC5_VECTOR, curr_polarity5, c_prescale_enable5, c_prescale_select5, $realtobits(va_ref_real) );
  
  assign tin_quad_prescaled5 = generate_tin_quad_prescaled ( 5, AT5_VECTOR, temp_polarity5, t_prescale_enable5, t_prescale_select5, $realtobits(va_ref_real) );
  
  assign vin_quad_prescaled6 = generate_quad_prescaled ( "AV", 6, AV6_VECTOR, volt_polarity6, v_prescale_enable6, v_prescale_select6, $realtobits(va_ref_real) );
  
  assign cin_quad_prescaled6 = generate_quad_prescaled ( "AC", 6, AC6_VECTOR, curr_polarity6, c_prescale_enable6, c_prescale_select6, $realtobits(va_ref_real) );
  
  assign tin_quad_prescaled6 = generate_tin_quad_prescaled ( 6, AT6_VECTOR, temp_polarity6, t_prescale_enable6, t_prescale_select6, $realtobits(va_ref_real) );
  
  assign vin_quad_prescaled7 = generate_quad_prescaled ( "AV", 7, AV7_VECTOR, volt_polarity7, v_prescale_enable7, v_prescale_select7, $realtobits(va_ref_real) );
  
  assign cin_quad_prescaled7 = generate_quad_prescaled ( "AC", 7, AC7_VECTOR, curr_polarity7, c_prescale_enable7, c_prescale_select7, $realtobits(va_ref_real) );
  
  assign tin_quad_prescaled7 = generate_tin_quad_prescaled ( 7, AT7_VECTOR, temp_polarity7, t_prescale_enable7, t_prescale_select7, $realtobits(va_ref_real) );
  
  assign vin_quad_prescaled8 = generate_quad_prescaled ( "AV", 8, AV8_VECTOR, volt_polarity8, v_prescale_enable8, v_prescale_select8, $realtobits(va_ref_real) );
  
  assign cin_quad_prescaled8 = generate_quad_prescaled ( "AC", 8, AC8_VECTOR, curr_polarity8, c_prescale_enable8, c_prescale_select8, $realtobits(va_ref_real) );
  
  assign tin_quad_prescaled8 = generate_tin_quad_prescaled ( 8, AT8_VECTOR, temp_polarity8, t_prescale_enable8, t_prescale_select8, $realtobits(va_ref_real) );
  
  assign vin_quad_prescaled9 = generate_quad_prescaled ( "AV", 9, AV9_VECTOR, volt_polarity9, v_prescale_enable9, v_prescale_select9, $realtobits(va_ref_real) );
  
  assign cin_quad_prescaled9 = generate_quad_prescaled ( "AC", 9, AC9_VECTOR, curr_polarity9, c_prescale_enable9, c_prescale_select9, $realtobits(va_ref_real) );
  
  assign tin_quad_prescaled9 = generate_tin_quad_prescaled ( 9, AT9_VECTOR, temp_polarity9, t_prescale_enable9, t_prescale_select9, $realtobits(va_ref_real) );
  
  // calculate current monitor output for all AV/AC pads

  assign curr_monitor0 = curr_monitor_fct ( 0, AC0_VECTOR, curr_polarity0, AV0_VECTOR, volt_polarity0, CMSTB0_ipd, curr_monitor_switch0, $realtobits(va_ref_real) );

  assign curr_monitor1 = curr_monitor_fct ( 1, AC1_VECTOR, curr_polarity1, AV1_VECTOR, volt_polarity1, CMSTB1_ipd, curr_monitor_switch1, $realtobits(va_ref_real) );

  assign curr_monitor2 = curr_monitor_fct ( 2, AC2_VECTOR, curr_polarity2, AV2_VECTOR, volt_polarity2, CMSTB2_ipd, curr_monitor_switch2, $realtobits(va_ref_real) );

  assign curr_monitor3 = curr_monitor_fct ( 3, AC3_VECTOR, curr_polarity3, AV3_VECTOR, volt_polarity3, CMSTB3_ipd, curr_monitor_switch3, $realtobits(va_ref_real) );

  assign curr_monitor4 = curr_monitor_fct ( 4, AC4_VECTOR, curr_polarity4, AV4_VECTOR, volt_polarity4, CMSTB4_ipd, curr_monitor_switch4, $realtobits(va_ref_real) );

  assign curr_monitor5 = curr_monitor_fct ( 5, AC5_VECTOR, curr_polarity5, AV5_VECTOR, volt_polarity5, CMSTB5_ipd, curr_monitor_switch5, $realtobits(va_ref_real) );

  assign curr_monitor6 = curr_monitor_fct ( 6, AC6_VECTOR, curr_polarity6, AV6_VECTOR, volt_polarity6, CMSTB6_ipd, curr_monitor_switch6, $realtobits(va_ref_real) );

  assign curr_monitor7 = curr_monitor_fct ( 7, AC7_VECTOR, curr_polarity7, AV7_VECTOR, volt_polarity7, CMSTB7_ipd, curr_monitor_switch7, $realtobits(va_ref_real) );

  assign curr_monitor8 = curr_monitor_fct ( 8, AC8_VECTOR, curr_polarity8, AV8_VECTOR, volt_polarity8, CMSTB8_ipd, curr_monitor_switch8, $realtobits(va_ref_real) );

  assign curr_monitor9 = curr_monitor_fct ( 9, AC9_VECTOR, curr_polarity9, AV9_VECTOR, volt_polarity9, CMSTB9_ipd, curr_monitor_switch9, $realtobits(va_ref_real) );

  // calculate temperature monitor output for all AT pads

  assign temp_monitor0 = temp_monitor_fct ( 0, AT0_VECTOR, temp_polarity0, TMSTB0_ipd, $realtobits(va_ref_real) );
  assign temp_monitor1 = temp_monitor_fct ( 1, AT1_VECTOR, temp_polarity1, TMSTB1_ipd, $realtobits(va_ref_real) );
  assign temp_monitor2 = temp_monitor_fct ( 2, AT2_VECTOR, temp_polarity2, TMSTB2_ipd, $realtobits(va_ref_real) );
  assign temp_monitor3 = temp_monitor_fct ( 3, AT3_VECTOR, temp_polarity3, TMSTB3_ipd, $realtobits(va_ref_real) );
  assign temp_monitor4 = temp_monitor_fct ( 4, AT4_VECTOR, temp_polarity4, TMSTB4_ipd, $realtobits(va_ref_real) );
  assign temp_monitor5 = temp_monitor_fct ( 5, AT5_VECTOR, temp_polarity5, TMSTB5_ipd, $realtobits(va_ref_real) );
  assign temp_monitor6 = temp_monitor_fct ( 6, AT6_VECTOR, temp_polarity6, TMSTB6_ipd, $realtobits(va_ref_real) );
  assign temp_monitor7 = temp_monitor_fct ( 7, AT7_VECTOR, temp_polarity7, TMSTB7_ipd, $realtobits(va_ref_real) );
  assign temp_monitor8 = temp_monitor_fct ( 8, AT8_VECTOR, temp_polarity8, TMSTB8_ipd, $realtobits(va_ref_real) );
  assign temp_monitor9 = temp_monitor_fct ( 9, AT9_VECTOR, temp_polarity9, TMSTB9_ipd, $realtobits(va_ref_real) );

  // outputs to analog mux based on pad configuration

  assign v_muxout0 = v_muxout_fct ( 0, v_mux_select0, v_direct_switch0, v_prescale_enable0, vin_quad_prescaled0, v_prescale_select0, AV0_VECTOR, curr_monitor_switch0 );

  assign c_muxout0 = c_muxout_fct ( 0, c_mux_select0, c_direct_switch0, c_prescale_enable0, curr_monitor_switch0, v_direct_switch0, cin_quad_prescaled0, c_prescale_select0, AC0_VECTOR, AV0_VECTOR, $realtobits(va_ref_real), curr_monitor0 ); 

  assign t_muxout0 = t_muxout_fct ( 0, t_mux_select0, t_direct_switch0, t_prescale_enable0, tin_quad_prescaled0, AT0_VECTOR, temp_monitor0 );

  assign v_muxout1 = v_muxout_fct ( 1, v_mux_select1, v_direct_switch1, v_prescale_enable1, vin_quad_prescaled1, v_prescale_select1, AV1_VECTOR, curr_monitor_switch1 );

  assign c_muxout1 = c_muxout_fct ( 1, c_mux_select1, c_direct_switch1, c_prescale_enable1, curr_monitor_switch1, v_direct_switch1, cin_quad_prescaled1, c_prescale_select1, AC1_VECTOR, AV1_VECTOR, $realtobits(va_ref_real), curr_monitor1 );

  assign t_muxout1 = t_muxout_fct ( 1, t_mux_select1, t_direct_switch1, t_prescale_enable1, tin_quad_prescaled1, AT1_VECTOR, temp_monitor1 );

  assign v_muxout2 = v_muxout_fct ( 2, v_mux_select2, v_direct_switch2, v_prescale_enable2, vin_quad_prescaled2, v_prescale_select2, AV2_VECTOR, curr_monitor_switch2 );

  assign c_muxout2 = c_muxout_fct ( 2, c_mux_select2, c_direct_switch2, c_prescale_enable2, curr_monitor_switch2, v_direct_switch2, cin_quad_prescaled2, c_prescale_select2, AC2_VECTOR, AV2_VECTOR, $realtobits(va_ref_real), curr_monitor2 );

  assign t_muxout2 = t_muxout_fct ( 2, t_mux_select2, t_direct_switch2, t_prescale_enable2, tin_quad_prescaled2, AT2_VECTOR, temp_monitor2 );

  assign v_muxout3 = v_muxout_fct ( 3, v_mux_select3, v_direct_switch3, v_prescale_enable3, vin_quad_prescaled3, v_prescale_select3, AV3_VECTOR, curr_monitor_switch3 );

  assign c_muxout3 = c_muxout_fct ( 3, c_mux_select3, c_direct_switch3, c_prescale_enable3, curr_monitor_switch3, v_direct_switch3, cin_quad_prescaled3, c_prescale_select3, AC3_VECTOR, AV3_VECTOR, $realtobits(va_ref_real), curr_monitor3 );

  assign t_muxout3 = t_muxout_fct ( 3, t_mux_select3, t_direct_switch3, t_prescale_enable3, tin_quad_prescaled3, AT3_VECTOR, temp_monitor3 );

  assign v_muxout4 = v_muxout_fct ( 4, v_mux_select4, v_direct_switch4, v_prescale_enable4, vin_quad_prescaled4, v_prescale_select4, AV4_VECTOR, curr_monitor_switch4 );

  assign c_muxout4 = c_muxout_fct ( 4, c_mux_select4, c_direct_switch4, c_prescale_enable4, curr_monitor_switch4, v_direct_switch4, cin_quad_prescaled4, c_prescale_select4, AC4_VECTOR, AV4_VECTOR, $realtobits(va_ref_real), curr_monitor4 );

  assign t_muxout4 = t_muxout_fct ( 4, t_mux_select4, t_direct_switch4, t_prescale_enable4, tin_quad_prescaled4, AT4_VECTOR, temp_monitor4 );

  assign v_muxout5 = v_muxout_fct ( 5, v_mux_select5, v_direct_switch5, v_prescale_enable5, vin_quad_prescaled5, v_prescale_select5, AV5_VECTOR, curr_monitor_switch5 );

  assign c_muxout5 = c_muxout_fct ( 5, c_mux_select5, c_direct_switch5, c_prescale_enable5, curr_monitor_switch5, v_direct_switch5, cin_quad_prescaled5, c_prescale_select5, AC5_VECTOR, AV5_VECTOR, $realtobits(va_ref_real), curr_monitor5 );

  assign t_muxout5 = t_muxout_fct ( 5, t_mux_select5, t_direct_switch5, t_prescale_enable5, tin_quad_prescaled5, AT5_VECTOR, temp_monitor5 );

  assign v_muxout6 = v_muxout_fct ( 6, v_mux_select6, v_direct_switch6, v_prescale_enable6, vin_quad_prescaled6, v_prescale_select6, AV6_VECTOR, curr_monitor_switch6 );

  assign c_muxout6 = c_muxout_fct ( 6, c_mux_select6, c_direct_switch6, c_prescale_enable6, curr_monitor_switch6, v_direct_switch6, cin_quad_prescaled6, c_prescale_select6, AC6_VECTOR, AV6_VECTOR, $realtobits(va_ref_real), curr_monitor6 );

  assign t_muxout6 = t_muxout_fct ( 6, t_mux_select6, t_direct_switch6, t_prescale_enable6, tin_quad_prescaled6, AT6_VECTOR, temp_monitor6 );

  assign v_muxout7 = v_muxout_fct ( 7, v_mux_select7, v_direct_switch7, v_prescale_enable7, vin_quad_prescaled7, v_prescale_select7, AV7_VECTOR, curr_monitor_switch7 );

  assign c_muxout7 = c_muxout_fct ( 7, c_mux_select7, c_direct_switch7, c_prescale_enable7, curr_monitor_switch7, v_direct_switch7, cin_quad_prescaled7, c_prescale_select7, AC7_VECTOR, AV7_VECTOR, $realtobits(va_ref_real), curr_monitor7 );

  assign t_muxout7 = t_muxout_fct ( 7, t_mux_select7, t_direct_switch7, t_prescale_enable7, tin_quad_prescaled7, AT7_VECTOR, temp_monitor7 );

  assign v_muxout8 = v_muxout_fct ( 8, v_mux_select8, v_direct_switch8, v_prescale_enable8, vin_quad_prescaled8, v_prescale_select8, AV8_VECTOR, curr_monitor_switch8 );

  assign c_muxout8 = c_muxout_fct ( 8, c_mux_select8, c_direct_switch8, c_prescale_enable8, curr_monitor_switch8, v_direct_switch8, cin_quad_prescaled8, c_prescale_select8, AC8_VECTOR, AV8_VECTOR, $realtobits(va_ref_real), curr_monitor8 );

  assign t_muxout8 = t_muxout_fct ( 8, t_mux_select8, t_direct_switch8, t_prescale_enable8, tin_quad_prescaled8, AT8_VECTOR, temp_monitor8 );

  assign v_muxout9 = v_muxout_fct ( 9, v_mux_select9, v_direct_switch9, v_prescale_enable9, vin_quad_prescaled9, v_prescale_select9, AV9_VECTOR, curr_monitor_switch9 );

  assign c_muxout9 = c_muxout_fct ( 9, c_mux_select9, c_direct_switch9, c_prescale_enable9, curr_monitor_switch9, v_direct_switch9, cin_quad_prescaled9, c_prescale_select9, AC9_VECTOR, AV9_VECTOR, $realtobits(va_ref_real), curr_monitor9 );

  assign t_muxout9 = t_muxout_fct ( 9, t_mux_select9, t_direct_switch9, t_prescale_enable9, tin_quad_prescaled9, AT9_VECTOR, temp_monitor9 );


  // -- - -- end All Analog Quads -- - --

  //
  // Analog Mux
  //

  always @ ( v_muxout0, v_muxout1, v_muxout2, 
             v_muxout3, v_muxout4, v_muxout5, v_muxout6, 
             v_muxout7, v_muxout8, v_muxout9, c_muxout0, 
             c_muxout1, c_muxout2, c_muxout3, c_muxout4, 
             c_muxout5, c_muxout6, c_muxout7, c_muxout8, 
             c_muxout9, t_muxout0, t_muxout1, t_muxout2, 
             t_muxout3, t_muxout4, t_muxout5, t_muxout6, 
             t_muxout7, t_muxout8, t_muxout9, CHNUMBER_i, 
             va_ref_real, gnd_ref_real
           )
  begin

      case (CHNUMBER_i)
        5'b00000 : MUXOUT = 1.5;
        5'b00001 : MUXOUT = $bitstoreal ( v_muxout0 );
        5'b00010 : MUXOUT = $bitstoreal ( c_muxout0 );
        5'b00011 : MUXOUT = $bitstoreal ( t_muxout0 );
        5'b00100 : MUXOUT = $bitstoreal ( v_muxout1 );
        5'b00101 : MUXOUT = $bitstoreal ( c_muxout1 );
        5'b00110 : MUXOUT = $bitstoreal ( t_muxout1 );
        5'b00111 : MUXOUT = $bitstoreal ( v_muxout2 );
        5'b01000 : MUXOUT = $bitstoreal ( c_muxout2 );
        5'b01001 : MUXOUT = $bitstoreal ( t_muxout2 );
        5'b01010 : MUXOUT = $bitstoreal ( v_muxout3 );
        5'b01011 : MUXOUT = $bitstoreal ( c_muxout3 );
        5'b01100 : MUXOUT = $bitstoreal ( t_muxout3 );
        5'b01101 : MUXOUT = $bitstoreal ( v_muxout4 );
        5'b01110 : MUXOUT = $bitstoreal ( c_muxout4 );
        5'b01111 : MUXOUT = $bitstoreal ( t_muxout4 );
        5'b10000 : MUXOUT = $bitstoreal ( v_muxout5 );
        5'b10001 : MUXOUT = $bitstoreal ( c_muxout5 );
        5'b10010 : MUXOUT = $bitstoreal ( t_muxout5 );
        5'b10011 : MUXOUT = $bitstoreal ( v_muxout6 );
        5'b10100 : MUXOUT = $bitstoreal ( c_muxout6 );
        5'b10101 : MUXOUT = $bitstoreal ( t_muxout6 );
        5'b10110 : MUXOUT = $bitstoreal ( v_muxout7 );
        5'b10111 : MUXOUT = $bitstoreal ( c_muxout7 );
        5'b11000 : MUXOUT = $bitstoreal ( t_muxout7 );
        5'b11001 : MUXOUT = $bitstoreal ( v_muxout8 );
        5'b11010 : MUXOUT = $bitstoreal ( c_muxout8 );
        5'b11011 : MUXOUT = $bitstoreal ( t_muxout8 );
        5'b11100 : MUXOUT = $bitstoreal ( v_muxout9 );
        5'b11101 : MUXOUT = $bitstoreal ( c_muxout9 );
        5'b11110 : MUXOUT = $bitstoreal ( t_muxout9 );
        5'b11111 : MUXOUT = 0.0;
        default  : MUXOUT = 0.0;
      endcase
  end


  //
  // Programmable Clock Divider
  //

  reg ADCRESET_tvc_event, ADCSTART_tvc_event, SYSCLK_tvc_event;

  always @ ( SYSCLK_ipd or ADCRESET_ipd or ADCSTART_ipd )

    begin
      ADCRESET_tvc_event = ADCRESET_ipd !== ADCRESET_tvc_prev;
      ADCSTART_tvc_event = ADCSTART_ipd !== ADCSTART_tvc_prev;
      SYSCLK_tvc_event   = SYSCLK_ipd   !== SYSCLK_tvc_prev;
      
      if ( ( ADCRESET_tvc_event && ( ADCRESET_ipd == 1'b1 ) ) || ( ADCSTART_ipd == 1'b1 && ADCSTART_tvc_event ) )
      	begin
          sysclk_count = 0;
          if ( calibration_started == 0 && busy_int == 0 ) 
            ADC_CLK    = 1'b0;
        end  
      else if ( SYSCLK_tvc_event && ( SYSCLK_ipd == 1'b1 ) )
        begin
          if ( sysclk_count == ( ( TVC_i + 1 ) * 4 ) - 1 )
            begin
	            sysclk_count = 0;
              ADC_CLK      = !ADC_CLK;
	            if ( SYSCLK_previous != 0 )
                SYSCLK_period = $time - SYSCLK_previous;
              SYSCLK_previous = $time;
            end
          else if ( sysclk_count < ( ( ( TVC_i + 1 ) * 4 ) - 1 ) )
	          begin
	            sysclk_count    = sysclk_count + 1;
	            if ( SYSCLK_previous != 0 )
                SYSCLK_period = $time - SYSCLK_previous;
              SYSCLK_previous = $time;
              if ( sysclk_count == ( ( TVC_i + 1 ) * 4 ) / 2 )
                ADC_CLK = !ADC_CLK;
            end
        end

      ADCRESET_tvc_prev = ADCRESET_ipd;
      ADCSTART_tvc_prev = ADCSTART_ipd;
      SYSCLK_tvc_prev   = SYSCLK_ipd;

    end // always @ ( SYSCLK_ipd, ADCRESET_ipd, ADCSTART_ipd )

  //
  // Generate the check signals(only after the 2nd clock cycle).
  //

  always @ ( posedge SYSCLK_ipd or posedge PWRDWN_ipd )
  begin

    if (PWRDWN_ipd == 1'b1)
      sysclk_check <= 1'b0;
    else if (SYSCLK_ipd == 1'b1)
      begin
        check1       <= 1'b1;
        sysclk_check <= check1;
      end

  end // always @ ( SYSCLK_ipd, PWRDWN_ipd )
 

  always @ ( posedge ADC_CLK or posedge PWRDWN_ipd )
  begin

    if (PWRDWN_ipd == 1'b1)
      adcclk_check <= 1'b0;
    else if (ADC_CLK == 1'b1)
      begin
        check2       <= 1'b1;
        adcclk_check <= check2;
      end
  end

  always @ ( TVC_i or SYSCLK_period )
    begin
      ADC_CLK_period <= ((TVC_i + 1) * 4) * SYSCLK_period;
    end

  always @ ( ADC_CLK_period )
    begin
      if ( ( ( (ADC_CLK_period < 100000 ) || ( ADC_CLK_period > 1000000 ) ) && adcclk_check == 1'b1) && ( WARNING_MSGS_ON ) )
        $display ("ADCCLK frequency should be between 1MHz and 10MHz");

    end

  
  //
  // Analog Configuration Mux (ACM)
  // 

  // Registers

  always @ ( ACMCLK_ipd or negedge ACMRESET_ipd )
  begin
    if ( ACMRESET_ipd == 1'b0 )
    begin
      count1          <= 0;
      acm_wen         <= 1'b0;
      aq_byte         <= 40'b0000000000000000000000000000000000000000;
      acm_address_lat <= 8'b00000000;
    end
    else if ( ACMCLK_ipd == 1'b1 )
    begin
`ifdef FUSION_DEBUG
      //$display("FUSION_ACM: clocked in ACMDATA %d, ACMADDR %d, ACMWEN %d, ACMRDATA %d",ACMWDATA_ipd,ACMADDR_ipd,ACMWEN_ipd,ACMRDATA_reg,MEMORY[ACMADDR_ipd]);
`endif
      count1          <= 1;
      aq_wdata        <= ACMWDATA_ipd;
      acm_address_lat <= ACMADDR_ipd;
      acm_wen         <= ACMWEN_ipd;
    end
    else if ( ACMCLK_ipd == 1'b0 ) 
      count1 <= 0;
  end

  // Oscillator

  always
  begin
    osc_clk <= 1'b0;
    #5_000; // 5ns
    osc_clk <= 1'b1;
    #5_000;
  end

  // Timing Generator

  always @ ( osc_clk or negedge ACMRESET_ipd )
  begin
    if ( ACMRESET_ipd == 1'b0 ) 
    begin
      oscp_count <= 0;
      oscn_count <= 0;
      aq_wen     <= 1'b0;
      byte_en    <= 1'b0;
    end
    else if ( osc_clk == 1'b0 )
    begin
      if (ACMRESET_ipd != 0) 
      begin
        if ( count1 != 0 )
        begin
          if ( oscn_count == 0 ) byte_en <= 1'b1;
          else if ( oscn_count >= 2 ) byte_en <= 1'b0;
          oscn_count <= oscn_count + 1;
        end
        else if ( count1 == 0 ) oscn_count <= 0;
      end
    end
    else if ( osc_clk == 1'b1 )
    begin
      if (ACMRESET_ipd !== 1'b0)
      begin
        if ( oscn_count >= 1 ) 
        begin
          if ( oscp_count == 0 ) aq_wen <= acm_wen;
          else if ( oscp_count >= 1 ) aq_wen <= 1'b0;
          oscp_count <= oscp_count + 1;
        end
        else if ( oscn_count == 0 ) oscp_count <= 0;
      end
    end
  end

  // Decoder
  
  always @ ( acm_address_lat or byte_en )
  begin
    if ( byte_en == 1'b0 ) aq_byte <= 40'b0000000000000000000000000000000000000000;
    else if ( byte_en == 1'b1 )
      begin
        case ( acm_address_lat )
          8'b00000000 : aq_byte <= 40'b0000000000000000000000000000000000000000;
          8'b00000001 : aq_byte <= 40'b0000000000000000000000000000000000000001;
          8'b00000010 : aq_byte <= 40'b0000000000000000000000000000000000000010;
          8'b00000011 : aq_byte <= 40'b0000000000000000000000000000000000000100;
          8'b00000100 : aq_byte <= 40'b0000000000000000000000000000000000001000;
          8'b00000101 : aq_byte <= 40'b0000000000000000000000000000000000010000;
          8'b00000110 : aq_byte <= 40'b0000000000000000000000000000000000100000;
          8'b00000111 : aq_byte <= 40'b0000000000000000000000000000000001000000;
          8'b00001000 : aq_byte <= 40'b0000000000000000000000000000000010000000;
          8'b00001001 : aq_byte <= 40'b0000000000000000000000000000000100000000;
          8'b00001010 : aq_byte <= 40'b0000000000000000000000000000001000000000;
          8'b00001011 : aq_byte <= 40'b0000000000000000000000000000010000000000;
          8'b00001100 : aq_byte <= 40'b0000000000000000000000000000100000000000;
          8'b00001101 : aq_byte <= 40'b0000000000000000000000000001000000000000;
          8'b00001110 : aq_byte <= 40'b0000000000000000000000000010000000000000;
          8'b00001111 : aq_byte <= 40'b0000000000000000000000000100000000000000;
          8'b00010000 : aq_byte <= 40'b0000000000000000000000001000000000000000;
          8'b00010001 : aq_byte <= 40'b0000000000000000000000010000000000000000;
          8'b00010010 : aq_byte <= 40'b0000000000000000000000100000000000000000;
          8'b00010011 : aq_byte <= 40'b0000000000000000000001000000000000000000;
          8'b00010100 : aq_byte <= 40'b0000000000000000000010000000000000000000;
          8'b00010101 : aq_byte <= 40'b0000000000000000000100000000000000000000;
          8'b00010110 : aq_byte <= 40'b0000000000000000001000000000000000000000;
          8'b00010111 : aq_byte <= 40'b0000000000000000010000000000000000000000;
          8'b00011000 : aq_byte <= 40'b0000000000000000100000000000000000000000;
          8'b00011001 : aq_byte <= 40'b0000000000000001000000000000000000000000;
          8'b00011010 : aq_byte <= 40'b0000000000000010000000000000000000000000;
          8'b00011011 : aq_byte <= 40'b0000000000000100000000000000000000000000;
          8'b00011100 : aq_byte <= 40'b0000000000001000000000000000000000000000;
          8'b00011101 : aq_byte <= 40'b0000000000010000000000000000000000000000;
          8'b00011110 : aq_byte <= 40'b0000000000100000000000000000000000000000;
          8'b00011111 : aq_byte <= 40'b0000000001000000000000000000000000000000;
          8'b00100000 : aq_byte <= 40'b0000000010000000000000000000000000000000;
          8'b00100001 : aq_byte <= 40'b0000000100000000000000000000000000000000;
          8'b00100010 : aq_byte <= 40'b0000001000000000000000000000000000000000;
          8'b00100011 : aq_byte <= 40'b0000010000000000000000000000000000000000;
          8'b00100100 : aq_byte <= 40'b0000100000000000000000000000000000000000;
          8'b00100101 : aq_byte <= 40'b0001000000000000000000000000000000000000;
          8'b00100110 : aq_byte <= 40'b0010000000000000000000000000000000000000;
          8'b00100111 : aq_byte <= 40'b0100000000000000000000000000000000000000;
          8'b00101000 : aq_byte <= 40'b1000000000000000000000000000000000000000;
          default     : aq_byte <= 40'b0000000000000000000000000000000000000000;
        endcase
			end
      
  end // always @ ( acm_address_lat or byte_en )


  //
  // Analog Quad Configuration Latches
  //

  reg         read_rtc_counter_byte0_event, read_rtc_counter_byte1_event, read_rtc_counter_byte2_event, read_rtc_counter_byte3_event, read_rtc_counter_byte4_event, read_match_reg_byte0_event, read_match_reg_byte1_event, read_match_reg_byte2_event, read_match_reg_byte3_event, read_match_reg_byte4_event, read_ind_match_byte0_event, read_ind_match_byte1_event, read_ind_match_byte2_event, read_ind_match_byte3_event, read_ind_match_byte4_event, read_ctrl_stat_reg_event; 

  always @ ( aq_wen or ACMRESET_ipd or aq_wdata or aq_byte or MEMORY[0] or MEMORY[1] or 
       MEMORY[2] or MEMORY[3] or MEMORY[4] or MEMORY[5] or MEMORY[6] or 
       MEMORY[7] or MEMORY[8] or MEMORY[9] or MEMORY[10] or MEMORY[11] or 
       MEMORY[12] or MEMORY[13] or MEMORY[14] or MEMORY[15] or MEMORY[16] or 
       MEMORY[17] or MEMORY[18] or MEMORY[19] or MEMORY[20] or MEMORY[21] or 
       MEMORY[22] or MEMORY[23] or MEMORY[24] or MEMORY[25] or MEMORY[26] or 
       MEMORY[27] or MEMORY[28] or MEMORY[29] or MEMORY[30] or MEMORY[31] or 
       MEMORY[32] or MEMORY[33] or MEMORY[34] or MEMORY[35] or MEMORY[36] or 
       MEMORY[37] or MEMORY[38] or MEMORY[39] or read_rtc_counter_byte0 or
       read_rtc_counter_byte1 or read_rtc_counter_byte2 or read_rtc_counter_byte3 or
       read_rtc_counter_byte4 or read_match_reg_byte0 or read_match_reg_byte1 or  
       read_match_reg_byte2 or read_match_reg_byte3 or read_match_reg_byte4 or
       read_ind_match_byte0 or read_ind_match_byte1 or read_ind_match_byte2 or
       read_ind_match_byte3 or read_ind_match_byte4 or read_ctrl_stat_reg )

  begin

    read_rtc_counter_byte0_event = ( read_rtc_counter_byte0 !== read_rtc_counter_byte0_prev );
    read_rtc_counter_byte1_event = ( read_rtc_counter_byte1 !== read_rtc_counter_byte1_prev );
    read_rtc_counter_byte2_event = ( read_rtc_counter_byte2 !== read_rtc_counter_byte2_prev );
    read_rtc_counter_byte3_event = ( read_rtc_counter_byte3 !== read_rtc_counter_byte3_prev );
    read_rtc_counter_byte4_event = ( read_rtc_counter_byte4 !== read_rtc_counter_byte4_prev );
    read_match_reg_byte0_event   = ( read_match_reg_byte0   !== read_match_reg_byte0_prev );
    read_match_reg_byte1_event   = ( read_match_reg_byte1   !== read_match_reg_byte1_prev );
    read_match_reg_byte2_event   = ( read_match_reg_byte2   !== read_match_reg_byte2_prev );
    read_match_reg_byte3_event   = ( read_match_reg_byte3   !== read_match_reg_byte3_prev );
    read_match_reg_byte4_event   = ( read_match_reg_byte4   !== read_match_reg_byte4_prev );
    read_ind_match_byte0_event   = ( read_ind_match_byte0   !== read_ind_match_byte0_prev );
    read_ind_match_byte1_event   = ( read_ind_match_byte1   !== read_ind_match_byte1_prev );
    read_ind_match_byte2_event   = ( read_ind_match_byte2   !== read_ind_match_byte2_prev );
    read_ind_match_byte3_event   = ( read_ind_match_byte3   !== read_ind_match_byte3_prev );
    read_ind_match_byte4_event   = ( read_ind_match_byte4   !== read_ind_match_byte4_prev );
    read_ctrl_stat_reg_event     = ( read_ctrl_stat_reg     !== read_ctrl_stat_reg_prev );

    case ( aq_byte )
       40'b0000000000000000000000000000000000000000  : AQ_ACM_ADDR = 8'b00000000;
       40'b0000000000000000000000000000000000000001  : AQ_ACM_ADDR = 8'b00000001;
       40'b0000000000000000000000000000000000000010  : AQ_ACM_ADDR = 8'b00000010;
       40'b0000000000000000000000000000000000000100  : AQ_ACM_ADDR = 8'b00000011;
       40'b0000000000000000000000000000000000001000  : AQ_ACM_ADDR = 8'b00000100;
       40'b0000000000000000000000000000000000010000  : AQ_ACM_ADDR = 8'b00000101;
       40'b0000000000000000000000000000000000100000  : AQ_ACM_ADDR = 8'b00000110;
       40'b0000000000000000000000000000000001000000  : AQ_ACM_ADDR = 8'b00000111;
       40'b0000000000000000000000000000000010000000  : AQ_ACM_ADDR = 8'b00001000;
       40'b0000000000000000000000000000000100000000  : AQ_ACM_ADDR = 8'b00001001;
       40'b0000000000000000000000000000001000000000  : AQ_ACM_ADDR = 8'b00001010;
       40'b0000000000000000000000000000010000000000  : AQ_ACM_ADDR = 8'b00001011;
       40'b0000000000000000000000000000100000000000  : AQ_ACM_ADDR = 8'b00001100;
       40'b0000000000000000000000000001000000000000  : AQ_ACM_ADDR = 8'b00001101;
       40'b0000000000000000000000000010000000000000  : AQ_ACM_ADDR = 8'b00001110;
       40'b0000000000000000000000000100000000000000  : AQ_ACM_ADDR = 8'b00001111;
       40'b0000000000000000000000001000000000000000  : AQ_ACM_ADDR = 8'b00010000;
       40'b0000000000000000000000010000000000000000  : AQ_ACM_ADDR = 8'b00010001;
       40'b0000000000000000000000100000000000000000  : AQ_ACM_ADDR = 8'b00010010;
       40'b0000000000000000000001000000000000000000  : AQ_ACM_ADDR = 8'b00010011;
       40'b0000000000000000000010000000000000000000  : AQ_ACM_ADDR = 8'b00010100;
       40'b0000000000000000000100000000000000000000  : AQ_ACM_ADDR = 8'b00010101;
       40'b0000000000000000001000000000000000000000  : AQ_ACM_ADDR = 8'b00010110;
       40'b0000000000000000010000000000000000000000  : AQ_ACM_ADDR = 8'b00010111;
       40'b0000000000000000100000000000000000000000  : AQ_ACM_ADDR = 8'b00011000;
       40'b0000000000000001000000000000000000000000  : AQ_ACM_ADDR = 8'b00011001;
       40'b0000000000000010000000000000000000000000  : AQ_ACM_ADDR = 8'b00011010;
       40'b0000000000000100000000000000000000000000  : AQ_ACM_ADDR = 8'b00011011;
       40'b0000000000001000000000000000000000000000  : AQ_ACM_ADDR = 8'b00011100;
       40'b0000000000010000000000000000000000000000  : AQ_ACM_ADDR = 8'b00011101;
       40'b0000000000100000000000000000000000000000  : AQ_ACM_ADDR = 8'b00011110;
       40'b0000000001000000000000000000000000000000  : AQ_ACM_ADDR = 8'b00011111;
       40'b0000000010000000000000000000000000000000  : AQ_ACM_ADDR = 8'b00100000;
       40'b0000000100000000000000000000000000000000  : AQ_ACM_ADDR = 8'b00100001;
       40'b0000001000000000000000000000000000000000  : AQ_ACM_ADDR = 8'b00100010;
       40'b0000010000000000000000000000000000000000  : AQ_ACM_ADDR = 8'b00100011;
       40'b0000100000000000000000000000000000000000  : AQ_ACM_ADDR = 8'b00100100;
       40'b0001000000000000000000000000000000000000  : AQ_ACM_ADDR = 8'b00100101;
       40'b0010000000000000000000000000000000000000  : AQ_ACM_ADDR = 8'b00100110;
       40'b0100000000000000000000000000000000000000  : AQ_ACM_ADDR = 8'b00100111;
       40'b1000000000000000000000000000000000000000  : AQ_ACM_ADDR = 8'b00101000;
       default                                       : AQ_ACM_ADDR = 8'b00000000;
    endcase

    if ( ( acm_address_lat > 89 ) && aq_wen == 1'b1 )
      begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Warning : Writing to an illegal address ACMADDR, at time %0.1f\n", $realtime);
      end

    RTC_ADDR = acm_address_lat;

    //  AQ-ACM Read, Write and Reset

    if (ACMRESET_ipd == 1'b0)
      begin
        // reset memory
        reset_memory = !reset_memory;
      end
    else if (ACMRESET === 1'bX) 
      begin
        if ( WARNING_MSGS_ON == 1 ) 
          $display("Warning : ACMRESET is unknown, at time %0.1f\n", $realtime);
      end
    else if ((aq_wen == 1'b1) && (AQ_ACM_ADDR > 0 && AQ_ACM_ADDR <= 40)) 
      begin
        // AQ Write (Note: ACMRDATA is driven with written data)
        write_acm_aq_wdata_to_memory_prev = write_acm_aq_wdata_to_memory;
        write_acm_aq_wdata_to_memory      = !write_acm_aq_wdata_to_memory;
        ACMRDATA_reg [ 7 : 0 ]            = aq_wdata;
      end
    else if ((aq_wen == 1'b0) && (AQ_ACM_ADDR > 0 && AQ_ACM_ADDR <= 40))
      // AQ Read 
      ACMRDATA_reg [ 7 : 0 ] = MEMORY[ ( AQ_ACM_ADDR - 1 ) ];
      if (AQ_ACM_ADDR==30) begin
        $display("HI: AV0 = %x",AV0_VECTOR);
        $display("HI: AC0 = %x",AC0_VECTOR);
        $display("HI: AT0 = %x",AT0_VECTOR);
        $display("HI: AV1 = %x",AV1_VECTOR);
        $display("HI: AC1 = %x",AC1_VECTOR);
        $display("HI: AT1 = %x",AT1_VECTOR);
        $display("HI: AV2 = %x",AV2_VECTOR);
        $display("HI: AC2 = %x",AC2_VECTOR);
        $display("HI: AT2 = %x",AT2_VECTOR);
        $display("HI: AV3 = %x",AV3_VECTOR);
        $display("HI: AC3 = %x",AC3_VECTOR);
        $display("HI: AT3 = %x",AT3_VECTOR);
        $display("HI: AV4 = %x",AV4_VECTOR);
        $display("HI: AC4 = %x",AC4_VECTOR);
        $display("HI: AT4 = %x",AT4_VECTOR);
        $display("HI: AV5 = %x",AV5_VECTOR);
        $display("HI: AC5 = %x",AC5_VECTOR);
        $display("HI: AT5 = %x",AT5_VECTOR);
        $display("HI: AV6 = %x",AV6_VECTOR);
        $display("HI: AC6 = %x",AC6_VECTOR);
        $display("HI: AT6 = %x",AT6_VECTOR);
        $display("HI: AV7 = %x",AV7_VECTOR);
        $display("HI: AC7 = %x",AC7_VECTOR);
        $display("HI: AT7 = %x",AT7_VECTOR);
        $display("HI: AV8 = %x",AV8_VECTOR);
        $display("HI: AC8 = %x",AC8_VECTOR);
        $display("HI: AT8 = %x",AT8_VECTOR);
        $display("HI: AV9 = %x",AV9_VECTOR);
        $display("HI: AC9 = %x",AC9_VECTOR);
        $display("HI: AT9 = %x",AT9_VECTOR);
      end
`ifdef FUSION_DEBUG
      $display("FUSION_ACM: READ - ACMRDATA %d, ACMADDR %d ?= AQ_ACM_ADDR %d",MEMORY[ ( AQ_ACM_ADDR - 1 ) ],ACMADDR,AQ_ACM_ADDR);
`endif       
    // RTC Read
    if ( RTC_ADDR >= 64 && RTC_ADDR <= 89 ) 
      begin
      // Read RTC counter byte
      if ( read_rtc_counter_byte0_event ) 
        begin
            capture_reg  [ 39 : 0 ] = rtc_counter_bits[ 39 : 0 ];
            ACMRDATA_reg [  7 : 0 ] = capture_reg     [  7 : 0 ];
        end
      else if ( read_rtc_counter_byte1_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 15 :  8 ];
        end
      else if ( read_rtc_counter_byte2_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 23 : 16 ];
        end
      else if ( read_rtc_counter_byte3_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 31 : 24 ];
        end
      else if ( read_rtc_counter_byte4_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 39 : 32 ];
        end
      // Read Match Register byte
      else if ( read_match_reg_byte0_event ) 
        begin
            capture_reg  [ 39 : 0 ] = rtc_match_reg_bits[ 39 : 0 ];
            ACMRDATA_reg [  7 : 0 ] = capture_reg       [  7 : 0 ];
        end
      else if ( read_match_reg_byte1_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 15 :  8 ];   
        end
      else if ( read_match_reg_byte2_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 23 : 16 ];   
        end
      else if ( read_match_reg_byte3_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 31 : 24 ];   
        end
      else if ( read_match_reg_byte4_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 39 : 32 ];   
        end
      // Read Individual Match byte
      else if ( read_ind_match_byte0_event ) 
        begin
            capture_reg  [ 39 : 0 ]  = ind_match_bits[ 39 : 0 ];
            ACMRDATA_reg [  7 : 0 ]  = capture_reg   [  7 : 0 ];
        end
      else if ( read_ind_match_byte1_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 15 :  8 ];
        end
      else if ( read_ind_match_byte2_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 23 : 16 ];
        end
      else if ( read_ind_match_byte3_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 31 : 24 ];
        end
      else if ( read_ind_match_byte4_event ) 
        begin
            ACMRDATA_reg [ 7 : 0 ] = capture_reg [ 39 : 32 ];
        end
      // Read CTRL_STAT register 
      else if ( read_ctrl_stat_reg_event ) 
        begin
            ACMRDATA_reg [0] = MEMORY [87][0];
            ACMRDATA_reg [1] = MEMORY [87][1];
            ACMRDATA_reg [2] = MEMORY [87][2];
            ACMRDATA_reg [3] = MEMORY [87][3];
            ACMRDATA_reg [4] = MEMORY [87][4];
            ACMRDATA_reg [5] = MEMORY [87][5];
            ACMRDATA_reg [6] = MEMORY [87][6];
            ACMRDATA_reg [7] = MEMORY [87][7];
        end
      end

    read_rtc_counter_byte0_prev = read_rtc_counter_byte0;
    read_rtc_counter_byte1_prev = read_rtc_counter_byte1;
    read_rtc_counter_byte2_prev = read_rtc_counter_byte2;
    read_rtc_counter_byte3_prev = read_rtc_counter_byte3;
    read_rtc_counter_byte4_prev = read_rtc_counter_byte4;
    read_match_reg_byte0_prev   = read_match_reg_byte0;
    read_match_reg_byte1_prev   = read_match_reg_byte1;
    read_match_reg_byte2_prev   = read_match_reg_byte2;
    read_match_reg_byte3_prev   = read_match_reg_byte3;
    read_match_reg_byte4_prev   = read_match_reg_byte4;
    read_ind_match_byte0_prev   = read_ind_match_byte0;
    read_ind_match_byte1_prev   = read_ind_match_byte1;
    read_ind_match_byte2_prev   = read_ind_match_byte2;
    read_ind_match_byte3_prev   = read_ind_match_byte3;
    read_ind_match_byte4_prev   = read_ind_match_byte4;
    read_ctrl_stat_reg_prev     = read_ctrl_stat_reg;

  end  // always @ ( aq_wen or ACMRESET or aq_wdata or aq_byte or MEMORY[0] ... )

  //
  // ADC
  //

  reg SYSCLK_adc_event;

  always @ ( MUXOUT, SYSCLK_ipd, TVC_i, STC_i, PWRDWN_ipd, ADCRESET_ipd, 
             ADC_CLK, ADCSTART_ipd, MODE_i, SYSCLK_period, ADC_CLK_period )
    begin
      
      SYSCLK_adc_event = SYSCLK_ipd !== SYSCLK_adc_prev;
      
      //
      //  Conversion & Resolution Selection
      //  

      if ( ( adc_input * 4096.0 ) / ( va_ref_real ) > 4095.0 )
        begin
          comparator_output_12 = 12'b111111111111;
          comparator_output_10 = 12'b111111111100;
          comparator_output_8  = 12'b111111110000;
        end
      else if ( ( adc_input * 4096.0 ) / ( va_ref_real ) > 4092.0 )
        begin
          comparator_output_12_temp = ( adc_input * 4096.0 ) / ( va_ref_real );
          comparator_output_12      =  comparator_output_12_temp;
          comparator_output_10      = 12'b111111111100;
          comparator_output_8       = 12'b111111110000;
        end
      else if ( ( adc_input * 4096.0 ) / ( va_ref_real ) > 4080.0 )
        begin
          comparator_output_12_temp = ( adc_input * 4096.0 ) / ( va_ref_real );
          comparator_output_12      =  comparator_output_12_temp;
          comparator_output_10      = {comparator_output_12_temp[11:2], 2'b00};
          comparator_output_8       = 12'b111111110000;
        end
      else if ( adc_input < ( va_ref_real / 4096.0 ) )
        begin
          comparator_output_10 = 12'b000000000000;
          comparator_output_12 = 12'b000000000000;
          comparator_output_8  = 12'b000000000000;
        end
      else
        begin
          comparator_output_12_temp = ( adc_input * 4096.0 ) / ( va_ref_real );
          comparator_output_12      =  comparator_output_12_temp;
          comparator_output_10      = {comparator_output_12_temp[11:2], 2'b00};
          comparator_output_8       = {comparator_output_12_temp[11:4], 4'b0000};
        end

      t_sync_read   = SYSCLK_period;
      t_sync_write  = SYSCLK_period;
      t_sample      = (2 + STC_i) * ADC_CLK_period;
      t_cal         = 2 * ADC_CLK_period;
      t_powerup_cal = SYSCLK_CYCLES_PCAL * ADC_CLK_period;

      if ( (MODE_i == 0) || (MODE_i == 4) || (MODE_i == 8) || (MODE_i == 12) )
        begin
          t_distrib     = 10 * ADC_CLK_period;
          if ( FAST_ADC_CONV_SIM )
            begin
              if (calibration_started == 1'b1) 
                 t_conv = t_distrib;
               else
                 t_conv = t_distrib + t_cal;
            end
          else 
            t_conv      = t_sync_read + t_sample + t_distrib + t_sync_write;
          result_temp = comparator_output_10;
        end
      else if ( (MODE_i == 1) || (MODE_i == 5) || (MODE_i == 9) || (MODE_i == 13) )
        begin
          t_distrib     = 12 * ADC_CLK_period;
          if ( FAST_ADC_CONV_SIM )
            begin
              if (calibration_started == 1'b1) 
                 t_conv = t_distrib;
               else
                 t_conv = t_distrib + t_cal;
            end
          else 
            t_conv      = t_sync_read + t_sample + t_distrib + t_sync_write;
          result_temp = comparator_output_12;
        end
      else if ( (MODE_i == 2) || (MODE_i == 6) || (MODE_i == 10) || (MODE_i == 14) )
        begin
          t_distrib     = 8 * ADC_CLK_period;
          if ( FAST_ADC_CONV_SIM )
            begin
              if (calibration_started == 1'b1)
                 t_conv = t_distrib;
               else
                 t_conv = t_distrib + t_cal;
            end
          else 
            t_conv      = t_sync_read + t_sample + t_distrib + t_sync_write;
          result_temp = comparator_output_8;
        end
      else if ( WARNING_MSGS_ON )
        begin 
          $display ( "Warning : Reserved ADC mode, at time  %0.1f\n", $realtime);
        end

      //
      // Latching of control signals and Powerup calibration.
      // Calibrate, Sample, DataValid and Busy signals
      //

      if (ADCRESET_ipd == 1'b1)
      begin
        calibration_started = 0;
        ad_res_int          = 1;
        busy_elapsed_time   = 0;
        BUSY_reg            = 1'b0;
        DATAVALID_reg       = 1'b0;
        RESULT_reg          = 12'b000000000000;
        busy_int            = 0;
        SAMPLE_reg          = 1'b0;
      end
      else if (SYSCLK_adc_event && SYSCLK_ipd == 1'b1)
      begin
        STC_i      = STC_ipd;
        TVC_i      = TVC_ipd;
        CHNUMBER_i = CHNUMBER_ipd;
        MODE_i     = MODE_ipd;

      	if ( ADCSTART_ipd == 1'b1 && conversion_started == 0 )
	begin
          BUSY_reg          = 1'b1;
          DATAVALID_reg     = 1'b0;
          busy_start_time   = $time;
          busy_int          = 1;
          SAMPLE_reg        = 1'b1;
          sample_start_time = $time;
          conversion_started = 1;
          // if ADCSTART interrupted power-up calibration (PUK) or ADCSTART was asserted before
          // PUK was started (intra conversion) assert interrup_cal to pause calibration
          if ( calibration_started == 1 || ad_res_int == 1 )
          begin
            interrupt_cal = 1'b1;
          end
        end
      	else if ( ADCSTART_ipd == 1'b0 && PWRDWN_ipd == 1'b0 )
        begin
          conversion_started = 0;
          if ( busy_int == 1 )
          begin
            if ( ( $time - busy_start_time ) >= t_conv )
            begin
              BUSY_reg      = 1'b0;
              DATAVALID_reg = 1'b1;
              RESULT_reg    = result_temp;
              busy_int      = 0;
              // if ADCSTART interrupted PUK, de-assert interrup_cal to resume calibration count
              if ( calibration_started == 1 )
                interrupt_cal = 1'b0;
            end
            else if ( ( $time - sample_start_time ) >= t_sample + ( 2 * SYSCLK_period ) )
            begin
              SAMPLE_reg  = 1'b0;
              if ( MUXOUT < 0.0 )
                adc_input = 0.0;
              else
                adc_input = MUXOUT;
            end
          end

          if ( ( ADCRESET_ipd == 1'b0 ) && ( ad_res_int == 1 ) )
          begin
            fper_cal_count = fper_cal_count + 1;
            if ( fper_cal_count == 4 )
            begin
              CALIBRATE_reg          = 1'b1;
              calibration_start_time = $time;
              fper_cal_count         = 0;
              calibration_started    = 1;
              ad_res_int             = 0;
              if (busy_int == 1)
                busy_elapsed_time <= $time - busy_start_time;
            end
          end
        end
      end

      SYSCLK_adc_prev = SYSCLK_ipd;

    end // always @ ( MUXOUT, SYSCLK_ipd, TVC_i, STC_i, PWRDWN_ipd, ADCRESET_ipd, ADC_CLK,
        //                             ADCSTART_ipd, MODE_i, SYSCLK_period, ADC_CLK_period )


    // counter implementation for CALIBRATE de-assertion
    
    always @ ( posedge ADC_CLK or posedge ADCRESET_ipd ) 
    begin
      if ( ADCRESET_ipd == 1'b1 )  
      begin
        CALIBRATE_reg       = 1'b0;
        CALIBRATE_cnt       =  'd0;
        interrupt_cal       = 1'b0;
      end
      else 
      begin
        if ( CALIBRATE_cnt == 'd3840 )
        begin
          CALIBRATE_reg       = 1'b0;
          CALIBRATE_cnt       =  'd0;
          calibration_started =  'd0;
          // pseudo interrupt to stop counting upon reaching 3840
          interrupt_cal       = 1'b1;
        end
        else
        begin
          if ( interrupt_cal == 1'b0 )
            CALIBRATE_cnt = CALIBRATE_cnt + 1'd1;
        end
      end
        
    end // always ( posedge ADC_CLK or posedge ADCRESET_ipd ) 



//--------------------------------------------------------------
//              Timing Checking Section
//-------------------------------------------------------------

 specify

  specparam   tpdLH_VARESEL_to_VAREF      = (0.1:0.1:0.1);
  specparam   tpdHL_VAREFSEL_to_VAREF     = (0.1:0.1:0.1);
  specparam   tpdLH_AV_to_DAVOUT          = (0.1:0.1:0.1);
  specparam   tpdHL_AV_to_DAVOUT          = (0.1:0.1:0.1);
  specparam   tpdLH_AC_to_DACOUT          = (0.1:0.1:0.1);
  specparam   tpdHL_AC_to_DACOUT          = (0.1:0.1:0.1);
  specparam   tpdLH_AT_to_DATOUT          = (0.1:0.1:0.1);
  specparam   tpdHL_AT_to_DATOUT          = (0.1:0.1:0.1);
  specparam   tpdLH_ACMCLK_to_ACMRDATA    = (0.1:0.1:0.1);
  specparam   tpdHL_ACMCLK_to_ACMRDATA    = (0.1:0.1:0.1);
  specparam   tpdLH_ACMRESET_to_ACMRDATA  = (0.1:0.1:0.1);
  specparam   tpdHL_ACMRESET_to_ACMRDATA  = (0.1:0.1:0.1);
  specparam   tpdLH_SYSCLK_to_BUSY        = (0.1:0.1:0.1);
  specparam   tpdHL_SYSCLK_to_BUSY        = (0.1:0.1:0.1);
  specparam   tpdLH_SYSCLK_to_CALIBRATE   = (0.1:0.1:0.1);
  specparam   tpdHL_SYSCLK_to_CALIBRATE   = (0.1:0.1:0.1);
  specparam   tpdLH_SYSCLK_to_DATAVALID   = (0.1:0.1:0.1);
  specparam   tpdHL_SYSCLK_to_DATAVALID   = (0.1:0.1:0.1);
  specparam   tpdLH_SYSCLK_to_SAMPLE      = (0.1:0.1:0.1);
  specparam   tpdHL_SYSCLK_to_SAMPLE      = (0.1:0.1:0.1);
  specparam   tpdLH_SYSCLK_to_RESULT      = (0.1:0.1:0.1);
  specparam   tpdHL_SYSCLK_to_RESULT      = (0.1:0.1:0.1);
  specparam   tpdLH_ADCRESET_to_BUSY      = (0.1:0.1:0.1);
  specparam   tpdHL_ADCRESET_to_BUSY      = (0.1:0.1:0.1);
  specparam   tpdLH_ADCRESET_to_CALIBRATE = (0.1:0.1:0.1);
  specparam   tpdHL_ADCRESET_to_CALIBRATE = (0.1:0.1:0.1);
  specparam   tpdLH_ADCRESET_to_DATAVALID = (0.1:0.1:0.1);
  specparam   tpdHL_ADCRESET_to_DATAVALID = (0.1:0.1:0.1);
  specparam   tpdLH_ADCRESET_to_SAMPLE    = (0.1:0.1:0.1);
  specparam   tpdHL_ADCRESET_to_SAMPLE    = (0.1:0.1:0.1);
  specparam   tpdLH_ADCRESET_to_RESULT    = (0.1:0.1:0.1);
  specparam   tpdHL_ADCRESET_to_RESULT    = (0.1:0.1:0.1);

  // IOPATH delay for VAREFSEL to VAREF

  (VAREFSEL => VAREF ) = ( tpdLH_VARESEL_to_VAREF, tpdHL_VAREFSEL_to_VAREF );

  // IOPATH delay for Analog Quads to Digital Ouputs

  (AV0 => DAVOUT0 )    = ( tpdLH_AV_to_DAVOUT, tpdHL_AV_to_DAVOUT );
  (AV1 => DAVOUT1 )    = ( tpdLH_AV_to_DAVOUT, tpdHL_AV_to_DAVOUT );
  (AV2 => DAVOUT2 )    = ( tpdLH_AV_to_DAVOUT, tpdHL_AV_to_DAVOUT );
  (AV3 => DAVOUT3 )    = ( tpdLH_AV_to_DAVOUT, tpdHL_AV_to_DAVOUT );
  (AV4 => DAVOUT4 )    = ( tpdLH_AV_to_DAVOUT, tpdHL_AV_to_DAVOUT );
  (AV5 => DAVOUT5 )    = ( tpdLH_AV_to_DAVOUT, tpdHL_AV_to_DAVOUT );
  (AV6 => DAVOUT6 )    = ( tpdLH_AV_to_DAVOUT, tpdHL_AV_to_DAVOUT );
  (AV7 => DAVOUT7 )    = ( tpdLH_AV_to_DAVOUT, tpdHL_AV_to_DAVOUT );
  (AV8 => DAVOUT8 )    = ( tpdLH_AV_to_DAVOUT, tpdHL_AV_to_DAVOUT );
  (AV9 => DAVOUT9 )    = ( tpdLH_AV_to_DAVOUT, tpdHL_AV_to_DAVOUT );
  (AC0 => DACOUT0 )    = ( tpdLH_AC_to_DACOUT, tpdHL_AC_to_DACOUT );
  (AC1 => DACOUT1 )    = ( tpdLH_AC_to_DACOUT, tpdHL_AC_to_DACOUT );
  (AC2 => DACOUT2 )    = ( tpdLH_AC_to_DACOUT, tpdHL_AC_to_DACOUT );
  (AC3 => DACOUT3 )    = ( tpdLH_AC_to_DACOUT, tpdHL_AC_to_DACOUT );
  (AC4 => DACOUT4 )    = ( tpdLH_AC_to_DACOUT, tpdHL_AC_to_DACOUT );
  (AC5 => DACOUT5 )    = ( tpdLH_AC_to_DACOUT, tpdHL_AC_to_DACOUT );
  (AC6 => DACOUT6 )    = ( tpdLH_AC_to_DACOUT, tpdHL_AC_to_DACOUT );
  (AC7 => DACOUT7 )    = ( tpdLH_AC_to_DACOUT, tpdHL_AC_to_DACOUT );
  (AC8 => DACOUT8 )    = ( tpdLH_AC_to_DACOUT, tpdHL_AC_to_DACOUT );
  (AC9 => DACOUT9 )    = ( tpdLH_AC_to_DACOUT, tpdHL_AC_to_DACOUT );
  (AT0 => DATOUT0 )    = ( tpdLH_AT_to_DATOUT, tpdHL_AT_to_DATOUT );
  (AT1 => DATOUT1 )    = ( tpdLH_AT_to_DATOUT, tpdHL_AT_to_DATOUT );
  (AT2 => DATOUT2 )    = ( tpdLH_AT_to_DATOUT, tpdHL_AT_to_DATOUT );
  (AT3 => DATOUT3 )    = ( tpdLH_AT_to_DATOUT, tpdHL_AT_to_DATOUT );
  (AT4 => DATOUT4 )    = ( tpdLH_AT_to_DATOUT, tpdHL_AT_to_DATOUT );
  (AT5 => DATOUT5 )    = ( tpdLH_AT_to_DATOUT, tpdHL_AT_to_DATOUT );
  (AT6 => DATOUT6 )    = ( tpdLH_AT_to_DATOUT, tpdHL_AT_to_DATOUT );
  (AT7 => DATOUT7 )    = ( tpdLH_AT_to_DATOUT, tpdHL_AT_to_DATOUT );
  (AT8 => DATOUT8 )    = ( tpdLH_AT_to_DATOUT, tpdHL_AT_to_DATOUT );
  (AT9 => DATOUT9 )    = ( tpdLH_AT_to_DATOUT, tpdHL_AT_to_DATOUT );

  // IOPATH delay for ACMCLK and ACMRESET to ACMRDATA

  (ACMCLK   => ACMRDATA[0] ) = ( tpdLH_ACMCLK_to_ACMRDATA, tpdHL_ACMCLK_to_ACMRDATA );
  (ACMCLK   => ACMRDATA[1] ) = ( tpdLH_ACMCLK_to_ACMRDATA, tpdHL_ACMCLK_to_ACMRDATA );
  (ACMCLK   => ACMRDATA[2] ) = ( tpdLH_ACMCLK_to_ACMRDATA, tpdHL_ACMCLK_to_ACMRDATA );
  (ACMCLK   => ACMRDATA[3] ) = ( tpdLH_ACMCLK_to_ACMRDATA, tpdHL_ACMCLK_to_ACMRDATA );
  (ACMCLK   => ACMRDATA[4] ) = ( tpdLH_ACMCLK_to_ACMRDATA, tpdHL_ACMCLK_to_ACMRDATA );
  (ACMCLK   => ACMRDATA[5] ) = ( tpdLH_ACMCLK_to_ACMRDATA, tpdHL_ACMCLK_to_ACMRDATA );
  (ACMCLK   => ACMRDATA[6] ) = ( tpdLH_ACMCLK_to_ACMRDATA, tpdHL_ACMCLK_to_ACMRDATA );
  (ACMCLK   => ACMRDATA[7] ) = ( tpdLH_ACMCLK_to_ACMRDATA, tpdHL_ACMCLK_to_ACMRDATA );
  (ACMRESET => ACMRDATA[0] ) = ( tpdLH_ACMRESET_to_ACMRDATA, tpdHL_ACMRESET_to_ACMRDATA );
  (ACMRESET => ACMRDATA[1] ) = ( tpdLH_ACMRESET_to_ACMRDATA, tpdHL_ACMRESET_to_ACMRDATA );
  (ACMRESET => ACMRDATA[2] ) = ( tpdLH_ACMRESET_to_ACMRDATA, tpdHL_ACMRESET_to_ACMRDATA );
  (ACMRESET => ACMRDATA[3] ) = ( tpdLH_ACMRESET_to_ACMRDATA, tpdHL_ACMRESET_to_ACMRDATA );
  (ACMRESET => ACMRDATA[4] ) = ( tpdLH_ACMRESET_to_ACMRDATA, tpdHL_ACMRESET_to_ACMRDATA );
  (ACMRESET => ACMRDATA[5] ) = ( tpdLH_ACMRESET_to_ACMRDATA, tpdHL_ACMRESET_to_ACMRDATA );
  (ACMRESET => ACMRDATA[6] ) = ( tpdLH_ACMRESET_to_ACMRDATA, tpdHL_ACMRESET_to_ACMRDATA );
  (ACMRESET => ACMRDATA[7] ) = ( tpdLH_ACMRESET_to_ACMRDATA, tpdHL_ACMRESET_to_ACMRDATA );

  // IOPATH delay for ADC's SYSCLK and ADCRESET

  (SYSCLK => BUSY      )    = ( tpdLH_SYSCLK_to_BUSY, tpdHL_SYSCLK_to_BUSY );
  (SYSCLK => CALIBRATE )    = ( tpdLH_SYSCLK_to_CALIBRATE, tpdHL_SYSCLK_to_CALIBRATE );
  (SYSCLK => DATAVALID )    = ( tpdLH_SYSCLK_to_DATAVALID, tpdHL_SYSCLK_to_DATAVALID );
  (SYSCLK => SAMPLE    )    = ( tpdLH_SYSCLK_to_SAMPLE, tpdHL_SYSCLK_to_SAMPLE );
  (SYSCLK => RESULT[0] )    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (SYSCLK => RESULT[1] )    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (SYSCLK => RESULT[2] )    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (SYSCLK => RESULT[3] )    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (SYSCLK => RESULT[4] )    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (SYSCLK => RESULT[5] )    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (SYSCLK => RESULT[6] )    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (SYSCLK => RESULT[7] )    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (SYSCLK => RESULT[8] )    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (SYSCLK => RESULT[9] )    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (SYSCLK => RESULT[10])    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (SYSCLK => RESULT[11])    = ( tpdLH_SYSCLK_to_RESULT, tpdHL_SYSCLK_to_RESULT );
  (ADCRESET => BUSY      )  = ( tpdLH_ADCRESET_to_BUSY, tpdHL_ADCRESET_to_BUSY );
  (ADCRESET => CALIBRATE )  = ( tpdLH_ADCRESET_to_CALIBRATE, tpdHL_ADCRESET_to_CALIBRATE );
  (ADCRESET => DATAVALID )  = ( tpdLH_ADCRESET_to_DATAVALID, tpdHL_ADCRESET_to_DATAVALID );
  (ADCRESET => SAMPLE    )  = ( tpdLH_ADCRESET_to_SAMPLE, tpdHL_ADCRESET_to_SAMPLE );
  (ADCRESET => RESULT[0] )  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );
  (ADCRESET => RESULT[1] )  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );
  (ADCRESET => RESULT[2] )  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );
  (ADCRESET => RESULT[3] )  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );
  (ADCRESET => RESULT[4] )  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );
  (ADCRESET => RESULT[5] )  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );
  (ADCRESET => RESULT[6] )  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );
  (ADCRESET => RESULT[7] )  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );
  (ADCRESET => RESULT[8] )  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );
  (ADCRESET => RESULT[9] )  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );
  (ADCRESET => RESULT[10])  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );
  (ADCRESET => RESULT[11])  = ( tpdLH_ADCRESET_to_RESULT, tpdHL_ADCRESET_to_RESULT );

  // Setup and hold checks

  $setup ( posedge MODE[0], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge MODE[0], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge MODE[0], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge MODE[0], 0.0, NOTIFY_REG );
  $setup ( posedge MODE[1], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge MODE[1], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge MODE[1], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge MODE[1], 0.0, NOTIFY_REG );
  $setup ( posedge MODE[2], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge MODE[2], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge MODE[2], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge MODE[2], 0.0, NOTIFY_REG );
  $setup ( posedge MODE[3], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge MODE[3], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge MODE[3], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge MODE[3], 0.0, NOTIFY_REG );
  $setup ( posedge TVC[0], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge TVC[0], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge TVC[0], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge TVC[0], 0.0, NOTIFY_REG );
  $setup ( posedge TVC[1], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge TVC[1], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge TVC[1], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge TVC[1], 0.0, NOTIFY_REG );
  $setup ( posedge TVC[2], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge TVC[2], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge TVC[2], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge TVC[2], 0.0, NOTIFY_REG );
  $setup ( posedge TVC[3], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge TVC[3], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge TVC[3], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge TVC[3], 0.0, NOTIFY_REG );
  $setup ( posedge TVC[4], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge TVC[4], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge TVC[4], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge TVC[4], 0.0, NOTIFY_REG );
  $setup ( posedge TVC[5], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge TVC[5], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge TVC[5], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge TVC[5], 0.0, NOTIFY_REG );
  $setup ( posedge TVC[6], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge TVC[6], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge TVC[6], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge TVC[6], 0.0, NOTIFY_REG );
  $setup ( posedge TVC[7], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge TVC[7], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge TVC[7], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge TVC[7], 0.0, NOTIFY_REG );
  $setup ( posedge STC[0], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge STC[0], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge STC[0], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge STC[0], 0.0, NOTIFY_REG );
  $setup ( posedge STC[1], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge STC[1], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge STC[1], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge STC[1], 0.0, NOTIFY_REG );
  $setup ( posedge STC[2], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge STC[2], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge STC[2], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge STC[2], 0.0, NOTIFY_REG );
  $setup ( posedge STC[3], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge STC[3], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge STC[3], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge STC[3], 0.0, NOTIFY_REG );
  $setup ( posedge STC[4], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge STC[4], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge STC[4], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge STC[4], 0.0, NOTIFY_REG );
  $setup ( posedge STC[5], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge STC[5], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge STC[5], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge STC[5], 0.0, NOTIFY_REG );
  $setup ( posedge STC[6], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge STC[6], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge STC[6], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge STC[6], 0.0, NOTIFY_REG );
  $setup ( posedge STC[7], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge STC[7], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge STC[7], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge STC[7], 0.0, NOTIFY_REG );
  $setup ( posedge CHNUMBER[0], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge CHNUMBER[0], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge CHNUMBER[0], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge CHNUMBER[0], 0.0, NOTIFY_REG );
  $setup ( posedge CHNUMBER[1], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge CHNUMBER[1], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge CHNUMBER[1], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge CHNUMBER[1], 0.0, NOTIFY_REG );
  $setup ( posedge CHNUMBER[2], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge CHNUMBER[2], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge CHNUMBER[2], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge CHNUMBER[2], 0.0, NOTIFY_REG );
  $setup ( posedge CHNUMBER[3], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge CHNUMBER[3], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge CHNUMBER[3], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge CHNUMBER[3], 0.0, NOTIFY_REG );
  $setup ( posedge CHNUMBER[4], posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge CHNUMBER[4], posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge CHNUMBER[4], 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge CHNUMBER[4], 0.0, NOTIFY_REG );
  $setup ( posedge VAREFSEL, posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge VAREFSEL, posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge VAREFSEL, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge VAREFSEL, 0.0, NOTIFY_REG );
  $setup ( posedge ADCSTART, posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ADCSTART, posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge ADCSTART, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge ADCSTART, 0.0, NOTIFY_REG );
  $setup ( posedge ADCRESET, posedge SYSCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ADCRESET, posedge SYSCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, posedge ADCRESET, 0.0, NOTIFY_REG );
  $hold  ( posedge SYSCLK, negedge ADCRESET, 0.0, NOTIFY_REG );
  $setup ( posedge ACMWEN, posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMWEN, posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMWEN, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMWEN, 0.0, NOTIFY_REG );
  $setup ( posedge ACMRESET, posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMRESET, posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMRESET, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMRESET, 0.0, NOTIFY_REG );
  $setup ( posedge ACMADDR[0], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMADDR[0], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMADDR[0], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMADDR[0], 0.0, NOTIFY_REG );
  $setup ( posedge ACMADDR[1], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMADDR[1], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMADDR[1], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMADDR[1], 0.0, NOTIFY_REG );
  $setup ( posedge ACMADDR[2], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMADDR[2], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMADDR[2], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMADDR[2], 0.0, NOTIFY_REG );
  $setup ( posedge ACMADDR[3], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMADDR[3], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMADDR[3], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMADDR[3], 0.0, NOTIFY_REG );
  $setup ( posedge ACMADDR[4], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMADDR[4], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMADDR[4], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMADDR[4], 0.0, NOTIFY_REG );
  $setup ( posedge ACMADDR[5], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMADDR[5], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMADDR[5], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMADDR[5], 0.0, NOTIFY_REG );
  $setup ( posedge ACMADDR[6], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMADDR[6], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMADDR[6], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMADDR[6], 0.0, NOTIFY_REG );
  $setup ( posedge ACMADDR[7], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMADDR[7], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMADDR[7], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMADDR[7], 0.0, NOTIFY_REG );
  $setup ( posedge ACMWDATA[0], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMWDATA[0], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMWDATA[0], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMWDATA[0], 0.0, NOTIFY_REG );
  $setup ( posedge ACMWDATA[1], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMWDATA[1], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMWDATA[1], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMWDATA[1], 0.0, NOTIFY_REG );
  $setup ( posedge ACMWDATA[2], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMWDATA[2], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMWDATA[2], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMWDATA[2], 0.0, NOTIFY_REG );
  $setup ( posedge ACMWDATA[3], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMWDATA[3], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMWDATA[3], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMWDATA[3], 0.0, NOTIFY_REG );
  $setup ( posedge ACMWDATA[4], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMWDATA[4], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMWDATA[4], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMWDATA[4], 0.0, NOTIFY_REG );
  $setup ( posedge ACMWDATA[5], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMWDATA[5], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMWDATA[5], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMWDATA[5], 0.0, NOTIFY_REG );
  $setup ( posedge ACMWDATA[6], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMWDATA[6], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMWDATA[6], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMWDATA[6], 0.0, NOTIFY_REG );
  $setup ( posedge ACMWDATA[7], posedge ACMCLK, 0.0, NOTIFY_REG );
  $setup ( negedge ACMWDATA[7], posedge ACMCLK, 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, posedge ACMWDATA[7], 0.0, NOTIFY_REG );
  $hold  ( posedge ACMCLK, negedge ACMWDATA[7], 0.0, NOTIFY_REG );

  //checking timing for control signals


  //checking the recovery data

  $recovery ( posedge ACMRESET, posedge ACMCLK, 0.0, NOTIFY_REG );
  $recovery ( negedge ADCRESET, posedge SYSCLK, 0.0, NOTIFY_REG );

  // period timing check on ACMCLK

  $period( posedge ACMCLK, 100000, NOTIFY_REG );
  $period( negedge ACMCLK, 100000, NOTIFY_REG );

  //checking the pulse width

  $width ( posedge ACMRESET, 0, 0, NOTIFY_REG );
  $width ( negedge ACMRESET, 0, 0, NOTIFY_REG );
  $width ( posedge ADCRESET, 0, 0, NOTIFY_REG );
  $width ( negedge ADCRESET, 0, 0, NOTIFY_REG );
  $width ( posedge SYSCLK, 0, 0, NOTIFY_REG );
  $width ( negedge SYSCLK, 0, 0, NOTIFY_REG );
  $width ( posedge ACMCLK, 45000, 0, NOTIFY_REG );
  $width ( negedge ACMCLK, 45000, 0, NOTIFY_REG );
  $width ( posedge RTCCLK, 0, 0, NOTIFY_REG );
  $width ( negedge RTCCLK, 0, 0, NOTIFY_REG );
  $width ( posedge AV0 &&& DENAV0, 0, 0, NOTIFY_REG );
  $width ( negedge AV0 &&& DENAV0, 0, 0, NOTIFY_REG );
  $width ( posedge AC0 &&& DENAC0, 0, 0, NOTIFY_REG ); 
  $width ( negedge AC0 &&& DENAC0, 0, 0, NOTIFY_REG ); 
  $width ( posedge AT0 &&& DENAT0, 0, 0, NOTIFY_REG ); 
  $width ( negedge AT0 &&& DENAT0, 0, 0, NOTIFY_REG ); 
  $width ( posedge AV1 &&& DENAV1, 0, 0, NOTIFY_REG );
  $width ( negedge AV1 &&& DENAV1, 0, 0, NOTIFY_REG );
  $width ( posedge AC1 &&& DENAC1, 0, 0, NOTIFY_REG );
  $width ( negedge AC1 &&& DENAC1, 0, 0, NOTIFY_REG );
  $width ( posedge AT1 &&& DENAT1, 0, 0, NOTIFY_REG );
  $width ( negedge AT1 &&& DENAT1, 0, 0, NOTIFY_REG );
  $width ( posedge AV2 &&& DENAV2, 0, 0, NOTIFY_REG );
  $width ( negedge AV2 &&& DENAV2, 0, 0, NOTIFY_REG );
  $width ( posedge AC2 &&& DENAC2, 0, 0, NOTIFY_REG );
  $width ( negedge AC2 &&& DENAC2, 0, 0, NOTIFY_REG );
  $width ( posedge AT2 &&& DENAT2, 0, 0, NOTIFY_REG );
  $width ( negedge AT2 &&& DENAT2, 0, 0, NOTIFY_REG );
  $width ( posedge AV3 &&& DENAV3, 0, 0, NOTIFY_REG );
  $width ( negedge AV3 &&& DENAV3, 0, 0, NOTIFY_REG );
  $width ( posedge AC3 &&& DENAC3, 0, 0, NOTIFY_REG );
  $width ( negedge AC3 &&& DENAC3, 0, 0, NOTIFY_REG );
  $width ( posedge AT3 &&& DENAT3, 0, 0, NOTIFY_REG );
  $width ( negedge AT3 &&& DENAT3, 0, 0, NOTIFY_REG );
  $width ( posedge AV4 &&& DENAV4, 0, 0, NOTIFY_REG );
  $width ( negedge AV4 &&& DENAV4, 0, 0, NOTIFY_REG );
  $width ( posedge AC4 &&& DENAC4, 0, 0, NOTIFY_REG );
  $width ( negedge AC4 &&& DENAC4, 0, 0, NOTIFY_REG );
  $width ( posedge AT4 &&& DENAT4, 0, 0, NOTIFY_REG );
  $width ( negedge AT4 &&& DENAT4, 0, 0, NOTIFY_REG );
  $width ( posedge AV5 &&& DENAV5, 0, 0, NOTIFY_REG );
  $width ( negedge AV5 &&& DENAV5, 0, 0, NOTIFY_REG );
  $width ( posedge AC5 &&& DENAC5, 0, 0, NOTIFY_REG );
  $width ( negedge AC5 &&& DENAC5, 0, 0, NOTIFY_REG );
  $width ( posedge AT5 &&& DENAT5, 0, 0, NOTIFY_REG );
  $width ( negedge AT5 &&& DENAT5, 0, 0, NOTIFY_REG );
  $width ( posedge AV6 &&& DENAV6, 0, 0, NOTIFY_REG );
  $width ( negedge AV6 &&& DENAV6, 0, 0, NOTIFY_REG );
  $width ( posedge AC6 &&& DENAC6, 0, 0, NOTIFY_REG );
  $width ( negedge AC6 &&& DENAC6, 0, 0, NOTIFY_REG );
  $width ( posedge AT6 &&& DENAT6, 0, 0, NOTIFY_REG );
  $width ( negedge AT6 &&& DENAT6, 0, 0, NOTIFY_REG );
  $width ( posedge AV7 &&& DENAV7, 0, 0, NOTIFY_REG );
  $width ( negedge AV7 &&& DENAV7, 0, 0, NOTIFY_REG );
  $width ( posedge AC7 &&& DENAC7, 0, 0, NOTIFY_REG );
  $width ( negedge AC7 &&& DENAC7, 0, 0, NOTIFY_REG );
  $width ( posedge AT7 &&& DENAT7, 0, 0, NOTIFY_REG );
  $width ( negedge AT7 &&& DENAT7, 0, 0, NOTIFY_REG );
  $width ( posedge AV8 &&& DENAV8, 0, 0, NOTIFY_REG );
  $width ( negedge AV8 &&& DENAV8, 0, 0, NOTIFY_REG );
  $width ( posedge AC8 &&& DENAC8, 0, 0, NOTIFY_REG );
  $width ( negedge AC8 &&& DENAC8, 0, 0, NOTIFY_REG );
  $width ( posedge AT8 &&& DENAT8, 0, 0, NOTIFY_REG );
  $width ( negedge AT8 &&& DENAT8, 0, 0, NOTIFY_REG );
  $width ( posedge AV9 &&& DENAV9, 0, 0, NOTIFY_REG );
  $width ( negedge AV9 &&& DENAV9, 0, 0, NOTIFY_REG );
  $width ( posedge AC9 &&& DENAC9, 0, 0, NOTIFY_REG );
  $width ( negedge AC9 &&& DENAC9, 0, 0, NOTIFY_REG );
  $width ( posedge AT9 &&& DENAT9, 0, 0, NOTIFY_REG );
  $width ( negedge AT9 &&& DENAT9, 0, 0, NOTIFY_REG );
  $width ( posedge DENAV0, 0, 0, NOTIFY_REG );
  $width ( negedge DENAV0, 0, 0, NOTIFY_REG );
  $width ( posedge DENAV1, 0, 0, NOTIFY_REG );
  $width ( negedge DENAV1, 0, 0, NOTIFY_REG );
  $width ( posedge DENAV2, 0, 0, NOTIFY_REG );
  $width ( negedge DENAV2, 0, 0, NOTIFY_REG );
  $width ( posedge DENAV3, 0, 0, NOTIFY_REG );
  $width ( negedge DENAV3, 0, 0, NOTIFY_REG );
  $width ( posedge DENAV4, 0, 0, NOTIFY_REG );
  $width ( negedge DENAV4, 0, 0, NOTIFY_REG );
  $width ( posedge DENAV5, 0, 0, NOTIFY_REG );
  $width ( negedge DENAV5, 0, 0, NOTIFY_REG );
  $width ( posedge DENAV6, 0, 0, NOTIFY_REG );
  $width ( negedge DENAV6, 0, 0, NOTIFY_REG );
  $width ( posedge DENAV7, 0, 0, NOTIFY_REG );
  $width ( negedge DENAV7, 0, 0, NOTIFY_REG );
  $width ( posedge DENAV8, 0, 0, NOTIFY_REG );
  $width ( negedge DENAV8, 0, 0, NOTIFY_REG );
  $width ( posedge DENAV9, 0, 0, NOTIFY_REG );
  $width ( negedge DENAV9, 0, 0, NOTIFY_REG );
  $width ( posedge DENAC0, 0, 0, NOTIFY_REG );
  $width ( negedge DENAC0, 0, 0, NOTIFY_REG );
  $width ( posedge DENAC1, 0, 0, NOTIFY_REG );
  $width ( negedge DENAC1, 0, 0, NOTIFY_REG );
  $width ( posedge DENAC2, 0, 0, NOTIFY_REG );
  $width ( negedge DENAC2, 0, 0, NOTIFY_REG );
  $width ( posedge DENAC3, 0, 0, NOTIFY_REG );
  $width ( negedge DENAC3, 0, 0, NOTIFY_REG );
  $width ( posedge DENAC4, 0, 0, NOTIFY_REG );
  $width ( negedge DENAC4, 0, 0, NOTIFY_REG );
  $width ( posedge DENAC5, 0, 0, NOTIFY_REG );
  $width ( negedge DENAC5, 0, 0, NOTIFY_REG );
  $width ( posedge DENAC6, 0, 0, NOTIFY_REG );
  $width ( negedge DENAC6, 0, 0, NOTIFY_REG );
  $width ( posedge DENAC7, 0, 0, NOTIFY_REG );
  $width ( negedge DENAC7, 0, 0, NOTIFY_REG );
  $width ( posedge DENAC8, 0, 0, NOTIFY_REG );
  $width ( negedge DENAC8, 0, 0, NOTIFY_REG );
  $width ( posedge DENAC9, 0, 0, NOTIFY_REG );
  $width ( negedge DENAC9, 0, 0, NOTIFY_REG );
  $width ( posedge DENAT0, 0, 0, NOTIFY_REG );
  $width ( negedge DENAT0, 0, 0, NOTIFY_REG );
  $width ( posedge DENAT1, 0, 0, NOTIFY_REG );
  $width ( negedge DENAT1, 0, 0, NOTIFY_REG );
  $width ( posedge DENAT2, 0, 0, NOTIFY_REG );
  $width ( negedge DENAT2, 0, 0, NOTIFY_REG );
  $width ( posedge DENAT3, 0, 0, NOTIFY_REG );
  $width ( negedge DENAT3, 0, 0, NOTIFY_REG );
  $width ( posedge DENAT4, 0, 0, NOTIFY_REG );
  $width ( negedge DENAT4, 0, 0, NOTIFY_REG );
  $width ( posedge DENAT5, 0, 0, NOTIFY_REG );
  $width ( negedge DENAT5, 0, 0, NOTIFY_REG );
  $width ( posedge DENAT6, 0, 0, NOTIFY_REG );
  $width ( negedge DENAT6, 0, 0, NOTIFY_REG );
  $width ( posedge DENAT7, 0, 0, NOTIFY_REG );
  $width ( negedge DENAT7, 0, 0, NOTIFY_REG );
  $width ( posedge DENAT8, 0, 0, NOTIFY_REG );
  $width ( negedge DENAT8, 0, 0, NOTIFY_REG );
  $width ( posedge DENAT9, 0, 0, NOTIFY_REG );
  $width ( negedge DENAT9, 0, 0, NOTIFY_REG );
  $width ( posedge CMSTB0, 0, 0, NOTIFY_REG );
  $width ( negedge CMSTB0, 0, 0, NOTIFY_REG );
  $width ( posedge CMSTB1, 0, 0, NOTIFY_REG );
  $width ( negedge CMSTB1, 0, 0, NOTIFY_REG );
  $width ( posedge CMSTB2, 0, 0, NOTIFY_REG );
  $width ( negedge CMSTB2, 0, 0, NOTIFY_REG );
  $width ( posedge CMSTB3, 0, 0, NOTIFY_REG );
  $width ( negedge CMSTB3, 0, 0, NOTIFY_REG );
  $width ( posedge CMSTB4, 0, 0, NOTIFY_REG );
  $width ( negedge CMSTB4, 0, 0, NOTIFY_REG );
  $width ( posedge CMSTB5, 0, 0, NOTIFY_REG );
  $width ( negedge CMSTB5, 0, 0, NOTIFY_REG );
  $width ( posedge CMSTB6, 0, 0, NOTIFY_REG );
  $width ( negedge CMSTB6, 0, 0, NOTIFY_REG );
  $width ( posedge CMSTB7, 0, 0, NOTIFY_REG );
  $width ( negedge CMSTB7, 0, 0, NOTIFY_REG );
  $width ( posedge CMSTB8, 0, 0, NOTIFY_REG );
  $width ( negedge CMSTB8, 0, 0, NOTIFY_REG );
  $width ( posedge CMSTB9, 0, 0, NOTIFY_REG );
  $width ( negedge CMSTB9, 0, 0, NOTIFY_REG );
  $width ( posedge TMSTB0, 0, 0, NOTIFY_REG );
  $width ( negedge TMSTB0, 0, 0, NOTIFY_REG );
  $width ( posedge TMSTB1, 0, 0, NOTIFY_REG );
  $width ( negedge TMSTB1, 0, 0, NOTIFY_REG );
  $width ( posedge TMSTB2, 0, 0, NOTIFY_REG );
  $width ( negedge TMSTB2, 0, 0, NOTIFY_REG );
  $width ( posedge TMSTB3, 0, 0, NOTIFY_REG );
  $width ( negedge TMSTB3, 0, 0, NOTIFY_REG );
  $width ( posedge TMSTB4, 0, 0, NOTIFY_REG );
  $width ( negedge TMSTB4, 0, 0, NOTIFY_REG );
  $width ( posedge TMSTB5, 0, 0, NOTIFY_REG );
  $width ( negedge TMSTB5, 0, 0, NOTIFY_REG );
  $width ( posedge TMSTB6, 0, 0, NOTIFY_REG );
  $width ( negedge TMSTB6, 0, 0, NOTIFY_REG );
  $width ( posedge TMSTB7, 0, 0, NOTIFY_REG );
  $width ( negedge TMSTB7, 0, 0, NOTIFY_REG );
  $width ( posedge TMSTB8, 0, 0, NOTIFY_REG );
  $width ( negedge TMSTB8, 0, 0, NOTIFY_REG );
  $width ( posedge TMSTB9, 0, 0, NOTIFY_REG );
  $width ( negedge TMSTB9, 0, 0, NOTIFY_REG );
  $width ( posedge TMSTBINT, 0, 0, NOTIFY_REG );
  $width ( negedge TMSTBINT, 0, 0, NOTIFY_REG );
  $width ( posedge GDON0, 0, 0, NOTIFY_REG );
  $width ( negedge GDON0, 0, 0, NOTIFY_REG );
  $width ( posedge GDON1, 0, 0, NOTIFY_REG );
  $width ( negedge GDON1, 0, 0, NOTIFY_REG );
  $width ( posedge GDON2, 0, 0, NOTIFY_REG );
  $width ( negedge GDON2, 0, 0, NOTIFY_REG );
  $width ( posedge GDON3, 0, 0, NOTIFY_REG );
  $width ( negedge GDON3, 0, 0, NOTIFY_REG );
  $width ( posedge GDON4, 0, 0, NOTIFY_REG );
  $width ( negedge GDON4, 0, 0, NOTIFY_REG );
  $width ( posedge GDON5, 0, 0, NOTIFY_REG );
  $width ( negedge GDON5, 0, 0, NOTIFY_REG );
  $width ( posedge GDON6, 0, 0, NOTIFY_REG );
  $width ( negedge GDON6, 0, 0, NOTIFY_REG );
  $width ( posedge GDON7, 0, 0, NOTIFY_REG );
  $width ( negedge GDON7, 0, 0, NOTIFY_REG );
  $width ( posedge GDON8, 0, 0, NOTIFY_REG );
  $width ( negedge GDON8, 0, 0, NOTIFY_REG );
  $width ( posedge GDON9, 0, 0, NOTIFY_REG );
  $width ( negedge GDON9, 0, 0, NOTIFY_REG );

 endspecify

endmodule // AB


//---- MODULE IOPAD_A_IN ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_A_IN
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_A_IN(Y,PAD);
 input PAD;
 output Y;

 assign Y = PAD;
 
       specify

    specparam tpdLH_PAD_to_Y = (0.0:0.0:0.0);
    specparam tpdHL_PAD_to_Y = (0.0:0.0:0.0);
    specparam MacroType = "comb";

    //pin to pin path delay

    (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_A_IN ----

//---- MODULE IOPAD_DA_IN ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_DA_IN
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_DA_IN(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 assign Y = PAD;

       specify

    specparam tpdLH_PAD_to_Y = (0.0:0.0:0.0);
    specparam tpdHL_PAD_to_Y = (0.0:0.0:0.0);
    specparam MacroType = "comb";

    //pin to pin path delay

    (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    specparam PATHPULSE$PAD$Y = (0.1, 0.1);
    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_DA_IN ----

//---- MODULE IOPAD_A_OUT ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_A_OUT
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_A_OUT(PAD,D);
 input D;
 output PAD;

 assign PAD = D;

       specify

    specparam tpdLH_D_to_PAD = (0.0:0.0:0.0);
    specparam tpdHL_D_to_PAD = (0.0:0.0:0.0);
    specparam MacroType = "comb";

    //pin to pin path delay

    (D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_A_OUT ----

//---- MODULE NGMUXPRIM ----
/*--------------------------------------------------------------------
 CELL NAME : NGMUXPRIM
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ps / 1 ps

module NGMUXPRIM ( GL, CLK0, CLK1, S );
`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif

  input   CLK0;
  input   CLK1;
  input   S;
  output  GL;

  reg     GL_zd;

  wire    CLK0_ipd;
  wire    CLK1_ipd;
  wire    S_ipd;

  reg     S_ipd_prev;
  reg     CLK0_ipd_prev;
  reg     CLK1_ipd_prev;
  integer CLK0_re;
  integer CLK1_re;
  integer CLK0_fe;
  integer CLK1_fe;
    // restart_clk_edge is assigned when GL_zd is sent low.
    // It is the number of "to clk" edges that must occur before the switch is complete
  integer restart_clk_edge;
    // driving_clk is -1 for GND, 0 for CLK0, 1 for CLK1, and -2 for unknown, and -3 for initialization
  integer driving_clk;

  buf     BUF_G ( GL, GL_zd );

  buf U0 ( CLK0_ipd, CLK0 );
  buf U1 ( CLK1_ipd, CLK1 );
  buf U2 ( S_ipd,    S    );

  initial
  begin
    S_ipd_prev       <= 1'bx;
    CLK0_ipd_prev    <= 1'bx;
    CLK1_ipd_prev    <= 1'bx;
    CLK0_re          <= 0;
    CLK1_re          <= 0;
    CLK0_fe          <= 0;
    CLK1_fe          <= 0;
    // Initial powerup does not have a standard switching sequence, comes up immediately with selected CLK
    restart_clk_edge <= 0;
    driving_clk      <= -3;
  end

  always @ ( CLK0_ipd, CLK1_ipd, S_ipd )
  begin
    if ( CLK0_ipd !== CLK0_ipd_prev ) begin
      CLK0_ipd_prev <= CLK0_ipd;
      if ( CLK0_ipd === 1'b1 ) begin
        CLK0_re <= CLK0_re + 1;
      end else if ( CLK0_ipd === 1'b0 ) begin
        CLK0_fe <= CLK0_fe + 1;
      end
    end
    if ( CLK1_ipd !== CLK1_ipd_prev ) begin
      CLK1_ipd_prev <= CLK1_ipd;
      if ( CLK1_ipd === 1'b1 ) begin
        CLK1_re <= CLK1_re + 1;
      end else if ( CLK1_ipd === 1'b0 ) begin
        CLK1_fe <= CLK1_fe + 1;
      end
    end
    if ( S_ipd !== S_ipd_prev ) begin
      S_ipd_prev <= S_ipd;
      CLK0_re <= 0;
      CLK1_re <= 0;
      CLK0_fe <= 0;
      CLK1_fe <= 0;
      // Handle error conditions:  previous switching cycle not completed or S_ipd unknown
      // driving_clk != -3 condition avoids error messsages for initial powerup unnknown
      if ( driving_clk != -3 ) begin
        if ( S_ipd === 1'b0 ) begin
          if ( driving_clk != 1 )  begin
                       if ( WARNING_MSGS_ON )
            $display( " ERROR: NGMUX switching sequence not completed, output GL unpredictable " );
                       if ( WARNING_MSGS_ON )
            $display( " Time: %0.1f Instance: %m ", $realtime );
            driving_clk <= 1;
          end
        end else if ( S_ipd === 1'b1 ) begin
          if ( driving_clk != 0 )  begin
                       if ( WARNING_MSGS_ON )
            $display( " ERROR: NGMUX switching sequence not completed, output GL unpredictable " );
                       if ( WARNING_MSGS_ON )
            $display( " Time: %0.1f Instance: %m ", $realtime );
            driving_clk <= 0;
          end
        end else begin
                       if ( WARNING_MSGS_ON )
          $display( " ERROR: NGMUX input S is unknown, output GL unpredictable, setting to 0 " );
                       if ( WARNING_MSGS_ON )
          $display( " Time: %0.1f Instance: %m ", $realtime );
          driving_clk <= -2;
          restart_clk_edge <= 17;
        end
      end
    end
  end

  always @ ( driving_clk, CLK0_re, CLK0_fe, CLK1_re, CLK1_fe )
  begin
    if ( driving_clk == 0 ) begin
      GL_zd <= CLK0_ipd;
      if ( S_ipd === 1'b1 ) begin
        if ( ( CLK0_re == 0 ) && ( CLK1_re == 7 ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= 9;
        end else if ( ( CLK0_fe == 0 ) && ( CLK1_re == 15 ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= 17;
        end else if ( ( CLK0_ipd === 1'b0 ) && ( CLK0_re == 1 ) && ( ( CLK0_fe == 1 ) || ( CLK0_fe == 2 ) ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= CLK1_re + 2;
        end
      end
    end else if ( driving_clk == 1 ) begin
      GL_zd <= CLK1_ipd;
      if ( S_ipd === 1'b0 ) begin
        if ( ( CLK1_re == 0 ) && ( CLK0_re == 7 ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= 9;
        end else if ( ( CLK1_fe == 0 ) && ( CLK0_re == 15 ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= 17;
        end else if ( ( CLK1_ipd === 1'b0 ) && ( CLK1_re == 1 ) && ( ( CLK1_fe == 1 ) || ( CLK1_fe == 2 ) ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= CLK0_re + 2;
        end
      end
    end else if ( driving_clk == -2 ) begin
      GL_zd <= 1'b0;
    end else begin
      if ( ( S_ipd == 1'b1 ) && ( CLK1_re >= restart_clk_edge ) ) begin
        driving_clk <= 1;
        GL_zd <= CLK1_ipd;
      end else if ( ( S_ipd == 1'b0 ) && ( CLK0_re >= restart_clk_edge ) ) begin
        driving_clk <= 0;
        GL_zd <= CLK0_ipd;
      end else begin
        GL_zd <= 1'b0;
      end
    end
  end

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NGMUXPRIM ----

//---- MODULE NGMUX ----
/*--------------------------------------------------------------------
 CELL NAME : NGMUX
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ps / 1 ps

module NGMUX ( GL, CLK0, CLK1, S );

  input   CLK0;
  input   CLK1;
  input   S;
  output  GL;

  reg     NOTIFY_REG;

  wire    CLK0_ipd;
  wire    CLK1_ipd;
  wire    S_ipd;

  // Add SDF PORT delays
  buf U0 ( CLK0_ipd, CLK0 );
  buf U1 ( CLK1_ipd, CLK1 );
  buf U2 ( S_ipd,    S    );

  // Instantiation of NGMUXPRIM with pure functionality
  NGMUXPRIM NGMUX0 (
    .GL   ( GL ),
    .CLK0 ( CLK0_ipd ),
    .CLK1 ( CLK1_ipd ),
    .S    ( S_ipd )
  );

    specify

      specparam tpdLH_CLK0_to_GL = ( 100 : 100 : 100 );
      specparam tpdHL_CLK0_to_GL = ( 100 : 100 : 100 );
      specparam tpdLH_CLK1_to_GL = ( 100 : 100 : 100 );
      specparam tpdHL_CLK1_to_GL = ( 100 : 100 : 100 );

      //pin to pin path delay 

      ( CLK0 => GL ) = ( tpdLH_CLK0_to_GL, tpdHL_CLK0_to_GL );
      ( CLK1 => GL ) = ( tpdLH_CLK1_to_GL, tpdHL_CLK1_to_GL );

      //checking setup and hold timing for inputs
  
      $setup(negedge S, posedge CLK1, 0.0, NOTIFY_REG);
      $hold(posedge CLK1, negedge S, 0.0, NOTIFY_REG);
      $setup(posedge S, posedge CLK0, 0.0, NOTIFY_REG);
      $hold(posedge CLK0, posedge S, 0.0, NOTIFY_REG);

    endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NGMUX ----

//---- MODULE UNGMUXHW1 ----
/*--------------------------------------------------------------------
 CELL NAME : UNGMUXHW1
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ps / 1 ps

module UNGMUXHW1 ( GL, GLC, CLK0, CLK1, SEL0, SEL1 );

  input   CLK0;
  input   CLK1;
  input   SEL0;
  input   SEL1;
  output  GL;
  output  GLC;

  reg     NOTIFY_REG;

  wire    CLK0_ipd;
  wire    CLK1_ipd;
  wire    SEL0_ipd;

  buf BUF_GLC ( GLC, CLK1_ipd );

  // Add SDF PORT delays
  buf U0 ( CLK0_ipd, CLK0 );
  buf U1 ( CLK1_ipd, CLK1 );
  buf U2 ( SEL0_ipd, SEL0 );
  // SEL1 input is always grounded in back-annotated netlist

  // Instantiation of NGMUXPRIM with pure functionality
  NGMUXPRIM NGMUX0 (
    .GL   ( GL ),
    .CLK0 ( CLK0_ipd ),
    .CLK1 ( CLK1_ipd ),
    .S    ( SEL0_ipd )
  );

    specify

      specparam tpdLH_CLK0_to_GL = ( 100 : 100 : 100 );
      specparam tpdHL_CLK0_to_GL = ( 100 : 100 : 100 );
      specparam tpdLH_CLK1_to_GL = ( 100 : 100 : 100 );
      specparam tpdHL_CLK1_to_GL = ( 100 : 100 : 100 );
      specparam tpdLH_CLK1_to_GLC = ( 100 : 100 : 100 );
      specparam tpdHL_CLK1_to_GLC = ( 100 : 100 : 100 );

      //pin to pin path delay 

      ( CLK0 => GL ) = ( tpdLH_CLK0_to_GL, tpdHL_CLK0_to_GL );
      ( CLK1 => GL ) = ( tpdLH_CLK1_to_GL, tpdHL_CLK1_to_GL );
      ( CLK1 => GLC ) = ( tpdLH_CLK1_to_GLC, tpdHL_CLK1_to_GLC );

      //checking setup and hold timing for inputs
  
      $setup(negedge SEL0, posedge CLK1, 0.0, NOTIFY_REG);
      $hold(posedge CLK1, negedge SEL0, 0.0, NOTIFY_REG);
      $setup(posedge SEL0, posedge CLK0, 0.0, NOTIFY_REG);
      $hold(posedge CLK0, posedge SEL0, 0.0, NOTIFY_REG);

    endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE UNGMUXHW1 ----

//---- MODULE RCOSC ----
/*--------------------------------------------------------------------
 CELL NAME : RCOSC 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module RCOSC 
  (
  CLKOUT
  );

  output CLKOUT;

  reg CLKOUT;

  always
  begin
    forever
    begin
      CLKOUT = 1'b1;
      # 5000;
      CLKOUT = 1'b0;
      # 5000;
    end
  end

endmodule
//---- END MODULE RCOSC ----

//---- MODULE VRPSM ----
/*--------------------------------------------------------------------
 CELL NAME : VRPSM 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module VRPSM ( 
  PUB,
  VRPU,
  VRINITSTATE,
  RTCPSMMATCH,
  FPGAGOOD,
  PUCORE
  );
`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif

  output         PUCORE;
  output         FPGAGOOD;
  input          PUB; 
  input          VRPU;
  input          VRINITSTATE;
  input          RTCPSMMATCH;

  wire           PUB_ipd;
  wire           VRPU_ipd;
  wire           VRINITSTATE_ipd;
  wire           RTCPSMMATCH_ipd;

  reg            VRPU_pd;
  reg            VRPU_prev;
  reg            PUCORE;
  reg            Q1_zd, Q2_zd;
  reg            vrinit_done;

  pmos     U0  ( PUB_ipd , PUB , 1'b0 );
  pmos     U1  ( VRPU_ipd, VRPU, 1'b0 );
  buf      U2  ( VRINITSTATE_ipd, VRINITSTATE );
  buf      U3  ( RTCPSMMATCH_ipd, RTCPSMMATCH );
  not      U4  ( vrinit_doneb, vrinit_done );
  and      U5  ( VRINITSTATE_EN, VRINITSTATE_ipd, vrinit_doneb );
  or       U6  ( RTMMATCH_SET, RTCPSMMATCH_ipd, VRINITSTATE_EN );
  or       U7  ( VRPU_Q1_CLR, VRPU_pd, Q1_zd );
  or       U8  ( FPGAGOOD, Q2_zd, VRPU_Q1_CLR );

  initial
  begin
    Q1_zd        <= 1'b0;  
    Q2_zd        <= 1'b0;
    vrinit_done  <= 1'b0;
    PUCORE       <= 1'b0;
    VRPU_pd      <= 1'b0;
    VRPU_prev    <= 1'b0;
    wait ( FPGAGOOD == 1'b1 )     
      vrinit_done <= 1'b1;
  end

  // INV 1
  always @ ( PUB_ipd )
  begin
    if ( PUB_ipd === 1'bz )
    // PUB pull-up
      PUCORE <= 1'b0;
    else 
      PUCORE <= !PUB_ipd;
  end

  // VRPU pull-down
  always @ ( VRPU_ipd )
  begin
    if ( VRPU_ipd === 1'bz )
      VRPU_pd <= 1'b0;
    else
      VRPU_pd <= VRPU_ipd;
  end
  
  // LATCH 1
  // Clear has priority over Preset
  always @ ( VRPU_pd, RTMMATCH_SET )
  begin
    if ( ( VRPU_prev !== VRPU_pd ) && ( FPGAGOOD == 1'b0 ) )
      begin
                       if ( WARNING_MSGS_ON )
        $display (" ** Warning: VRPU can not be driven high when FPGAGOOD is low");
                       if ( WARNING_MSGS_ON )
        $display (" Time: %0.1f Instance: %m ", $realtime );
      end
    
    if ( VRPU_pd === 1'b1 )
      Q1_zd <= 1'b0;
    else if ( ( RTMMATCH_SET == 1'b1 ) && ( VRPU_pd === 1'b0 ) )
      Q1_zd <= 1'b1;
    else if ( ( VRPU_pd === 1'bx ) && ( Q1_zd == 1'b1 ) )
    // VRPU unknown
      Q1_zd <= 1'bx;
    else if ( ( RTMMATCH_SET == 1'b1 ) && ( VRPU_pd === 1'bx ) && ( Q1_zd == 1'b0 ) )
    // VRPU unknown 
      Q1_zd <= 1'bx;
    else if ( ( RTMMATCH_SET === 1'bx ) && ( VRPU_pd === 1'b0 ) && ( Q1_zd == 1'b0 ) )
    // RTMMATCH_SET unknown
      Q1_zd <= 1'bx;
    else if ( ( RTMMATCH_SET === 1'bx ) && ( VRPU_pd === 1'bx ) )
      Q1_zd <= 1'bx;

    VRPU_prev <= VRPU_pd;

  end

  // LATCH 2
  // Preset has priority over Clear
  always @ ( VRPU_Q1_CLR, PUCORE )
  begin
    if ( PUCORE === 1'b1 )
      Q2_zd <= 1'b1;
    else if ( ( VRPU_Q1_CLR == 1'b1 ) && ( PUCORE === 1'b0 ) )
      Q2_zd <= 1'b0;
    else if ( ( VRPU_Q1_CLR == 1'b1 ) && ( PUCORE === 1'bx ) && ( Q2_zd == 1'b1 ) )
    // PUB unknown
      Q2_zd <= 1'bx;
    else if ( ( PUCORE === 1'bx ) && ( Q2_zd == 1'b0 ) )
    // PUB unknown
      Q2_zd <= 1'bx;
    else if ( ( VRPU_Q1_CLR === 1'bx ) && ( PUCORE === 1'b0 ) && ( Q2_zd == 1'b1 ) ) 
    // VRPU_Q1_CLR unknown
      Q2_zd <= 1'bx;
    else if ( ( VRPU_Q1_CLR === 1'bx ) && ( PUCORE === 1'bx ) )
      Q2_zd <= 1'bx;
  end

  specify

    specparam   LibName     = "fusion";

    // IOPATH delays for output pins

    // IOPATH delay from VRPU, PUB, RTMPSMMATCH to FPGAGOOD

    (PUB         => FPGAGOOD)   = (100.00:100.00:100.00, 100.00:100.00:100.00);
    (VRPU        => FPGAGOOD)   = (100.00:100.00:100.00, 100.00:100.00:100.00);
    (RTCPSMMATCH => FPGAGOOD)   = (100.00:100.00:100.00, 100.00:100.00:100.00);

    // IOPATH delay from VRINITSTATE to FPGAGOOD

    (VRINITSTATE => FPGAGOOD)   = (0.00:0.00:0.00, 0.00:0.00:0.00);

 endspecify

endmodule
//---- END MODULE VRPSM ----

//---- MODULE PLLPRIM ----
/*--------------------------------------------------------------------
 CELL NAME : PLLPRIM
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module PLLPRIM (
         DYNSYNC,
         CLKA,
         EXTFB,
         POWERDOWN,
         CLKB,
         CLKC,
         OADIVRST,
         OADIVHALF,
         OADIV0,
         OADIV1,
         OADIV2,
         OADIV3,
         OADIV4,
         OAMUX0,
         OAMUX1,
         OAMUX2,
         DLYGLA0,
         DLYGLA1,
         DLYGLA2,
         DLYGLA3,
         DLYGLA4,
         OBDIVRST,
         OBDIVHALF,
         OBDIV0,
         OBDIV1,
         OBDIV2,
         OBDIV3,
         OBDIV4,
         OBMUX0,
         OBMUX1,
         OBMUX2,
         DLYYB0,
         DLYYB1,
         DLYYB2,
         DLYYB3,
         DLYYB4,
         DLYGLB0,
         DLYGLB1,
         DLYGLB2,
         DLYGLB3,
         DLYGLB4,
         OCDIVRST,
         OCDIVHALF,
         OCDIV0,
         OCDIV1,
         OCDIV2,
         OCDIV3,
         OCDIV4,
         OCMUX0,
         OCMUX1,
         OCMUX2,
         DLYYC0,
         DLYYC1,
         DLYYC2,
         DLYYC3,
         DLYYC4,
         DLYGLC0,
         DLYGLC1,
         DLYGLC2,
         DLYGLC3,
         DLYGLC4,
         FINDIV0,
         FINDIV1,
         FINDIV2,
         FINDIV3,
         FINDIV4,
         FINDIV5,
         FINDIV6,
         FBDIV0,
         FBDIV1,
         FBDIV2,
         FBDIV3,
         FBDIV4,
         FBDIV5,
         FBDIV6,
         FBDLY0,
         FBDLY1,
         FBDLY2,
         FBDLY3,
         FBDLY4,
         FBSEL0,
         FBSEL1,
         XDLYSEL,
         VCOSEL0,
         VCOSEL1,
         VCOSEL2,
         GLA,
         LOCK,
         GLB,
         YB,
         GLC,
         YC
        );

`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 0; 
`endif
  output GLA, LOCK, GLB, YB, GLC, YC;
  input  VCOSEL2, VCOSEL1, VCOSEL0, XDLYSEL, FBSEL1, FBSEL0; 
  input  FBDLY4, FBDLY3, FBDLY2, FBDLY1, FBDLY0;
  input  FBDIV6, FBDIV5, FBDIV4, FBDIV3;
  input  FBDIV2, FBDIV1, FBDIV0;
  input  FINDIV6, FINDIV5, FINDIV4, FINDIV3, FINDIV2, FINDIV1, FINDIV0;
  input  DLYGLC4, DLYGLC3, DLYGLC2, DLYGLC1, DLYGLC0;
  input  DLYYC4, DLYYC3, DLYYC2, DLYYC1, DLYYC0;
  input  OCMUX2, OCMUX1, OCMUX0, OCDIV4, OCDIV3, OCDIV2, OCDIV1, OCDIV0;
  input  DLYGLB4, DLYGLB3, DLYGLB2, DLYGLB1, DLYGLB0;
  input  DLYYB4, DLYYB3, DLYYB2, DLYYB1, DLYYB0;
  input  OBMUX2, OBMUX1, OBMUX0;
  input  OBDIV4, OBDIV3, OBDIV2, OBDIV1, OBDIV0;
  input  DLYGLA4, DLYGLA3, DLYGLA2, DLYGLA1, DLYGLA0;
  input  OAMUX2, OAMUX1, OAMUX0;
  input  OADIV4, OADIV3, OADIV2, OADIV1, OADIV0;
  input  OADIVHALF;
  input  OADIVRST;
  input  OBDIVHALF;
  input  OBDIVRST;
  input  OCDIVHALF;
  input  OCDIVRST;
  input  POWERDOWN, EXTFB, CLKA;
  input  CLKB;
  input  CLKC;
  input  DYNSYNC;

  parameter       VCOFREQUENCY   = 0.0;
  parameter       f_CLKA_LOCK    = 3;
  parameter       CLKA_TO_REF_DELAY   =  395;
  parameter       EMULATED_SYSTEM_DELAY = 2290;
  parameter       IN_DIV_DELAY   =  335; // Input dividers intrinsic delay
  parameter       OUT_DIV_DELAY  =  770; // Output dividers intrinsic delay
  parameter       MUX_DELAY      = 1200; // MUXA/MUXB/MUXC intrinsic delay
  parameter       IN_DELAY_BYP1  = 1523; // Instrinsic delay for CLKDIVDLY bypass mode
  parameter       BYP_MUX_DELAY  =   40; // Bypass MUX intrinsic delay, not used for Ys
  parameter       GL_DRVR_DELAY  =   60; // Global Driver intrinsic delay
  parameter       Y_DRVR_DELAY   =  285; // Y Driver intrinsic delay
  parameter       FB_MUX_DELAY   =  145; // FBSEL MUX intrinsic delay
  parameter       BYP0_CLK_GL    =  528; // Instrinsic delay for CLKDLY bypass mode
  parameter       X_MUX_DELAY    =  625; // XDLYSEL MUX intrinsic delay
  parameter       FIN_LOCK_DELAY = 300; // FIN to LOCK propagation delay
  parameter       LOCK_OUT_DELAY = 120; // LOCK to OUT propagation delay
  parameter       t_rise = 0;
  parameter       t_fall = 0;
  parameter       PROG_STEP_INCREMENT  = 200;
  parameter       PROG_INIT_DELAY      = 535;

  reg             GLB;
  reg             GLA;
  reg             GLC;
  reg             YB;
  reg             YC;

  reg             AOUT;
  reg             BOUT;
  reg             COUT;
  
  reg             RESET1;
  reg             RESET2;
  reg             RESET3;

  time            PLLDELAY;
  time            PLLCLK_pw;
  time            PLLCLK_period;
  time            DTDELAY;
  time            FBDELAY;
  time            negative_delay;
  time            tmp_delay;
  time            LOCK_re;
  time            UIN_re;
  time            VIN_re;
  time            WIN_re;
  time            UIN_prev_re;
  time            VIN_prev_re;
  time            WIN_prev_re;
  integer         UIN_period;
  integer         VIN_period;
  integer         WIN_period;
  
  //Additional delay value variables for GLA and GLB path

  time            GLBDELAY;
  time            GLADELAY;
  time            GLCDELAY;
  time            YBDELAY;
  time            YCDELAY;

  time            CLKA_period;
  time            CLKA_re;

  reg             PLLCLK;

  reg             halveA;
  reg             halveB;
  reg             halveC;
  reg             CLKA2X;
  reg             CLKB2X;
  reg             CLKC2X;
  time            CLKA2X_CLKA_re;
  time            CLKA2X_CLKA_period;
  time            CLKB2X_CLKB_re;
  time            CLKB2X_CLKB_period;
  time            CLKC2X_CLKC_re;
  time            CLKC2X_CLKC_period;

  wire            UIN;
  wire            VIN;
  wire            WIN;

  integer         DelayVal1;
  integer         DelayVal2;
  integer         DelayVal3;
  integer         DelayVal4;
  integer         DelayVal5;
  integer         DelayVal6;
  integer         i;
  integer         DIVN;
  integer         DIVM;
  integer         DIVU;
  integer         DIVV;
  integer         DIVW;
  integer         fb_loop_div; // Total division of feedback loop
  integer         DivVal;
  integer         DivVal1;
  integer         DivVal2;
  integer         DivVal3;
  integer         DivVal4;
  integer         A_num_edges;
  integer         B_num_edges;
  integer         C_num_edges;
  integer         FBSEL_illegal;
  integer         UIN_num_res;
  integer         UIN_num_fes;
  integer         VIN_num_res;
  integer         VIN_num_fes;
  integer         WIN_num_res;
  integer         WIN_num_fes;

  integer         dlygla_step;
  integer         dlyglb_step;
  integer         dlyglc_step;


  // internal PLL control signal

  wire [4:0] OADIV_ipd;
  wire [4:0] OBDIV_ipd;
  wire [4:0] OCDIV_ipd;
  wire [2:0] OAMUX_ipd;
  wire [2:0] OBMUX_ipd;
  wire [2:0] OCMUX_ipd;
  wire [4:0] DLYGLA_ipd;
  wire [4:0] DLYGLB_ipd;
  wire [4:0] DLYGLC_ipd;
  wire [4:0] DLYYB_ipd;
  wire [4:0] DLYYC_ipd;
  wire [6:0] FINDIV_ipd;
  wire [6:0] FBDIV_ipd;
  wire [4:0] FBDLY_ipd;
  wire [1:0] FBSEL_ipd;
  wire [2:0] VCOSEL_ipd;
  wire       XDLYSEL_ipd;
  wire       CLKA_ipd;
  wire       CLKB_ipd;
  wire       CLKC_ipd;
  wire       POWERDOWN_ipd;
  wire       EXTFB_ipd;
  wire       OADIVHALF_ipd;
  wire       OADIVRST_ipd;
  wire       OBDIVHALF_ipd;
  wire       OBDIVRST_ipd;
  wire       OCDIVHALF_ipd;
  wire       OCDIVRST_ipd;

  integer    res_post_reseta1;
  integer    fes_post_reseta1;
  integer    res_post_reseta0;
  integer    fes_post_reseta0;
  reg        AOUT_CLKA_last_value;
  reg        OADIVRST_ipd_last_value;
  reg        UIN_last_value;
  reg        POWERDOWNA_ipd_last_value;
  reg        forcea_0;
  integer    res_post_resetb1;
  integer    fes_post_resetb1;
  integer    res_post_resetb0;
  integer    fes_post_resetb0;
  reg        BOUT_CLKB_last_value;
  reg        OBDIVRST_ipd_last_value;
  reg        VIN_last_value;
  reg        POWERDOWNB_ipd_last_value;
  reg        forceb_0;
  integer    res_post_resetc1;
  integer    fes_post_resetc1;
  integer    res_post_resetc0;
  integer    fes_post_resetc0;
  reg        COUT_CLKC_last_value;
  reg        OCDIVRST_ipd_last_value;
  reg        WIN_last_value;
  reg        POWERDOWNC_ipd_last_value;
  reg        forcec_0;
  reg        internal_lock;
  time       fin_period;
  reg        locked_fin_last_value;
  time       extfbin_fin_drift;
  time       fin_last_re;
  reg        locked;
  reg        vco0_divu;
  reg        vco0_divv;
  reg        vco0_divw;
  wire       vco180;
  integer    locked_vco_edges;
  integer    CLKA_num_re_stable;
  integer    core_config;
  integer    core_config_last_value;
  reg        CLKA_ipd_last_value;
  time       CLKA_to_VCO0_delay;

  reg        fin;
  reg        CLKA_period_stable;

  wire       using_EXTFB;
  reg        EXTFB_delay_dtrmd;
  reg        calibrate_EXTFB_delay;
  reg        GLA_free_running;
  reg        AOUT_using_EXTFB;
  time       GLA_pw;
  time       GLA_EXTFB_rise_dly;
  time       GLA_EXTFB_fall_dly;
  time       EXTFB_period;
  time       EXTFB_re;
  reg        expected_EXTFB;
  wire       external_dly_correct;

  time       gla_muxed_delay;
  time       glb_muxed_delay;
  time       glc_muxed_delay;

  time       internal_fb_delay;
  time       external_fb_delay;
  time       normalized_fb_delay;

  time       CLKA_2_GLA_dly;
  time       CLKA_2_GLA_bypass0_dly;
  time       CLKA_2_GLA_bypass1_dly;
  time       CLKA_2_GLB_dly;
  time       CLKB_2_GLB_bypass0_dly;
  time       CLKB_2_GLB_bypass1_dly;
  time       CLKA_2_YB_dly;
  time       CLKB_2_YB_bypass1_dly;
  time       CLKA_2_GLC_dly;
  time       CLKC_2_GLC_bypass0_dly;
  time       CLKC_2_GLC_bypass1_dly;
  time       CLKA_2_YC_dly;
  time       CLKC_2_YC_bypass1_dly;
  time       CLKA_2_LOCK_dly;

  integer    fin_num_CLKA_re;
  time       EXTFB_CLKA_edge;
  time       num_freerun_edges;
  reg  [2:0] prev_OAMUX;
  reg  [2:0] prev_OBMUX;
  reg  [2:0] prev_OCMUX;

  function time output_mux_delay;
    input [ 2 : 0 ] outmux;
    input [ 2 : 0]  vcoconfig;
    input time      fbdly_delay;
    input time      vco_pw;
    begin
       case ( outmux )
          1       : output_mux_delay = IN_DELAY_BYP1;
          2       : output_mux_delay = MUX_DELAY + fbdly_delay;
          5       : output_mux_delay = ( ( 1'b1 === vcoconfig[2] ) && ( 1'b1 === vcoconfig[1] ) ) ?
                       MUX_DELAY + ( vco_pw / 2.0 ) :
                       MUX_DELAY + ( vco_pw * 1.5 );
          6       : output_mux_delay = MUX_DELAY + vco_pw;
          7       : output_mux_delay = ( ( 1'b1 === vcoconfig[2] ) && ( 1'b1 === vcoconfig[1] ) ) ?
                       MUX_DELAY + ( vco_pw * 1.5 ) :
                       MUX_DELAY + ( vco_pw / 2.0 );
          default : output_mux_delay = MUX_DELAY;
        endcase
     end
  endfunction


  function output_mux_driver;
    input [ 2 : 0 ] outmux;
    input           halved;
    input           bypass;
    input           bypass2x;
    input           vco;
    begin
       case ( outmux )
             1  : if ( 1'b1 === halved )
                     output_mux_driver = bypass2x;
                  else if ( 1'b0 === halved )
                     output_mux_driver = bypass;
                  else
                     output_mux_driver = 1'bx;
             2  : output_mux_driver = vco;
             4  : output_mux_driver = vco;
             5  : output_mux_driver = vco;
             6  : output_mux_driver = vco;
             7  : output_mux_driver = vco;
        default : output_mux_driver = 1'bx;
     endcase
     end
  endfunction

  // Interconnect Delays

  // The following buf instantiations needed to enable SDF back annotation of 
  // PORT delays

  buf U0 ( CLKA_ipd,      CLKA      );
  buf U1 ( CLKB_ipd,      CLKB      );
  buf U2 ( CLKC_ipd,      CLKC      );
  buf U3 ( POWERDOWN_ipd, POWERDOWN );
  buf U4 ( EXTFB_ipd,     EXTFB     );
  
  assign    # ( t_rise, t_fall ) OADIV_ipd[0]  = OADIV0;
  assign    # ( t_rise, t_fall ) OADIV_ipd[1]  = OADIV1;
  assign    # ( t_rise, t_fall ) OADIV_ipd[2]  = OADIV2;
  assign    # ( t_rise, t_fall ) OADIV_ipd[3]  = OADIV3;
  assign    # ( t_rise, t_fall ) OADIV_ipd[4]  = OADIV4;
  assign    # ( t_rise, t_fall ) OADIVHALF_ipd = OADIVHALF;
  assign    # ( t_rise, t_fall ) OADIVRST_ipd  = OADIVRST;
  assign    # ( t_rise, t_fall ) OAMUX_ipd[0]  = OAMUX0;
  assign    # ( t_rise, t_fall ) OAMUX_ipd[1]  = OAMUX1;
  assign    # ( t_rise, t_fall ) OAMUX_ipd[2]  = OAMUX2;
  assign    # ( t_rise, t_fall ) DLYGLA_ipd[0] = DLYGLA0;
  assign    # ( t_rise, t_fall ) DLYGLA_ipd[1] = DLYGLA1;
  assign    # ( t_rise, t_fall ) DLYGLA_ipd[2] = DLYGLA2;
  assign    # ( t_rise, t_fall ) DLYGLA_ipd[3] = DLYGLA3;
  assign    # ( t_rise, t_fall ) DLYGLA_ipd[4] = DLYGLA4;
  assign    # ( t_rise, t_fall ) OBDIV_ipd[0]  = OBDIV0;
  assign    # ( t_rise, t_fall ) OBDIV_ipd[1]  = OBDIV1;
  assign    # ( t_rise, t_fall ) OBDIV_ipd[2]  = OBDIV2;
  assign    # ( t_rise, t_fall ) OBDIV_ipd[3]  = OBDIV3;
  assign    # ( t_rise, t_fall ) OBDIV_ipd[4]  = OBDIV4;
  assign    # ( t_rise, t_fall ) OBDIVHALF_ipd = OBDIVHALF;
  assign    # ( t_rise, t_fall ) OBDIVRST_ipd  = OBDIVRST;
  assign    # ( t_rise, t_fall ) OBMUX_ipd[0]  = OBMUX0;
  assign    # ( t_rise, t_fall ) OBMUX_ipd[1]  = OBMUX1;
  assign    # ( t_rise, t_fall ) OBMUX_ipd[2]  = OBMUX2;
  assign    # ( t_rise, t_fall ) DLYYB_ipd[0]  = DLYYB0;
  assign    # ( t_rise, t_fall ) DLYYB_ipd[1]  = DLYYB1;
  assign    # ( t_rise, t_fall ) DLYYB_ipd[2]  = DLYYB2;
  assign    # ( t_rise, t_fall ) DLYYB_ipd[3]  = DLYYB3;
  assign    # ( t_rise, t_fall ) DLYYB_ipd[4]  = DLYYB4;
  assign    # ( t_rise, t_fall ) DLYGLB_ipd[0] = DLYGLB0;
  assign    # ( t_rise, t_fall ) DLYGLB_ipd[1] = DLYGLB1;
  assign    # ( t_rise, t_fall ) DLYGLB_ipd[2] = DLYGLB2;
  assign    # ( t_rise, t_fall ) DLYGLB_ipd[3] = DLYGLB3;
  assign    # ( t_rise, t_fall ) DLYGLB_ipd[4] = DLYGLB4;
  assign    # ( t_rise, t_fall ) OCDIV_ipd[0]  = OCDIV0;
  assign    # ( t_rise, t_fall ) OCDIV_ipd[1]  = OCDIV1;
  assign    # ( t_rise, t_fall ) OCDIV_ipd[2]  = OCDIV2;
  assign    # ( t_rise, t_fall ) OCDIV_ipd[3]  = OCDIV3;
  assign    # ( t_rise, t_fall ) OCDIV_ipd[4]  = OCDIV4;
  assign    # ( t_rise, t_fall ) OCDIVHALF_ipd = OCDIVHALF;
  assign    # ( t_rise, t_fall ) OCDIVRST_ipd  = OCDIVRST;
  assign    # ( t_rise, t_fall ) OCMUX_ipd[0]  = OCMUX0;
  assign    # ( t_rise, t_fall ) OCMUX_ipd[1]  = OCMUX1;
  assign    # ( t_rise, t_fall ) OCMUX_ipd[2]  = OCMUX2;
  assign    # ( t_rise, t_fall ) DLYYC_ipd[0]  = DLYYC0;
  assign    # ( t_rise, t_fall ) DLYYC_ipd[1]  = DLYYC1;
  assign    # ( t_rise, t_fall ) DLYYC_ipd[2]  = DLYYC2;
  assign    # ( t_rise, t_fall ) DLYYC_ipd[3]  = DLYYC3;
  assign    # ( t_rise, t_fall ) DLYYC_ipd[4]  = DLYYC4;
  assign    # ( t_rise, t_fall ) DLYGLC_ipd[0] = DLYGLC0;
  assign    # ( t_rise, t_fall ) DLYGLC_ipd[1] = DLYGLC1;
  assign    # ( t_rise, t_fall ) DLYGLC_ipd[2] = DLYGLC2;
  assign    # ( t_rise, t_fall ) DLYGLC_ipd[3] = DLYGLC3;
  assign    # ( t_rise, t_fall ) DLYGLC_ipd[4] = DLYGLC4;
  assign    # ( t_rise, t_fall ) FINDIV_ipd[0] = FINDIV0;
  assign    # ( t_rise, t_fall ) FINDIV_ipd[1] = FINDIV1;
  assign    # ( t_rise, t_fall ) FINDIV_ipd[2] = FINDIV2;
  assign    # ( t_rise, t_fall ) FINDIV_ipd[3] = FINDIV3;
  assign    # ( t_rise, t_fall ) FINDIV_ipd[4] = FINDIV4;
  assign    # ( t_rise, t_fall ) FINDIV_ipd[5] = FINDIV5;
  assign    # ( t_rise, t_fall ) FINDIV_ipd[6] = FINDIV6;
  assign    # ( t_rise, t_fall ) FBDIV_ipd[0]  = FBDIV0;
  assign    # ( t_rise, t_fall ) FBDIV_ipd[1]  = FBDIV1;
  assign    # ( t_rise, t_fall ) FBDIV_ipd[2]  = FBDIV2;
  assign    # ( t_rise, t_fall ) FBDIV_ipd[3]  = FBDIV3;
  assign    # ( t_rise, t_fall ) FBDIV_ipd[4]  = FBDIV4;
  assign    # ( t_rise, t_fall ) FBDIV_ipd[5]  = FBDIV5;
  assign    # ( t_rise, t_fall ) FBDIV_ipd[6]  = FBDIV6;
  assign    # ( t_rise, t_fall ) FBDLY_ipd[0]  = FBDLY0;
  assign    # ( t_rise, t_fall ) FBDLY_ipd[1]  = FBDLY1;
  assign    # ( t_rise, t_fall ) FBDLY_ipd[2]  = FBDLY2;
  assign    # ( t_rise, t_fall ) FBDLY_ipd[3]  = FBDLY3;
  assign    # ( t_rise, t_fall ) FBDLY_ipd[4]  = FBDLY4;
  assign    # ( t_rise, t_fall ) FBSEL_ipd[0]  = FBSEL0;
  assign    # ( t_rise, t_fall ) FBSEL_ipd[1]  = FBSEL1;
  assign    # ( t_rise, t_fall ) XDLYSEL_ipd   = XDLYSEL;
  assign    # ( t_rise, t_fall ) VCOSEL_ipd[0] = VCOSEL0;
  assign    # ( t_rise, t_fall ) VCOSEL_ipd[1] = VCOSEL1;
  assign    # ( t_rise, t_fall ) VCOSEL_ipd[2] = VCOSEL2;

  assign # ( CLKA_2_LOCK_dly, 0 ) LOCK = locked;

  always @ ( fin_period or normalized_fb_delay or gla_muxed_delay or GLADELAY )
  begin
     CLKA_2_GLA_dly         <= CLKA_TO_REF_DELAY + IN_DIV_DELAY + fin_period - normalized_fb_delay + gla_muxed_delay + OUT_DIV_DELAY + BYP_MUX_DELAY + GLADELAY + GL_DRVR_DELAY;
  end

  always @ ( GLADELAY )
  begin
     CLKA_2_GLA_bypass0_dly <= BYP0_CLK_GL + GLADELAY;
  end

  always @ ( gla_muxed_delay, GLADELAY )
  begin
     CLKA_2_GLA_bypass1_dly <= gla_muxed_delay + OUT_DIV_DELAY + BYP_MUX_DELAY + GLADELAY + GL_DRVR_DELAY;
  end

  always @ ( fin_period or normalized_fb_delay or glb_muxed_delay or GLBDELAY )
  begin
     CLKA_2_GLB_dly         <= CLKA_TO_REF_DELAY + IN_DIV_DELAY + fin_period - normalized_fb_delay + glb_muxed_delay + OUT_DIV_DELAY + BYP_MUX_DELAY + GLBDELAY + GL_DRVR_DELAY;
  end

  always @ ( GLBDELAY )
  begin
     CLKB_2_GLB_bypass0_dly <= BYP0_CLK_GL + GLBDELAY;
  end

  always @ ( glb_muxed_delay or GLBDELAY )
  begin
     CLKB_2_GLB_bypass1_dly <= glb_muxed_delay + OUT_DIV_DELAY + BYP_MUX_DELAY + GLBDELAY + GL_DRVR_DELAY;
  end

  always @ ( fin_period or normalized_fb_delay or glb_muxed_delay or YBDELAY )
  begin
     CLKA_2_YB_dly          <= CLKA_TO_REF_DELAY + IN_DIV_DELAY + fin_period - normalized_fb_delay + glb_muxed_delay + OUT_DIV_DELAY + YBDELAY + Y_DRVR_DELAY;
  end

  always @ ( glb_muxed_delay or YBDELAY )
  begin
     CLKB_2_YB_bypass1_dly  <= glb_muxed_delay + OUT_DIV_DELAY + YBDELAY + Y_DRVR_DELAY;
  end

  always @ ( fin_period or normalized_fb_delay or glc_muxed_delay or GLCDELAY )
  begin
     CLKA_2_GLC_dly         <= CLKA_TO_REF_DELAY + IN_DIV_DELAY + fin_period - normalized_fb_delay + glc_muxed_delay + OUT_DIV_DELAY + BYP_MUX_DELAY + GLCDELAY + GL_DRVR_DELAY;
  end

  always @ ( GLCDELAY )
  begin
     CLKC_2_GLC_bypass0_dly <= BYP0_CLK_GL + GLCDELAY;
  end

  always @ ( glc_muxed_delay or GLCDELAY )
  begin
     CLKC_2_GLC_bypass1_dly <= glc_muxed_delay + OUT_DIV_DELAY + BYP_MUX_DELAY + GLCDELAY + GL_DRVR_DELAY;
  end

  always @ ( fin_period or normalized_fb_delay or glc_muxed_delay or YCDELAY )
  begin
     CLKA_2_YC_dly          <= CLKA_TO_REF_DELAY + IN_DIV_DELAY + fin_period - normalized_fb_delay + glc_muxed_delay + OUT_DIV_DELAY + YCDELAY + Y_DRVR_DELAY;
  end

  always @ ( glc_muxed_delay or YCDELAY )
  begin
     CLKC_2_YC_bypass1_dly  <= glc_muxed_delay + OUT_DIV_DELAY + YCDELAY + Y_DRVR_DELAY;
  end

  always @ ( fin_period or normalized_fb_delay )
  begin
     CLKA_2_LOCK_dly        <= CLKA_TO_REF_DELAY + IN_DIV_DELAY + fin_period - normalized_fb_delay + LOCK_OUT_DELAY;
  end

  //
  // Deskew
  //

  always @ ( XDLYSEL_ipd )
  begin

    if ( XDLYSEL_ipd === 1'b1 )
      DTDELAY = EMULATED_SYSTEM_DELAY;
    else
      DTDELAY = 0;

  end

  always @ ( FBDLY_ipd )
  begin
    FBDELAY <= ( FBDLY_ipd * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY;
  end

  always @ ( DLYGLB_ipd )
  begin
    GLBDELAY = ( DLYGLB_ipd == 0 ) ? 0 : ( ( DLYGLB_ipd * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY );
  end

  always @ ( DLYYB_ipd )
  begin
    YBDELAY = ( DLYYB_ipd * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY;
  end

  always @ ( DLYGLC_ipd )
  begin
    GLCDELAY = ( DLYGLC_ipd == 0 ) ? 0 : ( ( DLYGLC_ipd * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY );
  end

  always @ ( DLYYC_ipd )
  begin
    YCDELAY = ( DLYYC_ipd * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY;
  end


  always @ ( DLYGLA_ipd )
  begin
    GLADELAY = ( DLYGLA_ipd == 0 ) ? 0 : ( ( DLYGLA_ipd * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY );
  end

  always @ ( FBDIV_ipd )
  begin
    DIVM = FBDIV_ipd + 1;
  end


  always @ ( FINDIV_ipd )
  begin
    DIVN <= FINDIV_ipd + 1;
  end

  always @ ( OADIV_ipd )
  begin
    DIVU <= OADIV_ipd + 1;
  end

  always @ ( OBDIV_ipd )
  begin
    DIVV <= OBDIV_ipd + 1;
  end

  always @ ( OCDIV_ipd )
  begin
    DIVW <= OCDIV_ipd + 1;
  end

  // Check OADIVHALF
  always @( OADIVHALF_ipd or DIVU or OAMUX_ipd )
  begin
     if ( 1'b1 === OADIVHALF_ipd ) begin
        if ( 3'b001 !== OAMUX_ipd ) begin
                       if ( WARNING_MSGS_ON )
           $display( " ** Warning: Illegal configuration.  OADIVHALF can only be used when OAMUX = 001. OADIVHALF ignored.");
                       if ( WARNING_MSGS_ON )
           $display( " Time: %0.1f Instance: %m ", $realtime );
           halveA <= 1'b0;
        end else if ( ( DIVU < 3 ) || ( DIVU > 29 ) || ( ( DIVU % 2 ) != 1 ) ) begin
                       if ( WARNING_MSGS_ON )
           $display( " ** Warning: Illegal configuration. Only even OADIV values from 2 to 28 (inclusive) are allowed with OADIVHALF." );
                       if ( WARNING_MSGS_ON )
           $display( " Time: %0.1f Instance: %m ", $realtime );
           halveA <= 1'bx;
        end else begin
           halveA <= 1'b1;
        end
     end else if ( 1'bx === OADIVHALF_ipd ) begin
                       if ( WARNING_MSGS_ON )
        $display( " ** Warning: OADIVHALF unknown." );
                       if ( WARNING_MSGS_ON )
        $display( " Time: %0.1f Instance: %m ", $realtime );
        halveA <= 1'bx;
     end else begin
        halveA <= 1'b0;
     end
  end

  // Check OBDIVHALF
  always @( OBDIVHALF_ipd or DIVV or OBMUX_ipd )
  begin
     if ( 1'b1 === OBDIVHALF_ipd ) begin
        if ( 3'b001 !== OBMUX_ipd ) begin
                       if ( WARNING_MSGS_ON )
           $display( " ** Warning: Illegal configuration.  OBDIVHALF can only be used when OBMUX = 001. OBDIVHALF ignored.");
                       if ( WARNING_MSGS_ON )
           $display( " Time: %0.1f Instance: %m ", $realtime );
           halveB <= 1'b0;
        end else if ( ( DIVV < 3 ) || ( DIVV > 29 ) || ( ( DIVV % 2 ) != 1 ) ) begin
                       if ( WARNING_MSGS_ON )
           $display( " ** Warning: Illegal configuration. Only even OBDIV values from 2 to 28 (inclusive) are allowed with OBDIVHALF." );
                       if ( WARNING_MSGS_ON )
           $display( " Time: %0.1f Instance: %m ", $realtime );
           halveB <= 1'bx;
        end else begin
           halveB <= 1'b1;
        end
     end else if ( 1'bx === OBDIVHALF_ipd ) begin
                       if ( WARNING_MSGS_ON )
        $display( " ** Warning: OBDIVHALF unknown." );
                       if ( WARNING_MSGS_ON )
        $display( " Time: %0.1f Instance: %m ", $realtime );
        halveB <= 1'bx;
     end else begin
        halveB <= 1'b0;
     end
  end

  // Check OCDIVHALF
  always @( OCDIVHALF_ipd or DIVW or OCMUX_ipd )
  begin
     if ( 1'b1 === OCDIVHALF_ipd ) begin
        if ( 3'b001 !== OCMUX_ipd ) begin
                       if ( WARNING_MSGS_ON )
           $display( " ** Warning: Illegal configuration.  OCDIVHALF can only be used when OCMUX = 001. OCDIVHALF ignored.");
                       if ( WARNING_MSGS_ON )
           $display( " Time: %0.1f Instance: %m ", $realtime );
           halveC <= 1'b0;
        end else if ( ( DIVW < 3 ) || ( DIVW > 29 ) || ( ( DIVW % 2 ) != 1 ) ) begin
                       if ( WARNING_MSGS_ON )
           $display( " ** Warning: Illegal configuration. Only even OCDIV values from 2 to 28 (inclusive) are allowed with OCDIVHALF." );
                       if ( WARNING_MSGS_ON )
           $display( " Time: %0.1f Instance: %m ", $realtime );
           halveC <= 1'bx;
        end else begin
           halveC <= 1'b1;
        end
     end else if ( 1'bx === OCDIVHALF_ipd ) begin
                       if ( WARNING_MSGS_ON )
        $display( " ** Warning: OCDIVHALF unknown." );
                       if ( WARNING_MSGS_ON )
        $display( " Time: %0.1f Instance: %m ", $realtime );
        halveC <= 1'bx;
     end else begin
        halveC <= 1'b0;
     end
  end

  always @( OAMUX_ipd or VCOSEL_ipd or FBDELAY or PLLCLK_pw )
  begin
     gla_muxed_delay <= output_mux_delay( OAMUX_ipd, VCOSEL_ipd, FBDELAY, PLLCLK_pw );
  end

  always @( OBMUX_ipd or VCOSEL_ipd or FBDELAY or PLLCLK_pw )
  begin
    glb_muxed_delay <= output_mux_delay( OBMUX_ipd, VCOSEL_ipd, FBDELAY, PLLCLK_pw );
  end

  always @( OCMUX_ipd or VCOSEL_ipd or  FBDELAY or PLLCLK_pw )
  begin
     glc_muxed_delay <= output_mux_delay( OCMUX_ipd, VCOSEL_ipd, FBDELAY, PLLCLK_pw );
  end

  // Get internal (not using external feedback pin) feeback delay
  always @( FBSEL_ipd or FBDELAY or DTDELAY or fin_period )
  begin
     if ( 2'b10 === FBSEL_ipd ) begin
        internal_fb_delay <= IN_DIV_DELAY + X_MUX_DELAY + DTDELAY + FB_MUX_DELAY + FBDELAY;
     end else begin
        internal_fb_delay <= IN_DIV_DELAY + X_MUX_DELAY + DTDELAY + FB_MUX_DELAY;
     end
  end

  // Get external (using external feedback pin) feedback delay
  always @( DTDELAY or GLADELAY or gla_muxed_delay or GLA_EXTFB_rise_dly )
  begin
    external_fb_delay <= IN_DIV_DELAY + X_MUX_DELAY + DTDELAY + FB_MUX_DELAY + GL_DRVR_DELAY + GLADELAY + BYP_MUX_DELAY + OUT_DIV_DELAY + gla_muxed_delay + GLA_EXTFB_rise_dly;
  end

  // Normalize appropriate feedback delay
  always @( using_EXTFB or internal_fb_delay or external_fb_delay or fin_period )
  begin
     if ( 0 >= fin_period ) begin
        normalized_fb_delay <= 0;
     end else if ( using_EXTFB === 1'b1 ) begin
        normalized_fb_delay <= ( external_fb_delay > fin_period ) ? ( external_fb_delay % fin_period ) : external_fb_delay;
     end else begin
        normalized_fb_delay <= ( internal_fb_delay > fin_period ) ? ( internal_fb_delay % fin_period ) : internal_fb_delay;
     end
  end

  // Check FBSEL
  always @( FBSEL_ipd or OAMUX_ipd or OBMUX_ipd or OCMUX_ipd or DIVM or DIVU or DIVN or CLKA_period_stable or PLLCLK_period or external_fb_delay )
  begin
     if ( 1'bx === ^FBSEL_ipd ) begin
        FBSEL_illegal <= 1'b1;
                       if ( WARNING_MSGS_ON )
        $display( " ** Warning: FBSEL is unknown." );
                       if ( WARNING_MSGS_ON )
        $display( " Time: %0.1f Instance: %m ", $realtime );
     end else if ( 2'b00 === FBSEL_ipd ) begin // Grounded.
        FBSEL_illegal <= 1'b1;
                       if ( WARNING_MSGS_ON )
        $display( " ** Warning: Illegal FBSEL configuration 00." );
                       if ( WARNING_MSGS_ON )
        $display( " Time: %0.1f Instance: %m ", $realtime );
     end else if ( 2'b11 === FBSEL_ipd ) begin // External feedback
        if ( 2 >  OAMUX_ipd ) begin
           FBSEL_illegal <= 1'b1;
                       if ( WARNING_MSGS_ON )
           $display( " ** Warning: Illegal configuration. GLA cannot be in bypass mode (OAMUX = 000 or OAMUX = 001) when using external feedback (FBSEL = 11)." );
                       if ( WARNING_MSGS_ON )
           $display( " Time: %0.1f Instance: %m ", $realtime );
        end else if ( DIVM < 5 ) begin
           FBSEL_illegal <= 1'b1;
                       if ( WARNING_MSGS_ON )
           $display( " ** Error: FBDIV must be greater than 4 when using external feedback (FBSEL = 11)." );
                       if ( WARNING_MSGS_ON )
           $display( " Time: %0.1f Instance: %m ", $realtime );
        end else if ( ( DIVM * DIVU ) > 232 ) begin
           FBSEL_illegal <= 1'b1;
                       if ( WARNING_MSGS_ON )
           $display( " ** Error: Product of FBDIV and OADIV must be less than 233 when using external feedback (FBSEL = 11)." );
                       if ( WARNING_MSGS_ON )
           $display( " Time: %0.1f Instance: %m ", $realtime );
        end else if ( ( DIVN % DIVU ) != 0 ) begin
           FBSEL_illegal <= 1'b1;
                       if ( WARNING_MSGS_ON )
           $display( " ** Error: Division factor FINDIV must be a multiple of OADIV when using external feedback (FBSEL = 11)." );
                       if ( WARNING_MSGS_ON )
           $display( " Time: %0.1f Instance: %m ", $realtime );
        end else if ( ( 1'b1 === CLKA_period_stable ) && ( 1'b1 === EXTFB_delay_dtrmd ) &&
                ( ( 1 < OBMUX_ipd ) || ( 1 < OCMUX_ipd ) ) &&
                ( ( external_fb_delay >= CLKA_period ) || ( external_fb_delay >= PLLCLK_period ) ) ) begin
           FBSEL_illegal <= 1'b1;
                       if ( WARNING_MSGS_ON )
           $display( " ** Error: Total sum of delays in the feedback path must be less than 1 VCO period AND less than 1 CLKA period when V and/or W dividers when using external feedback (FBSEL = 11)." );
                       if ( WARNING_MSGS_ON )
           $display( " Time: %0.1f Instance: %m ", $realtime );
        end else begin
           FBSEL_illegal <= 1'b0;
        end
     end else begin
        FBSEL_illegal <= 1'b0;
     end
  end

  // Generate fin
  // Mimicing silicon - no need for a 50/50 duty cycle and this way fin only changes on rising edge of CLKA (except when DIVN is 1)
  // Uses prefix fin for registers used locally
  always @( CLKA_ipd )
  begin
     if ( 1'bx === CLKA_ipd ) begin
        fin_num_CLKA_re = -1;
     end else if ( 1 == DIVN ) begin
        fin = CLKA;
     end else if ( 1'b1 === CLKA_ipd ) begin
        fin_num_CLKA_re = fin_num_CLKA_re + 1;
        if ( 0 == ( fin_num_CLKA_re % DIVN  ) ) begin
           fin = 1'b1;
           fin_num_CLKA_re = 0;
        end else if ( 1 == ( fin_num_CLKA_re % DIVN  ) ) begin
           fin = 1'b0;
        end
     end
  end

  always @ ( normalized_fb_delay or DIVN or DIVM )
  begin
    core_config = core_config + 1;
  end

  // Calculate CLKA period and establish internal lock
  always @ ( CLKA_ipd or POWERDOWN_ipd or FBSEL_illegal or core_config or locked_vco_edges or external_dly_correct )
    // locked_vco_edges is in the sensitivity list so that we periodically check for CLKA stopped.
  begin
    if ( ( POWERDOWN_ipd === 1'b1 ) && ( FBSEL_illegal === 1'b0 ) ) begin
      if ( ( core_config != core_config_last_value ) ||
           ( ( 1'b1 === using_EXTFB ) && ( 1'b1 !== external_dly_correct ) ) ) begin
        internal_lock <= 1'b0;
        CLKA_num_re_stable <= -1;
        core_config_last_value <= core_config;
      end
      if ( CLKA_ipd_last_value !== CLKA_ipd ) begin
        CLKA_ipd_last_value <= CLKA_ipd;
        if ( CLKA_ipd === 1'b1 ) begin
          if ( CLKA_period != ( $time - CLKA_re ) ) begin
             CLKA_period <= $time - CLKA_re;
             CLKA_num_re_stable <= -1;
             internal_lock <= 1'b0;
             CLKA_period_stable <= 1'b0;
          end else begin
            if ( f_CLKA_LOCK > CLKA_num_re_stable ) begin
               CLKA_num_re_stable <= CLKA_num_re_stable + 1;
            end else if ( f_CLKA_LOCK == CLKA_num_re_stable ) begin
               internal_lock <= 1'b1;
            end
            CLKA_period_stable <= 1'b1;
          end
          CLKA_re <= $time;
        end
      end else if ( CLKA_period < ( $time - CLKA_re ) ) begin
        CLKA_num_re_stable <= -1;
        internal_lock <= 1'b0;
        CLKA_period_stable <= 1'b0;
      end
    end else begin
      CLKA_num_re_stable <= -1;
      internal_lock <= 1'b0;
      CLKA_period_stable <= 1'b0;
    end
  end

  always @( CLKA_period_stable or CLKA_period or DIVN )
  begin
    if ( CLKA_period_stable) begin
      fin_period <= CLKA_period * ( DIVN * 1.0 );
    end
  end

  always @( PLLCLK_pw or DIVU )
  begin
    GLA_pw <= PLLCLK_pw * ( DIVU * 1.0 );
  end

  always @( GLA_pw or DIVM or fin_period )
  begin
    extfbin_fin_drift <= ( GLA_pw * DIVM * 2.0 ) - fin_period;
  end

  always @( fin_period or fb_loop_div )
  begin
    PLLCLK_period <= fin_period / ( fb_loop_div * 1.0 );
    PLLCLK_pw     <= fin_period / ( fb_loop_div * 2.0 );
  end

  // Calculate feedback loop divider
  always @( DIVM or DIVU or using_EXTFB )
  begin
     if ( 1'b1 === using_EXTFB ) begin
        fb_loop_div <= DIVM * DIVU; 
     end else begin
        fb_loop_div <= DIVM;
     end        
  end 

  // Generated locked
  // Uses prefix locked for internal registers
  always @( fin or internal_lock or DYNSYNC )
  begin
    if ( ( 1'b0 === internal_lock ) || ( 1'b1 === DYNSYNC ) ) begin
      locked <= 1'b0;       
    end else if ( ( 1'b1 === fin ) && ( 1'b0 === locked_fin_last_value ) ) begin
      locked <= 1'b1;
    end
    locked_fin_last_value <= fin;
  end

  // Use vco180 to count locked edges since it will have all edges delayed from locked by uniform PLLCLK_pw.
  // Initial edge count is set to 0 by locked rising (below).
  // Need inertial delay
  assign # PLLCLK_pw vco180 = ( locked === 1'b1 ) ? ~vco180 : 1'b0;

  always @ ( vco180 )
  begin
    if ( ( locked_vco_edges % ( DIVU * DIVV * DIVW * DIVM * 2 ) ) == 0 ) begin
      locked_vco_edges <= 1;
    end else begin
      locked_vco_edges <= locked_vco_edges + 1;
    end
  end

  always @ ( locked )
  begin
    if ( locked === 1'b1 ) begin
      assign locked_vco_edges = 0;
      deassign locked_vco_edges;
    end else begin
      assign locked_vco_edges = -1;
    end
  end

  always @ ( locked_vco_edges )
  begin
    if ( locked_vco_edges == -1 ) begin
       vco0_divu <= 1'b0;
       vco0_divv <= 1'b0;
       vco0_divw <= 1'b0;
    end else begin
       if ( ( locked_vco_edges % DIVU ) == 0 ) begin
         vco0_divu <= ~vco0_divu;
       end
       if ( ( locked_vco_edges % DIVV ) == 0 ) begin
         vco0_divv <= ~vco0_divv;
       end
       if ( ( locked_vco_edges % DIVW ) == 0 ) begin
         vco0_divw <= ~vco0_divw;
       end
    end
  end

  assign UIN = output_mux_driver(  OAMUX_ipd, halveA, CLKA_ipd, CLKA2X, vco0_divu );
  assign VIN = output_mux_driver(  OBMUX_ipd, halveB, CLKB_ipd, CLKB2X, vco0_divv );
  assign WIN = output_mux_driver(  OCMUX_ipd, halveC, CLKC_ipd, CLKC2X, vco0_divw );

  // Generate doubled CLKA
  // Uses prefix CLKA2X for internal registers
  always @( CLKA_ipd )
  begin
    if ( 1'b1 === CLKA_ipd ) begin
      CLKA2X_CLKA_period = $time - CLKA2X_CLKA_re;
      CLKA2X_CLKA_re = $time;
      if ( CLKA2X_CLKA_period > 0 ) begin
        CLKA2X <= 1'b1;
        CLKA2X <= # ( CLKA2X_CLKA_period / 4.0 ) 1'b0;
        CLKA2X <= # ( CLKA2X_CLKA_period / 2.0 ) 1'b1;
        CLKA2X <= # ( CLKA2X_CLKA_period * 3.0 / 4.0 ) 1'b0;
      end
    end
  end

  // Generate doubled CLKB
  // Uses prefix CLKB2X for internal registers
  always @( CLKB_ipd )
  begin
    if ( 1'b1 === CLKB_ipd ) begin
      CLKB2X_CLKB_period = $time - CLKB2X_CLKB_re;
      CLKB2X_CLKB_re = $time;
      if ( CLKB2X_CLKB_period > 0 ) begin
        CLKB2X <= 1'b1;
        CLKB2X <= # ( CLKB2X_CLKB_period / 4.0 ) 1'b0;
        CLKB2X <= # ( CLKB2X_CLKB_period / 2.0 ) 1'b1;
        CLKB2X <= # ( CLKB2X_CLKB_period * 3.0 / 4.0 ) 1'b0;
      end
    end
  end

  // Generate doubled CLKC
  // Uses prefix CLKC2X for internal registers
  always @( CLKC_ipd )
  begin
    if ( 1'b1 === CLKC_ipd ) begin
      CLKC2X_CLKC_period = $time - CLKC2X_CLKC_re;
      CLKC2X_CLKC_re = $time;
      if ( CLKC2X_CLKC_period > 0 ) begin
        CLKC2X <= 1'b1;
        CLKC2X <= # ( CLKC2X_CLKC_period / 4.0 ) 1'b0;
        CLKC2X <= # ( CLKC2X_CLKC_period / 2.0 ) 1'b1;
        CLKC2X <= # ( CLKC2X_CLKC_period * 3.0 / 4.0 ) 1'b0;
      end
    end
  end

  // AOUT Output of Divider U
  always @ ( UIN or CLKA_ipd or POWERDOWN_ipd or OADIVRST_ipd or OADIVHALF_ipd )
  begin
  
    if ( OAMUX_ipd === 3'b001 ) begin
    
      // PLL core bypassed.  OADIVRST active.

      if ( CLKA_ipd !== AOUT_CLKA_last_value ) begin
        if ( ( CLKA_ipd === 1'b1 ) && ( AOUT_CLKA_last_value === 1'b0 ) ) begin
          if ( 4 > res_post_reseta1 ) begin
            res_post_reseta1 = res_post_reseta1 + 1;
          end
          if ( 4 > res_post_reseta0 ) begin
            res_post_reseta0 = res_post_reseta0 + 1;
          end
          if ( res_post_reseta1 == 3 ) begin
            forcea_0 = 1'b0;
            A_num_edges = -1;
          end
        end else if ( ( CLKA_ipd === 1'b0 ) && ( AOUT_CLKA_last_value === 1'b1 ) ) begin
          if ( 4 > fes_post_reseta1 ) begin
            fes_post_reseta1 = fes_post_reseta1 + 1;
          end
          if ( 4 > fes_post_reseta0 ) begin
            fes_post_reseta0 = fes_post_reseta0 + 1;
          end
          if ( fes_post_reseta1 == 1 ) begin
            forcea_0 = 1'b1;
          end
        end
        AOUT_CLKA_last_value = CLKA;
      end

      if ( OADIVRST_ipd !== OADIVRST_ipd_last_value ) begin
        if ( OADIVRST_ipd === 1'b1 ) begin
          if ( ( OADIVRST_ipd_last_value === 1'b0 ) &&
               ( ( res_post_reseta0 < 1 ) || ( fes_post_reseta0 < 1 ) ) ) begin
                       if ( WARNING_MSGS_ON )
            $display( " ** Error: OADIVRST must be held low for at least one CLKA period for the reset operation to work correctly: reset operation may not be successful, edge alignment unpredictable" );
                       if ( WARNING_MSGS_ON )
            $display( " Time: %0.1f Instance: %m ", $realtime );
          end
          res_post_reseta1 = 0;
          fes_post_reseta1 = 0;
        end else if ( OADIVRST_ipd === 1'b0 ) begin
          if ( ( OADIVRST_ipd_last_value === 1'b1 ) &&
               ( ( res_post_reseta1 < 3 ) || ( fes_post_reseta1 < 3 ) ) ) begin
                       if ( WARNING_MSGS_ON )
            $display( " ** Error: OADIVRST must be held high for at least three CLKA periods for the reset operation to work correctly: reset operation may not be succesful, edge alignment unpredictable" );
                       if ( WARNING_MSGS_ON )
            $display( " Time: %0.1f Instance: %m ", $realtime );
          end
          res_post_reseta0 = 0;
          fes_post_reseta0 = 0;
        end else begin
                       if ( WARNING_MSGS_ON )
          $display( " ** Error: OADIVRST is unknown. Edge alignment unpredictable." );
                       if ( WARNING_MSGS_ON )
          $display( " Time: %0.1f Instance: %m ", $realtime );
        end
        OADIVRST_ipd_last_value = OADIVRST_ipd;
      end
  
      if ( UIN !== UIN_last_value ) begin
        A_num_edges = A_num_edges + 1;
        if ( forcea_0 === 1'b1 ) begin
          AOUT <= 1'b0;
        end else if ( UIN === 1'bx ) begin
          AOUT <= 1'bx;
        end else if ( ( A_num_edges % DIVU ) == 0 ) begin
          if ( AOUT === 1'bx ) begin
            AOUT <= UIN;
          end else begin
            AOUT <= !AOUT;
          end
        end
      end

    end else if ( ( UIN !== UIN_last_value ) || ( POWERDOWN_ipd !== POWERDOWNA_ipd_last_value ) ) begin
    // PLL core not bypassed.  OADIVRST inactive.
      if ( POWERDOWN_ipd === 1'b0 ) begin
        AOUT <= 1'b0;
      end else if ( POWERDOWN_ipd === 1'b1 ) begin
         AOUT <= UIN;
      end else begin // POWERDOWN unknown
        AOUT <= 1'bx;
      end
    end

    if ( UIN !== UIN_last_value ) begin
       UIN_last_value = UIN;
    end
    if ( POWERDOWN_ipd !== POWERDOWNA_ipd_last_value ) begin
       POWERDOWNA_ipd_last_value = POWERDOWN_ipd;
    end
  
  end


  //
  // BOUT Output of Divider V
  //

  always @ ( VIN or CLKB_ipd or POWERDOWN_ipd or OBDIVRST_ipd or OBDIVHALF_ipd )
  begin
  
    if ( OBMUX_ipd === 3'b000 ) begin
      BOUT <= 1'bx;
    end else if ( OBMUX_ipd === 3'b001 ) begin
    
      // PLL core bypassed.  OBDIVRST active.
      if ( CLKB_ipd !== BOUT_CLKB_last_value ) begin
        if ( ( CLKB_ipd === 1'b1 ) && ( BOUT_CLKB_last_value === 1'b0 ) ) begin
          if ( 4 > res_post_resetb1 ) begin
            res_post_resetb1 = res_post_resetb1 + 1;
          end
          if ( 4 > res_post_resetb0 ) begin
            res_post_resetb0 = res_post_resetb0 + 1;
          end
          if ( res_post_resetb1 == 3 ) begin
            forceb_0 = 1'b0;
            B_num_edges = -1;
          end
        end else if ( ( CLKB_ipd === 1'b0 ) && ( BOUT_CLKB_last_value === 1'b1 ) ) begin
          if ( 4 > fes_post_resetb1 ) begin
            fes_post_resetb1 = fes_post_resetb1 + 1;
          end
          if ( 4 > fes_post_resetb0 ) begin
            fes_post_resetb0 = fes_post_resetb0 + 1;
          end
          if ( fes_post_resetb1 == 1 ) begin
            forceb_0 = 1'b1;
          end
        end
        BOUT_CLKB_last_value = CLKB_ipd;
      end

      if ( OBDIVRST_ipd !== OBDIVRST_ipd_last_value ) begin
        if ( OBDIVRST_ipd === 1'b1 ) begin
          if ( ( OBDIVRST_ipd_last_value === 1'b0 ) &&
               ( ( res_post_resetb0 < 1 ) || ( fes_post_resetb0 < 1 ) ) ) begin
                       if ( WARNING_MSGS_ON )
            $display( " ** Error: OBDIVRST must be held low for at least one CLKB period for the reset operation to work correctly: reset operation may not be successful, edge alignment unpredictable" );
                       if ( WARNING_MSGS_ON )
            $display( " Time: %0.1f Instance: %m ", $realtime );
          end
          res_post_resetb1 = 0;
          fes_post_resetb1 = 0;
        end else if ( OBDIVRST_ipd === 1'b0 ) begin
          if ( ( OBDIVRST_ipd_last_value === 1'b1 ) &&
               ( ( res_post_resetb1 < 3 ) || ( fes_post_resetb1 < 3 ) ) ) begin
                       if ( WARNING_MSGS_ON )
            $display( " ** Error: OBDIVRST must be held high for at least three CLKB periods for the reset operation to work correctly: reset operation may not be succesful, edge alignment unpredictable" );
                       if ( WARNING_MSGS_ON )
            $display( " Time: %0.1f Instance: %m ", $realtime );
          end
          res_post_resetb0 = 0;
          fes_post_resetb0 = 0;
        end else begin
                       if ( WARNING_MSGS_ON )
          $display( " ** Error: OBDIVRST is unknown. Edge alignment unpredictable." );
                       if ( WARNING_MSGS_ON )
          $display( " Time: %0.1f Instance: %m ", $realtime );
        end
        OBDIVRST_ipd_last_value = OBDIVRST_ipd;
      end

      if ( VIN !== VIN_last_value ) begin
        B_num_edges = B_num_edges + 1;
        if ( forceb_0 === 1'b1 ) begin
          BOUT <= 1'b0;
        end else if ( VIN === 1'bx ) begin
          BOUT <= 1'bx;
        end else if ( ( B_num_edges % DIVV ) == 0 ) begin
          if ( BOUT === 1'bx ) begin
            BOUT <= VIN;
          end else begin
            BOUT <= !BOUT;
          end
        end
      end

    end else if ( ( VIN !== VIN_last_value ) || ( POWERDOWN_ipd !== POWERDOWNB_ipd_last_value ) ) begin
      if ( POWERDOWN_ipd === 1'b0 ) begin
        BOUT <= 1'b0;
      end else if ( POWERDOWN_ipd === 1'b1 ) begin
        BOUT <= VIN;
      end else begin
        BOUT <= 1'bx;
      end
    end

    if ( VIN !== VIN_last_value ) begin
       VIN_last_value = VIN;
    end
    if ( POWERDOWN_ipd !== POWERDOWNB_ipd_last_value ) begin
       POWERDOWNB_ipd_last_value = POWERDOWN_ipd;
    end
    
  end


  //
  // COUT Output of Divider W
  //

  always @ ( WIN or CLKC_ipd or POWERDOWN_ipd or OCDIVRST_ipd or OCDIVHALF_ipd )
  begin
  
    if ( OCMUX_ipd === 3'b000 ) begin
      COUT <= 1'bx;
    end else if ( OCMUX_ipd === 3'b001 ) begin
    
      // PLL core bypassed.  OCDIVRST active.
     if ( CLKC_ipd !== COUT_CLKC_last_value ) begin
        if ( ( CLKC_ipd === 1'b1 ) && ( COUT_CLKC_last_value === 1'b0 ) ) begin
          if ( 4 > res_post_resetc1 ) begin
            res_post_resetc1 = res_post_resetc1 + 1;
          end
          if ( 4 > res_post_resetc0 ) begin
            res_post_resetc0 = res_post_resetc0 + 1;
          end
          if ( res_post_resetc1 == 3 ) begin
            forcec_0 = 1'b0;
            C_num_edges = -1;
          end
        end else if ( ( CLKC_ipd === 1'b0 ) && ( COUT_CLKC_last_value === 1'b1 ) ) begin
          if ( 4 > fes_post_resetc1 ) begin
            fes_post_resetc1 = fes_post_resetc1 + 1;
          end
          if ( 4 > fes_post_resetc0 ) begin
            fes_post_resetc0 = fes_post_resetc0 + 1;
          end
          if ( fes_post_resetc1 == 1 ) begin
            forcec_0 = 1'b1;
          end
        end
        COUT_CLKC_last_value = CLKC_ipd;
      end

      if ( OCDIVRST_ipd !== OCDIVRST_ipd_last_value ) begin
        if ( OCDIVRST_ipd === 1'b1 ) begin
          if ( ( OCDIVRST_ipd_last_value === 1'b0 ) &&
               ( ( res_post_resetc0 < 1 ) || ( fes_post_resetc0 < 1 ) ) ) begin
                       if ( WARNING_MSGS_ON )
            $display( " ** Error: OCDIVRST must be held low for at least one CLKC period for the reset operation to work correctly: reset operation may not be successful, edge alignment unpredictable" );
                       if ( WARNING_MSGS_ON )
            $display( " Time: %0.1f Instance: %m ", $realtime );
          end
          res_post_resetc1 = 0;
          fes_post_resetc1 = 0;
        end else if ( OCDIVRST_ipd === 1'b0 ) begin
          if ( ( OCDIVRST_ipd_last_value === 1'b1 ) &&
               ( ( res_post_resetc1 < 3 ) || ( fes_post_resetc1 < 3 ) ) ) begin
                       if ( WARNING_MSGS_ON )
            $display( " ** Error: OCDIVRST must be held high for at least three CLKC periods for the reset operation to work correctly: reset operation may not be succesful, edge alignment unpredictable" );
                       if ( WARNING_MSGS_ON )
            $display( " Time: %0.1f Instance: %m ", $realtime );
          end
          res_post_resetc0 = 0;
          fes_post_resetc0 = 0;
        end else begin
                       if ( WARNING_MSGS_ON )
          $display( " ** Error: OCDIVRST is unknown. Edge alignment unpredictable." );
                       if ( WARNING_MSGS_ON )
          $display( " Time: %0.1f Instance: %m ", $realtime );
        end
        OCDIVRST_ipd_last_value = OCDIVRST_ipd;
      end

      if ( WIN !== WIN_last_value ) begin
        C_num_edges = C_num_edges + 1;
        if ( forcec_0 === 1'b1 ) begin
          COUT <= 1'b0;
        end else if ( WIN === 1'bx ) begin
          COUT <= 1'bx;
        end else if ( ( C_num_edges % DIVW ) == 0 ) begin
          if ( COUT === 1'bx ) begin
            COUT <= WIN;
          end else begin
            COUT <= !COUT;
          end
        end
      end

    end else if ( ( WIN !== WIN_last_value ) || ( POWERDOWN_ipd !== POWERDOWNC_ipd_last_value ) ) begin
      if ( POWERDOWN_ipd === 1'b0 ) begin
        COUT <= 1'b0;
      end else if ( POWERDOWN_ipd === 1'b1 ) begin
        COUT <= WIN;
      end else begin
        COUT <= 1'bx;
      end
    end

    if ( WIN !== WIN_last_value ) begin
       WIN_last_value = WIN;
    end
    if ( POWERDOWN_ipd !== POWERDOWNC_ipd_last_value ) begin
       POWERDOWNC_ipd_last_value = POWERDOWN_ipd;
    end
    
  end

  assign using_EXTFB = ( FBSEL_ipd[1] && FBSEL_ipd[0] );

  assign #1 external_dly_correct = expected_EXTFB ^~ EXTFB_ipd;

  // Get EXTFB period, rising edge, and falling edge
  always @( posedge EXTFB_ipd )
  begin
    EXTFB_period <= $time - EXTFB_re;
    EXTFB_re <= $time;
  end

  // Calculate EXTFB delay
  always
  begin
    EXTFB_delay_dtrmd = 1'b0;
    if ( ( 1'b1 !== using_EXTFB ) || ( 1'b1 !== CLKA_period_stable ) ) begin
      wait ( ( 1'b1 === using_EXTFB ) && ( 1'b1 === CLKA_period_stable ) );
    end
    #GLA_EXTFB_rise_dly;
    GLA_EXTFB_fall_dly = 0;
    GLA_EXTFB_rise_dly = 0;
    # ( CLKA_2_GLA_dly * 2 );
    calibrate_EXTFB_delay = 1'b1;
    if ( 1'b1 !== EXTFB_ipd ) begin
      wait ( 1'b1 === EXTFB_ipd );
    end
    @ ( negedge CLKA_ipd );
    EXTFB_CLKA_edge = $time;
    calibrate_EXTFB_delay = 1'b0;
    @ ( negedge EXTFB_ipd );
    GLA_EXTFB_fall_dly = $time - EXTFB_CLKA_edge - CLKA_2_GLA_dly;
    @ ( posedge CLKA_ipd );
    EXTFB_CLKA_edge = $time;
    calibrate_EXTFB_delay = 1'b1;
    @ ( posedge EXTFB_ipd );
    GLA_EXTFB_rise_dly = $time - EXTFB_CLKA_edge - CLKA_2_GLA_dly;
    @ ( posedge CLKA_ipd );
    wait ( 1'b1 === CLKA_period_stable );
    @ ( posedge fin );
    EXTFB_delay_dtrmd = 1'b1;
    @ ( negedge expected_EXTFB );
    if ( 1'b1 !== external_dly_correct ) begin
                       if ( WARNING_MSGS_ON )
      $display( " ** Error: EXTFB must be a simple, time-delayed derivative of GLA. Simulation cannot continue until user-logic is corrected" );
                       if ( WARNING_MSGS_ON )
      $display( " Time: %0.1f Instance: %m ", $realtime );
      $finish;
    end
    wait ( 1'b1 !== external_dly_correct );
  end

  // Generate GLA directly from CLA, includes drift adjustment so everything syncs up when PLL is locked
  always @( GLA_free_running or EXTFB_delay_dtrmd )
  begin
    if ( EXTFB_delay_dtrmd ) begin
      if ( ( num_freerun_edges % ( DIVM * 2 ) ) == 0 ) begin
        GLA_free_running <= # ( GLA_pw - extfbin_fin_drift ) ~GLA_free_running;
        num_freerun_edges <= 0;
      end else begin
        GLA_free_running <= # GLA_pw ~GLA_free_running;
      end
      num_freerun_edges <= num_freerun_edges + 1;
    end else begin
      num_freerun_edges <= 1;
      GLA_free_running <= # GLA_pw 1'b1;
    end
  end

  // Generate AOUT_using_EXTFB
  always @( AOUT or GLA_free_running or calibrate_EXTFB_delay or locked_vco_edges or EXTFB_delay_dtrmd )
  begin
    if ( 0 <= locked_vco_edges ) begin
      AOUT_using_EXTFB <= AOUT;
    end else if ( EXTFB_delay_dtrmd ) begin
      AOUT_using_EXTFB <= GLA_free_running;
    end else begin
      AOUT_using_EXTFB <= calibrate_EXTFB_delay;
    end
  end

  always @( GLA or EXTFB_delay_dtrmd )
  begin
    if ( 1'b1 !== EXTFB_delay_dtrmd ) begin
      expected_EXTFB <= 1'bx;
    end else if ( 1'b1 === GLA ) begin
      expected_EXTFB <= # GLA_EXTFB_rise_dly GLA;
    end else begin
      expected_EXTFB <= # GLA_EXTFB_fall_dly GLA;
    end
  end

  // GLA
  always @ ( AOUT or CLKA_ipd or AOUT_using_EXTFB or OAMUX_ipd )
  begin
    if ( 3'b000 === OAMUX_ipd ) begin
      GLA <= # CLKA_2_GLA_bypass0_dly CLKA_ipd;
      A_num_edges <= -1;
    end else if ( 3'b001 === OAMUX_ipd ) begin
      GLA <= # CLKA_2_GLA_bypass1_dly AOUT;
    end else if ( 3'b011 === OAMUX_ipd ) begin
      GLA <= # CLKA_2_GLA_dly 1'bx;
      if ( OAMUX_ipd !== prev_OAMUX ) begin
                       if ( WARNING_MSGS_ON )
        $display( " ** Warning: Illegal OAMUX configuration 011" );
                       if ( WARNING_MSGS_ON )
        $display( " Time: %0.1f Instance: %m ", $realtime );
      end
    end else if ( 1'b1 === using_EXTFB ) begin
      GLA <= # CLKA_2_GLA_dly AOUT_using_EXTFB;
    end else begin
      GLA <= # CLKA_2_GLA_dly AOUT;
    end
    if ( OAMUX_ipd !== prev_OAMUX ) begin
      prev_OAMUX <= OAMUX_ipd;
    end
  end

  // GLB and YB
  always @ ( BOUT or CLKB_ipd or OBMUX_ipd )
  begin
    if ( 3'b000 === OBMUX_ipd ) begin
      GLB <= # CLKB_2_GLB_bypass0_dly CLKB_ipd;
      YB  <= 1'bx;
      B_num_edges <= -1;
    end else if ( 3'b001 === OBMUX_ipd ) begin
      GLB <= # CLKB_2_GLB_bypass1_dly BOUT;
      YB  <= # CLKB_2_YB_bypass1_dly  BOUT;
    end else if ( 3'b011 === OBMUX_ipd ) begin
      GLB <= # CLKA_2_GLB_dly 1'bx;
      YB  <= # CLKA_2_YB_dly  1'bx;
      if ( OBMUX_ipd !== prev_OBMUX ) begin
                       if ( WARNING_MSGS_ON )
        $display( " ** Warning: Illegal OBMUX configuration 011" );
                       if ( WARNING_MSGS_ON )
        $display( " Time: %0.1f Instance: %m ", $realtime );
      end
    end else begin
      GLB <= # CLKA_2_GLB_dly BOUT;
      YB  <= # CLKA_2_YB_dly  BOUT;
    end
    if ( OBMUX_ipd !== prev_OBMUX ) begin
      prev_OBMUX <= OBMUX_ipd;
    end
  end

  // GLC and YC
  always @ ( COUT or CLKC_ipd or OCMUX_ipd )
  begin
    if ( 3'b000 === OCMUX_ipd ) begin
      GLC <= # CLKC_2_GLC_bypass0_dly CLKC_ipd;
      YC  <= 1'bx;
      C_num_edges <= -1;
    end else if ( 3'b001 === OCMUX_ipd ) begin
      GLC <= # CLKC_2_GLC_bypass1_dly COUT;
      YC  <= # CLKC_2_YC_bypass1_dly  COUT;
    end else if ( 3'b011 === OCMUX_ipd ) begin
      GLC <= # CLKA_2_GLC_dly 1'bx;
      YC  <= # CLKA_2_YC_dly  1'bx;
      if ( OCMUX_ipd !== prev_OCMUX ) begin
                       if ( WARNING_MSGS_ON )
        $display( " ** Warning: Illegal OCMUX configuration 011" );
                       if ( WARNING_MSGS_ON )
        $display( " Time: %0.1f Instance: %m ", $realtime );
      end
    end else begin
      GLC <= # CLKA_2_GLC_dly COUT;
      YC  <= # CLKA_2_YC_dly  COUT;
    end
    if ( OCMUX_ipd !== prev_OCMUX ) begin
      prev_OCMUX <= OCMUX_ipd;
    end
  end

  //
  // Initialization
  //

  initial
  begin
  
    PLLCLK = 1'bx;
    CLKA_re = 0;
    DTDELAY = 0;
    DelayVal1 = 0;
    DelayVal2 = 0;
    DelayVal3 = 0;
    DelayVal4 = 0;
    DelayVal5 = 0;
    DelayVal6 = 0;
    DIVN = 1;
    DIVM = 1;
    DIVU = 1;
    DIVV = 1;
    DIVW = 1;
    FBDELAY = 0;
    YBDELAY = 0;
    YCDELAY = 0;
    GLADELAY = 0;
    GLBDELAY = 0;
    GLCDELAY = 0;
    PLLDELAY = 0;
    DivVal = 0;
    DivVal1 = 0;
    DivVal2 = 0;
    DivVal3 = 0;
    DivVal4 = 0;
    CLKA_period = 0;
    AOUT = 1'bx;
    A_num_edges = -1;
    UIN_num_res = 0;
    UIN_num_fes = 0;
    BOUT = 1'bx;
    B_num_edges = -1;
    VIN_num_res = 0;
    VIN_num_fes = 0;
    COUT = 1'bx;
    C_num_edges = -1;
    WIN_num_res = 0;
    WIN_num_fes = 0;
    FBSEL_illegal = 0;
    UIN_re = 0;
    UIN_prev_re = 0;
    UIN_period = 0;
    VIN_re = 0;
    VIN_prev_re = 0;
    VIN_period = 0;
    WIN_re = 0;
    WIN_prev_re = 0;
    WIN_period = 0;

    RESET1 = 1'b1;
    RESET2 = 1'b1;
    RESET3 = 1'b1;

    res_post_reseta1          = 0;
    fes_post_reseta1          = 0;
    res_post_reseta0          = 0;
    fes_post_reseta0          = 0;
    AOUT_CLKA_last_value      = 1'bx;
    OADIVRST_ipd_last_value   = 1'bx;
    UIN_last_value            = 1'bx;
    POWERDOWNA_ipd_last_value = 1'bx;
    forcea_0                  = 1'b1;
    res_post_resetb1          = 0;
    fes_post_resetb1          = 0;
    res_post_resetb0          = 0;
    fes_post_resetb0          = 0;
    BOUT_CLKB_last_value      = 1'bx;
    OBDIVRST_ipd_last_value   = 1'bx;
    VIN_last_value            = 1'bx;
    POWERDOWNB_ipd_last_value = 1'bx;
    forceb_0                  = 1'b1;
    res_post_resetc1          = 0;
    fes_post_resetc1          = 0;
    res_post_resetc0          = 0;
    fes_post_resetc0          = 0;
    COUT_CLKC_last_value      = 1'bx;
    OCDIVRST_ipd_last_value   = 1'bx;
    WIN_last_value            = 1'bx;
    POWERDOWNC_ipd_last_value = 1'bx;
    forcec_0                  = 1'b1;
    PLLCLK_pw                 = 10000;
    PLLCLK_period             = 10000;
    internal_lock             = 1'b0;
    fin_period                = 0;
    fin_last_re               = 0;
    CLKA_num_re_stable        = -1;
    core_config               = 0;
    core_config_last_value    = -1;
    CLKA_ipd_last_value       = 1'bx;
    CLKA_to_VCO0_delay        = 0;
    locked_vco_edges          = -1;

    halveA                    = 1'bx;
    halveB                    = 1'bx;
    halveC                    = 1'bx;
    CLKA2X                    = 1'bx;
    CLKB2X                    = 1'bx;
    CLKC2X                    = 1'bx;
    CLKA2X_CLKA_re            = 0;
    CLKA2X_CLKA_period        = 0;
    CLKB2X_CLKB_re            = 0;
    CLKB2X_CLKB_period        = 0;
    CLKC2X_CLKC_re            = 0;
    CLKC2X_CLKC_period        = 0;
    fin                       = 1'b0;
    CLKA_period_stable        = 1'b0;
    EXTFB_delay_dtrmd         = 1'b0;
    calibrate_EXTFB_delay     = 1'b0;
    GLA_free_running          = 1'b1;
    AOUT_using_EXTFB          = 1'b1;
    GLA_pw                    = 10000;
    GLA_EXTFB_rise_dly        = 0;
    GLA_EXTFB_fall_dly        = 0;
    EXTFB_period              = 20000;
    EXTFB_re                  = 0;
    expected_EXTFB            = 1'bx;
    gla_muxed_delay           = 0;
    glb_muxed_delay           = 0;
    glc_muxed_delay           = 0;
    internal_fb_delay         = 0;
    external_fb_delay         = 0;
    normalized_fb_delay       = 0;
    CLKA_2_GLA_dly            = 0;
    CLKA_2_GLA_bypass0_dly    = 0;
    CLKA_2_GLA_bypass1_dly    = 0;
    CLKA_2_GLB_dly            = 0;
    CLKB_2_GLB_bypass0_dly    = 0;
    CLKB_2_GLB_bypass1_dly    = 0;
    CLKA_2_YB_dly             = 0;
    CLKB_2_YB_bypass1_dly     = 0;
    CLKA_2_GLC_dly            = 0;
    CLKC_2_GLC_bypass0_dly    = 0;
    CLKC_2_GLC_bypass1_dly    = 0;
    CLKA_2_YC_dly             = 0;
    CLKC_2_YC_bypass1_dly     = 0;
    fin_num_CLKA_re           = -1;
    extfbin_fin_drift         = 0;
    fb_loop_div               = 1;
    locked_fin_last_value     = 1'bx;
    EXTFB_CLKA_edge           = 0;
    num_freerun_edges         = 1;
    prev_OAMUX                = 1'bx;
    prev_OBMUX                = 1'bx;
    prev_OCMUX                = 1'bx;
  end

endmodule
//---- END MODULE PLLPRIM ----

//---- MODULE PLL ----
/*--------------------------------------------------------------------
 CELL NAME : PLL
 
--  9/10/04: Initial version of Fusion Static PLL.
-- 10/12/04: Updated with latest G3 changes.
--  1/31/05: Updated as per G3 PLL spec. rev. 31 updates.
--  2/08/05: Remove OBDIVHALF & OCDIVHALF.  Add OADIVRST.
--  3/10/05: Added VCOFREQUENCY parameter.
--  6/16/05: Use PLLPRIM as the underlying PLL primitive to support DYNPLL.

---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module PLL (
         CLKA,
         EXTFB,
         POWERDOWN,
         OADIVRST,
         OADIVHALF,
         OADIV0,
         OADIV1,
         OADIV2,
         OADIV3,
         OADIV4,
         OAMUX0,
         OAMUX1,
         OAMUX2,
         DLYGLA0,
         DLYGLA1,
         DLYGLA2,
         DLYGLA3,
         DLYGLA4,
         OBDIV0,
         OBDIV1,
         OBDIV2,
         OBDIV3,
         OBDIV4,
         OBMUX0,
         OBMUX1,
         OBMUX2,
         DLYYB0,
         DLYYB1,
         DLYYB2,
         DLYYB3,
         DLYYB4,
         DLYGLB0,
         DLYGLB1,
         DLYGLB2,
         DLYGLB3,
         DLYGLB4,
         OCDIV0,
         OCDIV1,
         OCDIV2,
         OCDIV3,
         OCDIV4,
         OCMUX0,
         OCMUX1,
         OCMUX2,
         DLYYC0,
         DLYYC1,
         DLYYC2,
         DLYYC3,
         DLYYC4,
         DLYGLC0,
         DLYGLC1,
         DLYGLC2,
         DLYGLC3,
         DLYGLC4,
         FINDIV0,
         FINDIV1,
         FINDIV2,
         FINDIV3,
         FINDIV4,
         FINDIV5,
         FINDIV6,
         FBDIV0,
         FBDIV1,
         FBDIV2,
         FBDIV3,
         FBDIV4,
         FBDIV5,
         FBDIV6,
         FBDLY0,
         FBDLY1,
         FBDLY2,
         FBDLY3,
         FBDLY4,
         FBSEL0,
         FBSEL1,
         XDLYSEL,
         VCOSEL0,
         VCOSEL1,
         VCOSEL2,
         GLA,
         LOCK,
         GLB,
         YB,
         GLC,
         YC
        );

  output GLA, LOCK, GLB, YB, GLC, YC;
  input  VCOSEL2, VCOSEL1, VCOSEL0, XDLYSEL, FBSEL1, FBSEL0; 
  input  FBDLY4, FBDLY3, FBDLY2, FBDLY1, FBDLY0;
  input  FBDIV6, FBDIV5, FBDIV4, FBDIV3;
  input  FBDIV2, FBDIV1, FBDIV0;
  input  FINDIV6, FINDIV5, FINDIV4, FINDIV3, FINDIV2, FINDIV1, FINDIV0;
  input  DLYGLC4, DLYGLC3, DLYGLC2, DLYGLC1, DLYGLC0;
  input  DLYYC4, DLYYC3, DLYYC2, DLYYC1, DLYYC0;
  input  OCMUX2, OCMUX1, OCMUX0, OCDIV4, OCDIV3, OCDIV2, OCDIV1, OCDIV0;
  input  DLYGLB4, DLYGLB3, DLYGLB2, DLYGLB1, DLYGLB0;
  input  DLYYB4, DLYYB3, DLYYB2, DLYYB1, DLYYB0;
  input  OBMUX2, OBMUX1, OBMUX0;
  input  OBDIV4, OBDIV3, OBDIV2, OBDIV1, OBDIV0;
  input  DLYGLA4, DLYGLA3, DLYGLA2, DLYGLA1, DLYGLA0;
  input  OAMUX2, OAMUX1, OAMUX0;
  input  OADIV4, OADIV3, OADIV2, OADIV1, OADIV0;
  input  OADIVHALF;
  input  OADIVRST;
  input  POWERDOWN, EXTFB, CLKA;

  parameter       VCOFREQUENCY   = 0.0;
  parameter       f_CLKA_LOCK    = 3;

  supply0 GND;
  wire    unused;
  wire    CLKA_ipd;
  wire    EXTFB_ipd;
  wire    POWERDOWN_ipd;

  buf    U0 ( CLKA_ipd, CLKA );
  buf    U1 ( EXTFB_ipd, EXTFB );
  buf    U2 ( POWERDOWN_ipd, POWERDOWN );

  defparam P1.VCOFREQUENCY = VCOFREQUENCY;
  defparam P1.f_CLKA_LOCK = f_CLKA_LOCK;
  
  PLLPRIM P1   (
                .DYNSYNC ( GND ),
                .CLKA ( CLKA_ipd ),
                .EXTFB ( EXTFB_ipd ),
                .POWERDOWN ( POWERDOWN_ipd ),
                .CLKB ( unused ),
                .CLKC ( unused ),
                .OADIVRST ( OADIVRST ),
                .OADIVHALF ( OADIVHALF ),
                .OADIV0 ( OADIV0 ),
                .OADIV1 ( OADIV1 ),
                .OADIV2 ( OADIV2 ),
                .OADIV3 ( OADIV3 ),
                .OADIV4 ( OADIV4 ),
                .OAMUX0 ( OAMUX0 ),
                .OAMUX1 ( OAMUX1 ),
                .OAMUX2 ( OAMUX2 ),
                .DLYGLA0 ( DLYGLA0 ),
                .DLYGLA1 ( DLYGLA1 ),
                .DLYGLA2 ( DLYGLA2 ),
                .DLYGLA3 ( DLYGLA3 ),
                .DLYGLA4 ( DLYGLA4 ),
                .OBDIVRST ( GND ),
                .OBDIVHALF ( GND ),
                .OBDIV0 ( OBDIV0 ),
                .OBDIV1 ( OBDIV1 ),
                .OBDIV2 ( OBDIV2 ),
                .OBDIV3 ( OBDIV3 ),
                .OBDIV4 ( OBDIV4 ),
                .OBMUX0 ( OBMUX0 ),
                .OBMUX1 ( OBMUX1 ),
                .OBMUX2 ( OBMUX2 ),
                .DLYYB0 ( DLYYB0 ),
                .DLYYB1 ( DLYYB1 ),
                .DLYYB2 ( DLYYB2 ),
                .DLYYB3 ( DLYYB3 ),
                .DLYYB4 ( DLYYB4 ),
                .DLYGLB0 ( DLYGLB0 ),
                .DLYGLB1 ( DLYGLB1 ),
                .DLYGLB2 ( DLYGLB2 ),
                .DLYGLB3 ( DLYGLB3 ),
                .DLYGLB4 ( DLYGLB4 ),
                .OCDIVRST ( GND ),
                .OCDIVHALF ( GND ),
                .OCDIV0 ( OCDIV0 ),
                .OCDIV1 ( OCDIV1 ),
                .OCDIV2 ( OCDIV2 ),
                .OCDIV3 ( OCDIV3 ),
                .OCDIV4 ( OCDIV4 ),
                .OCMUX0 ( OCMUX0 ),
                .OCMUX1 ( OCMUX1 ),
                .OCMUX2 ( OCMUX2 ),
                .DLYYC0 ( DLYYC0 ),
                .DLYYC1 ( DLYYC1 ),
                .DLYYC2 ( DLYYC2 ),
                .DLYYC3 ( DLYYC3 ),
                .DLYYC4 ( DLYYC4 ),
                .DLYGLC0 ( DLYGLC0 ),
                .DLYGLC1 ( DLYGLC1 ),
                .DLYGLC2 ( DLYGLC2 ),
                .DLYGLC3 ( DLYGLC3 ),
                .DLYGLC4 ( DLYGLC4 ),
                .FINDIV0 ( FINDIV0 ),
                .FINDIV1 ( FINDIV1 ),
                .FINDIV2 ( FINDIV2 ),
                .FINDIV3 ( FINDIV3 ),
                .FINDIV4 ( FINDIV4 ),
                .FINDIV5 ( FINDIV5 ),
                .FINDIV6 ( FINDIV6 ),
                .FBDIV0 ( FBDIV0 ),
                .FBDIV1 ( FBDIV1 ),
                .FBDIV2 ( FBDIV2 ),
                .FBDIV3 ( FBDIV3 ),
                .FBDIV4 ( FBDIV4 ),
                .FBDIV5 ( FBDIV5 ),
                .FBDIV6 ( FBDIV6 ),
                .FBDLY0 ( FBDLY0 ),
                .FBDLY1 ( FBDLY1 ),
                .FBDLY2 ( FBDLY2 ),
                .FBDLY3 ( FBDLY3 ),
                .FBDLY4 ( FBDLY4 ),
                .FBSEL0 ( FBSEL0 ),
                .FBSEL1 ( FBSEL1 ),
                .XDLYSEL ( XDLYSEL ),
                .VCOSEL0 ( VCOSEL0 ),
                .VCOSEL1 ( VCOSEL1 ),
                .VCOSEL2 ( VCOSEL2 ),
                .GLA ( GLA ),
                .LOCK ( LOCK ),
                .GLB ( GLB ),
                .YB ( YB ),
                .GLC ( GLC ),
                .YC ( YC )
             );

 specify

    // Timing paths for PLL related signals

    (CLKA      => GLA)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLA)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => GLA)  = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => GLB)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLB)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => GLB)  = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => GLC)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLC)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => GLC)  = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => YB)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => YB)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => YB)   = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => YC)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => YC)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => YC)   = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => LOCK) = (0.00:0.00:0.00, 0.00:0.00:0.00);

 endspecify

endmodule
//---- END MODULE PLL ----

//---- MODULE SHREG ----
//------------------------
// CELL NAME: SHREG
//------------------------

`timescale 1 ps / 1 ps

module SHREG (
              SDOUT,
              SUPDATELATCH,
              SDIN,
              SCLK,
              SSHIFT,	
              SUPDATE	
       	     );

input	SDIN;    // Serial data input.  Applies data to a 88-bit shift register.
input	SCLK;    // Serial Clock signal for the shift register.
input	SSHIFT;  // Serial shift enable signal for the shift register.
input	SUPDATE; // Load data from the shift register into the update latch.
output	SDOUT;   // Serial data output.  Data from LSB of the shift register is shifted out.
output  [ 88 : 0 ] SUPDATELATCH;

reg	[ 88 : 0 ] SH_REG;       // 89-bit shift register
reg	[ 88 : 0 ] SUPDATELATCH; // 89-bit latch
reg	SDOUT;


always @ ( posedge SCLK )
  begin
    if ( SSHIFT ) begin
      // Serial input data enters through the MSB of the shift register 
      SH_REG [ 88 : 0 ] <= { SDIN, SH_REG [ 88 : 1 ] }; 
      // Serial output data comes from the LSB of the shift register
      SDOUT <= SH_REG [ 0 ]; 
      // SDOUT gets the LSB value after one SCLK delay
    end else
      SH_REG [ 88 : 0 ] <= SH_REG [ 88 : 0 ];
  end	


always @ ( SUPDATE or SH_REG )
  begin
    if ( SUPDATE )
      // SUPDATE latch gets SH_REG value with one SCLK delay
      SUPDATELATCH [ 88 : 0 ] <= SH_REG [ 88 : 0 ]; 
    else
      SUPDATELATCH [ 88 : 0 ] <= SUPDATELATCH [ 88 : 0 ];
  end
endmodule
//---- END MODULE SHREG ----

//---- MODULE DYNCCC ----
//------------------------
// CELL NAME: DYNCCC
//------------------------

// Configuration bit string does not include bit 80 (RESET ENABLE), so it is
// actually only 88 bits wide and the upper 8 bits are shifted down (i.e. 
// PC<81> = C<80>, PC<82> = C<81>, etc.
// Configuration bits 71 - 73, 77 - 79, 80 - 82, and 86 - 87 not used by model 

`timescale 1 ps / 1 ps

module DYNCCC ( 
		CLKA,
		EXTFB,
		POWERDOWN,
		CLKB,
		CLKC,
		OADIVRST,
		OBDIVRST,
		OCDIVRST,
		SDIN,
		SCLK,
		SSHIFT,
		SUPDATE,
		MODE,
		OADIVHALF,
                OADIV0,
                OADIV1,
                OADIV2,
                OADIV3,
                OADIV4,
                OAMUX0,
                OAMUX1,
                OAMUX2,
                DLYGLA0,
                DLYGLA1,
                DLYGLA2,
                DLYGLA3,
                DLYGLA4,
		OBDIVHALF,
                OBDIV0,
                OBDIV1,
                OBDIV2,
                OBDIV3,
                OBDIV4,
                OBMUX0,
                OBMUX1,
                OBMUX2,
                DLYYB0,
                DLYYB1,
                DLYYB2,
                DLYYB3,
                DLYYB4,
                DLYGLB0,
                DLYGLB1,
                DLYGLB2,
                DLYGLB3,
                DLYGLB4,
		OCDIVHALF,
                OCDIV0,
                OCDIV1,
                OCDIV2,
                OCDIV3,
                OCDIV4,
                OCMUX0,
                OCMUX1,
                OCMUX2,
                DLYYC0,
                DLYYC1,
                DLYYC2,
                DLYYC3,
                DLYYC4,
                DLYGLC0,
                DLYGLC1,
                DLYGLC2,
                DLYGLC3,
                DLYGLC4,
                FINDIV0,
                FINDIV1,
                FINDIV2,
                FINDIV3,
                FINDIV4,
                FINDIV5,
                FINDIV6,
                FBDIV0,
                FBDIV1,
                FBDIV2,
                FBDIV3,
                FBDIV4,
                FBDIV5,
                FBDIV6,
                FBDLY0,
                FBDLY1,
                FBDLY2,
                FBDLY3,
                FBDLY4,
                FBSEL0,
                FBSEL1,
                XDLYSEL,
                VCOSEL0,
                VCOSEL1,
                VCOSEL2,
                GLA,
		LOCK,
		GLB,
		YB,
		GLC,
		YC,
		SDOUT
              );

output GLA;
output LOCK;
output GLB;
output YB;
output GLC;
output YC;
output SDOUT;

input CLKA;
input EXTFB;
input POWERDOWN;
input CLKB;
input CLKC;
input OADIVRST;
input OBDIVRST;
input OCDIVRST;
input SDIN;
input SCLK;
input SSHIFT;
input SUPDATE;
input MODE;
input OADIVHALF;
input OADIV0;
input OADIV1;
input OADIV2;
input OADIV3;
input OADIV4;
input OAMUX0;
input OAMUX1;
input OAMUX2;
input DLYGLA0;
input DLYGLA1;
input DLYGLA2;
input DLYGLA3;
input DLYGLA4;
input OBDIVHALF;
input OBDIV0;
input OBDIV1;
input OBDIV2;
input OBDIV3;
input OBDIV4;
input OBMUX0;
input OBMUX1;
input OBMUX2;
input DLYYB0;
input DLYYB1;
input DLYYB2;
input DLYYB3;
input DLYYB4;
input DLYGLB0;
input DLYGLB1;
input DLYGLB2;
input DLYGLB3;
input DLYGLB4;
input OCDIVHALF;
input OCDIV0;
input OCDIV1;
input OCDIV2;
input OCDIV3;
input OCDIV4;
input OCMUX0;
input OCMUX1;
input OCMUX2;
input DLYYC0;
input DLYYC1;
input DLYYC2;
input DLYYC3;
input DLYYC4;
input DLYGLC0;
input DLYGLC1;
input DLYGLC2;
input DLYGLC3;
input DLYGLC4;
input FINDIV0;
input FINDIV1;
input FINDIV2;
input FINDIV3;
input FINDIV4;
input FINDIV5;
input FINDIV6;
input FBDIV0;
input FBDIV1;
input FBDIV2;
input FBDIV3;
input FBDIV4;
input FBDIV5;
input FBDIV6;
input FBDLY0;
input FBDLY1;
input FBDLY2;
input FBDLY3;
input FBDLY4;
input FBSEL0;
input FBSEL1;
input XDLYSEL;
input VCOSEL0;
input VCOSEL1;
input VCOSEL2;

wire [ 87 : 0 ] C;
wire [ 88 : 0 ] SUPDATELATCH;
wire [ 87 : 0 ] PC;
wire SDOUT_int;

wire CLKA_ipd;
wire EXTFB_ipd;
wire POWERDOWN_ipd;
wire CLKB_ipd;
wire CLKC_ipd;
wire OADIVRST_ipd;
wire OBDIVRST_ipd;
wire OCDIVRST_ipd;
wire SDIN_ipd;
wire SCLK_ipd;
wire SSHIFT_ipd;
wire SUPDATE_ipd;
wire MODE_ipd;

// Unused configuration bits
wire GLMUXCFG1;
wire GLMUXCFG0;
wire RXCSEL;
wire RXBSEL;
wire RXASEL;
wire DYNCSEL;
wire DYNBSEL;
wire DYNASEL;
wire STATCSEL;
wire STATBSEL;
wire STATASEL;

reg  NOTIFY_REG;

reg  RESETENA_latched;
reg  DYNSYNC;

  parameter       VCOFREQUENCY = 0.0;
  parameter       f_CLKA_LOCK  = 3;      // Number of CLKA cycles to wait before raising LOCK

  buf SDOUT_BUF     ( SDOUT,         SDOUT_int );

  buf CLKA_BUF      ( CLKA_ipd,           CLKA );
  buf EXTFB_BUF     ( EXTFB_ipd,         EXTFB );
  buf POWERDOWN_BUF ( POWERDOWN_ipd, POWERDOWN );
  buf CLKB_BUF      ( CLKB_ipd,           CLKB );
  buf CLKC_BUF      ( CLKC_ipd,           CLKC );
  buf SDIN_BUF      ( SDIN_ipd,           SDIN );
  buf SCLK_BUF      ( SCLK_ipd,           SCLK );
  buf SSHIFT_BUF    ( SSHIFT_ipd,       SSHIFT );
  buf SUPDATE_BUF   ( SUPDATE_ipd,     SUPDATE );
  buf MODE_BUF      ( MODE_ipd,           MODE );

  buf OADIVRST_BUF  ( OADIVRST_ipd,   OADIVRST );
  buf OBDIVRST_BUF  ( OBDIVRST_ipd,   OBDIVRST );
  buf OCDIVRST_BUF  ( OCDIVRST_ipd,   OCDIVRST );
 

  assign PC [ 87 : 0 ] = { GLMUXCFG1,    // 87
                         GLMUXCFG0,      // 86
                         OCDIVHALF,      // 85
                         OBDIVHALF,      // 84
                         OADIVHALF,      // 83
                         RXCSEL,         // 82
                         RXBSEL,         // 81
                         RXASEL,         // 80
                         DYNCSEL,        // 79
                         DYNBSEL,        // 78
                         DYNASEL,        // 77
                         VCOSEL2,        // 76
                         VCOSEL1,        // 75
                         VCOSEL0,        // 74
                         STATCSEL,       // 73
                         STATBSEL,       // 72
                         STATASEL,       // 71
                         DLYYC4,         // 70
                         DLYYC3,
                         DLYYC2,
                         DLYYC1,
                         DLYYC0,
                         DLYYB4,
                         DLYYB3,
                         DLYYB2,
                         DLYYB1,
                         DLYYB0,
                         DLYGLC4,
                         DLYGLC3,
                         DLYGLC2,
                         DLYGLC1,
                         DLYGLC0,
                         DLYGLB4,
                         DLYGLB3,
                         DLYGLB2,
                         DLYGLB1,
                         DLYGLB0,
                         DLYGLA4,
                         DLYGLA3,
                         DLYGLA2,
                         DLYGLA1,
                         DLYGLA0,
                         XDLYSEL,
                         FBDLY4,
                         FBDLY3,
                         FBDLY2,
                         FBDLY1,
                         FBDLY0,
                         FBSEL1,
                         FBSEL0,
                         OCMUX2,
                         OCMUX1,
                         OCMUX0,
                         OBMUX2,
                         OBMUX1,
                         OBMUX0,
                         OAMUX2,
                         OAMUX1,
                         OAMUX0,
                         OCDIV4,
                         OCDIV3,
                         OCDIV2,
                         OCDIV1,
                         OCDIV0,
                         OBDIV4,
                         OBDIV3,
                         OBDIV2,
                         OBDIV1,
                         OBDIV0,
                         OADIV4,
                         OADIV3,
                         OADIV2,
                         OADIV1,
                         OADIV0,
                         FBDIV6,
                         FBDIV5,
                         FBDIV4,
                         FBDIV3,
                         FBDIV2,
                         FBDIV1,
                         FBDIV0,
                         FINDIV6,
                         FINDIV5,
                         FINDIV4,
                         FINDIV3,
                         FINDIV2,
                         FINDIV1,
                         FINDIV0
                       };


  //Multiplexer functionality

  assign C [ 87 : 0 ] = MODE_ipd ? 
                        { SUPDATELATCH [ 88 : 81 ] , SUPDATELATCH [ 79 : 0 ] } : 
                        PC [ 87 : 0 ];

  //Logic for generating DYNSYNC

  always @ ( SUPDATE_ipd )
  begin

    if ( SUPDATE_ipd == 1'b1 )
    begin
      if ( MODE_ipd == 1'b1 && RESETENA_latched == 1'b1 )
      begin
        DYNSYNC <= 1'b1;
      end
    end
    else if ( SUPDATE_ipd == 1'b0 )
    begin
      DYNSYNC <= 1'b0;
      RESETENA_latched <= SUPDATELATCH [ 80 ];
    end

  end
 

  //instantiating the PLL module


  defparam P1.VCOFREQUENCY = VCOFREQUENCY;
  defparam P1.f_CLKA_LOCK  = f_CLKA_LOCK;


  PLLPRIM   P1 (
                .DYNSYNC   ( DYNSYNC       ),
                .CLKA      ( CLKA_ipd      ),
                .EXTFB     ( EXTFB_ipd     ),
                .POWERDOWN ( POWERDOWN_ipd ),
                .CLKB      ( CLKB_ipd      ),
                .CLKC      ( CLKC_ipd      ),
                .OADIVRST  ( OADIVRST_ipd  ),
                .OBDIVRST  ( OBDIVRST_ipd  ),
                .OCDIVRST  ( OCDIVRST_ipd  ),
                .OADIV0  ( C [ 14 ] ),
                .OADIV1  ( C [ 15 ] ),
                .OADIV2  ( C [ 16 ] ),
                .OADIV3  ( C [ 17 ] ),
                .OADIV4  ( C [ 18 ] ),
                .OAMUX0  ( C [ 29 ] ),
                .OAMUX1  ( C [ 30 ] ),
                .OAMUX2  ( C [ 31 ] ),
                .DLYGLA0 ( C [ 46 ] ),
                .DLYGLA1 ( C [ 47 ] ),
                .DLYGLA2 ( C [ 48 ] ),
                .DLYGLA3 ( C [ 49 ] ),
                .DLYGLA4 ( C [ 50 ] ),
                .OBDIV0  ( C [ 19 ] ),
                .OBDIV1  ( C [ 20 ] ),
                .OBDIV2  ( C [ 21 ] ),
                .OBDIV3  ( C [ 22 ] ),
                .OBDIV4  ( C [ 23 ] ),
                .OBMUX0  ( C [ 32 ] ),
                .OBMUX1  ( C [ 33 ] ),
                .OBMUX2  ( C [ 34 ] ),
                .DLYYB0  ( C [ 61 ] ),
                .DLYYB1  ( C [ 62 ] ),
                .DLYYB2  ( C [ 63 ] ),
                .DLYYB3  ( C [ 64 ] ),
                .DLYYB4  ( C [ 65 ] ),
                .DLYGLB0 ( C [ 51 ] ),
                .DLYGLB1 ( C [ 52 ] ),
                .DLYGLB2 ( C [ 53 ] ),
                .DLYGLB3 ( C [ 54 ] ),
                .DLYGLB4 ( C [ 55 ] ),
                .OCDIV0  ( C [ 24 ] ),
                .OCDIV1  ( C [ 25 ] ),
                .OCDIV2  ( C [ 26 ] ),
                .OCDIV3  ( C [ 27 ] ),
                .OCDIV4  ( C [ 28 ] ),
                .OCMUX0  ( C [ 35 ] ),
                .OCMUX1  ( C [ 36 ] ),
                .OCMUX2  ( C [ 37 ] ),
                .DLYYC0  ( C [ 66 ] ),
                .DLYYC1  ( C [ 67 ] ),
                .DLYYC2  ( C [ 68 ] ),
                .DLYYC3  ( C [ 69 ] ),
                .DLYYC4  ( C [ 70 ] ),
                .DLYGLC0 ( C [ 56 ] ),
                .DLYGLC1 ( C [ 57 ] ),
                .DLYGLC2 ( C [ 58 ] ),
                .DLYGLC3 ( C [ 59 ] ),
                .DLYGLC4 ( C [ 60 ] ),
                .FINDIV0 ( C [  0 ] ),
                .FINDIV1 ( C [  1 ] ),
                .FINDIV2 ( C [  2 ] ),
                .FINDIV3 ( C [  3 ] ),
                .FINDIV4 ( C [  4 ] ),
                .FINDIV5 ( C [  5 ] ),
                .FINDIV6 ( C [  6 ] ),
                .FBDIV0  ( C [  7 ] ),
                .FBDIV1  ( C [  8 ] ),
                .FBDIV2  ( C [  9 ] ),
                .FBDIV3  ( C [ 10 ] ),
                .FBDIV4  ( C [ 11 ] ),
                .FBDIV5  ( C [ 12 ] ),
                .FBDIV6  ( C [ 13 ] ),
                .FBDLY0  ( C [ 40 ] ),
                .FBDLY1  ( C [ 41 ] ),
                .FBDLY2  ( C [ 42 ] ),
                .FBDLY3  ( C [ 43 ] ),
                .FBDLY4  ( C [ 44 ] ),
                .FBSEL0  ( C [ 38 ] ),
                .FBSEL1  ( C [ 39 ] ),
                .XDLYSEL ( C [ 45 ] ),
                .VCOSEL0 ( C [ 74 ] ),
                .VCOSEL1 ( C [ 75 ] ),
                .VCOSEL2 ( C [ 76 ] ),
                .OADIVHALF ( C [ 83 ] ),
                .OBDIVHALF ( C [ 84 ] ),
                .OCDIVHALF ( C [ 85 ] ),
                .GLA     ( GLA  ),
                .LOCK    ( LOCK ),
                .GLB     ( GLB  ),
                .YB      ( YB   ),
                .GLC     ( GLC  ),
                .YC      ( YC   )
               );

  //instantiating the shift register

  SHREG     Sh1 (
                .SDOUT        ( SDOUT_int    ),
                .SUPDATELATCH ( SUPDATELATCH ),
                .SDIN         ( SDIN_ipd     ),
                .SCLK         ( SCLK_ipd     ),
                .SSHIFT       ( SSHIFT_ipd   ),
                .SUPDATE      ( SUPDATE_ipd  )
                );

  specify

    specparam   LibName     = "fusion";

    // Timing paths for PLL related signals

    (CLKA      => GLA)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLA)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => GLA)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (OADIVRST  => GLA)  = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => GLB)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLB)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => GLB)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (OBDIVRST  => GLB)  = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => GLC)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLC)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => GLC)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (OCDIVRST  => GLC)  = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => YB)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => YB)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => YB)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (OBDIVRST  => YB)   = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => YC)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => YC)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => YC)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (OCDIVRST  => YC)   = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => LOCK) = (0.00:0.00:0.00, 0.00:0.00:0.00);

    // Timing paths and timing checks for SHREG related signals

    // IOPATH delay between rising edge of SCLK and SDOUT

    ( posedge SCLK => (SDOUT+:SDOUT) ) =  ( 0.1:0.1:0.1, 0.1:0.1:0.1 );

    // setup and hold checks on SDIN when SSHIFT is active

    $setup( posedge SDIN, posedge SCLK &&& SSHIFT, 0.0, NOTIFY_REG );
    $setup( negedge SDIN, posedge SCLK &&& SSHIFT, 0.0, NOTIFY_REG );
    $hold ( posedge SCLK &&& SSHIFT, posedge SDIN, 0.0, NOTIFY_REG );
    $hold ( posedge SCLK &&& SSHIFT, negedge SDIN, 0.0, NOTIFY_REG );

    // setup and hold checks on SSHIFT

    $setup( posedge SSHIFT, posedge SCLK, 0.0, NOTIFY_REG );
    $setup( negedge SSHIFT, posedge SCLK, 0.0, NOTIFY_REG );
    $hold ( posedge SCLK, posedge SSHIFT, 0.0, NOTIFY_REG );
    $hold ( posedge SCLK, negedge SSHIFT, 0.0, NOTIFY_REG );

    // pulse width check on SUPDATE and SCLK

    $width( posedge SUPDATE, 0.0, 0, NOTIFY_REG );
    $width( negedge SUPDATE, 0.0, 0, NOTIFY_REG );  // is this required??
    $width( posedge SCLK,    0.0, 0, NOTIFY_REG );
    $width( negedge SCLK,    0.0, 0, NOTIFY_REG );

  endspecify

endmodule
//---- END MODULE DYNCCC ----

//---- MODULE CORERAM4K9 ----
/*-----------------------------------------------------------------
 CELL NAME : CORERAM4K9
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 100 ps  / 10 ps

`define DELAY_TWO 2
`define TWRO      16
`define CLK_MIN   16

module CORERAM4K9 (ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5,
               ADDRA4, ADDRA3, ADDRA2, ADDRA1, ADDRA0, DINA8, DINA7, DINA6,
               DINA5, DINA4, DINA3, DINA2, DINA1, DINA0, DOUTA8, DOUTA7,
               DOUTA6, DOUTA5, DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0,
               WIDTHA1, WIDTHA0, PIPEA, WMODEA, BLKA, WENA, CLKA,
               ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5,
               ADDRB4, ADDRB3, ADDRB2, ADDRB1, ADDRB0, DINB8, DINB7, DINB6,
               DINB5, DINB4, DINB3, DINB2, DINB1, DINB0, DOUTB8, DOUTB7,
               DOUTB6, DOUTB5, DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0,
               WIDTHB1, WIDTHB0, PIPEB, WMODEB, BLKB, WENB, CLKB, RESET
              );

input ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5, ADDRA4, ADDRA3, ADDRA2, ADDRA1, ADDRA0;
input DINA8, DINA7, DINA6, DINA5, DINA4, DINA3, DINA2, DINA1, DINA0;
input WIDTHA1, WIDTHA0, PIPEA, WMODEA, BLKA, WENA, CLKA;
input ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5, ADDRB4, ADDRB3, ADDRB2, ADDRB1, ADDRB0;
input DINB8, DINB7, DINB6, DINB5, DINB4, DINB3, DINB2, DINB1, DINB0;
input WIDTHB1, WIDTHB0, PIPEB, WMODEB, BLKB, WENB, CLKB, RESET;

output DOUTA8, DOUTA7, DOUTA6, DOUTA5, DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0;
output DOUTB8, DOUTB7, DOUTB6, DOUTB5, DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0; 


reg DOUTAP8, DOUTAP7, DOUTAP6, DOUTAP5, DOUTAP4, DOUTAP3, DOUTAP2, DOUTAP1, DOUTAP0;
reg DOUTBP8, DOUTBP7, DOUTBP6, DOUTBP5, DOUTBP4, DOUTBP3, DOUTBP2, DOUTBP1, DOUTBP0;

reg DOUTAP8_stg1, DOUTAP7_stg1, DOUTAP6_stg1, DOUTAP5_stg1, DOUTAP4_stg1, DOUTAP3_stg1, DOUTAP2_stg1, DOUTAP1_stg1, DOUTAP0_stg1;
reg DOUTBP8_stg1, DOUTBP7_stg1, DOUTBP6_stg1, DOUTBP5_stg1, DOUTBP4_stg1, DOUTBP3_stg1, DOUTBP2_stg1, DOUTBP1_stg1, DOUTBP0_stg1;

wire CLKA_int, CLKB_int;
wire WENA_int, WENB_int, WMODEA_int, WMODEB_int;
wire BLKA_int, BLKB_int, RESET_int,  PIPEA_int, PIPEB_int;

wire ADDRA11_int, ADDRA10_int, ADDRA9_int, ADDRA8_int, ADDRA7_int, ADDRA6_int, ADDRA5_int, ADDRA4_int;
wire ADDRA3_int, ADDRA2_int, ADDRA1_int, ADDRA0_int;

wire ADDRB11_int, ADDRB10_int, ADDRB9_int, ADDRB8_int, ADDRB7_int, ADDRB6_int, ADDRB5_int, ADDRB4_int;
wire ADDRB3_int, ADDRB2_int, ADDRB1_int, ADDRB0_int;

wire DINA8_int, DINA7_int, DINA6_int, DINA5_int, DINA4_int, DINA3_int, DINA2_int, DINA1_int, DINA0_int;
wire DINB8_int, DINB7_int, DINB6_int, DINB5_int, DINB4_int, DINB3_int, DINB2_int, DINB1_int, DINB0_int;

reg [8:0] MEM_512_9 [0:511];

reg NOTIFY_REG;

integer ADDRA;            // Address of PORT A
integer ADDRB;            // Address of PORT B
integer DEPTH;
integer MAXADD;

reg ADDRA_VALID;
reg ADDRB_VALID;

time CLKA_wr_re, CLKA_rd_re;
time CLKB_wr_re, CLKB_rd_re;

reg  WENA_lat, WENB_lat;

reg  DINA8_reg, DINA7_reg, DINA6_reg, DINA5_reg, DINA4_reg, DINA3_reg, DINA2_reg, DINA1_reg, DINA0_reg;
reg  DINB8_reg, DINB7_reg, DINB6_reg, DINB5_reg, DINB4_reg, DINB3_reg, DINB2_reg, DINB1_reg, DINB0_reg;

reg  DINA8_bypass, DINA7_bypass, DINA6_bypass, DINA5_bypass, DINA4_bypass;
reg  DINA3_bypass, DINA2_bypass, DINA1_bypass, DINA0_bypass;

reg  DINB8_bypass, DINB7_bypass, DINB6_bypass, DINB5_bypass, DINB4_bypass;
reg  DINB3_bypass, DINB2_bypass, DINB1_bypass, DINB0_bypass;

/********************* TEXT MACRO DEFINITIONS ******************/

`define BLKA_WIDTH_CFG {WIDTHA1,WIDTHA0}
`define BLKB_WIDTH_CFG {WIDTHB1,WIDTHB0}

`define BLKA_ADDR          {ADDRA11_int,ADDRA10_int,ADDRA9_int,ADDRA8_int,ADDRA7_int,ADDRA6_int,ADDRA5_int,ADDRA4_int,ADDRA3_int,ADDRA2_int,ADDRA1_int,ADDRA0_int}

`define BLKB_ADDR          {ADDRB11_int,ADDRB10_int,ADDRB9_int,ADDRB8_int,ADDRB7_int,ADDRB6_int,ADDRB5_int,ADDRB4_int,ADDRB3_int,ADDRB2_int,ADDRB1_int,ADDRB0_int}

`define DATA_A_OUT     {DOUTAP8,DOUTAP7,DOUTAP6,DOUTAP5,DOUTAP4,DOUTAP3,DOUTAP2,DOUTAP1,DOUTAP0}
`define DATA_B_OUT     {DOUTBP8,DOUTBP7,DOUTBP6,DOUTBP5,DOUTBP4,DOUTBP3,DOUTBP2,DOUTBP1,DOUTBP0}

`define DATAP_A_OUT    {DOUTAP8_stg1,DOUTAP7_stg1,DOUTAP6_stg1,DOUTAP5_stg1,DOUTAP4_stg1,DOUTAP3_stg1,DOUTAP2_stg1,DOUTAP1_stg1,DOUTAP0_stg1}
`define DATAP_B_OUT    {DOUTBP8_stg1,DOUTBP7_stg1,DOUTBP6_stg1,DOUTBP5_stg1,DOUTBP4_stg1,DOUTBP3_stg1,DOUTBP2_stg1,DOUTBP1_stg1,DOUTBP0_stg1}

`define DATA_A_IN      {DINA8_int,DINA7_int,DINA6_int,DINA5_int,DINA4_int,DINA3_int,DINA2_int,DINA1_int,DINA0_int}
`define DATA_B_IN      {DINB8_int,DINB7_int,DINB6_int,DINB5_int,DINB4_int,DINB3_int,DINB2_int,DINB1_int,DINB0_int}

`define DATA_A_REG     {DINA8_reg,DINA7_reg,DINA6_reg,DINA5_reg,DINA4_reg,DINA3_reg,DINA2_reg,DINA1_reg,DINA0_reg}
`define DATA_B_REG     {DINB8_reg,DINB7_reg,DINB6_reg,DINB5_reg,DINB4_reg,DINB3_reg,DINB2_reg,DINB1_reg,DINB0_reg}

`define DATA_A_BYP     {DINA8_bypass,DINA7_bypass,DINA6_bypass,DINA5_bypass,DINA4_bypass,DINA3_bypass,DINA2_bypass,DINA1_bypass,DINA0_bypass}
`define DATA_B_BYP     {DINB8_bypass,DINB7_bypass,DINB6_bypass,DINB5_bypass,DINB4_bypass,DINB3_bypass,DINB2_bypass,DINB1_bypass,DINB0_bypass}

buf b0(CLKA_int, CLKA);
buf b1(CLKB_int, CLKB);
buf b2(WENA_int, WENA);
buf b3(WENB_int, WENB);

buf b4(DINA0_int, DINA0);
buf b5(DINA1_int, DINA1);
buf b6(DINA2_int, DINA2);
buf b7(DINA3_int, DINA3);
buf b8(DINA4_int, DINA4);
buf b9(DINA5_int, DINA5);
buf b10(DINA6_int, DINA6);
buf b11(DINA7_int, DINA7);
buf b12(DINA8_int, DINA8);


buf b13(DINB0_int, DINB0);
buf b14(DINB1_int, DINB1);
buf b15(DINB2_int, DINB2);
buf b16(DINB3_int, DINB3);
buf b17(DINB4_int, DINB4);
buf b18(DINB5_int, DINB5);
buf b19(DINB6_int, DINB6);
buf b20(DINB7_int, DINB7);
buf b21(DINB8_int, DINB8);

buf b22(ADDRA0_int, ADDRA0);
buf b23(ADDRA1_int, ADDRA1);
buf b24(ADDRA2_int, ADDRA2);
buf b25(ADDRA3_int, ADDRA3);
buf b26(ADDRA4_int, ADDRA4);
buf b27(ADDRA5_int, ADDRA5);
buf b28(ADDRA6_int, ADDRA6);
buf b29(ADDRA7_int, ADDRA7);
buf b30(ADDRA8_int, ADDRA8);
buf b31(ADDRA9_int, ADDRA9);
buf b32(ADDRA10_int, ADDRA10);
buf b33(ADDRA11_int, ADDRA11);

buf b34(ADDRB0_int, ADDRB0);
buf b35(ADDRB1_int, ADDRB1);
buf b36(ADDRB2_int, ADDRB2);
buf b37(ADDRB3_int, ADDRB3);
buf b38(ADDRB4_int, ADDRB4);
buf b39(ADDRB5_int, ADDRB5);
buf b40(ADDRB6_int, ADDRB6);
buf b41(ADDRB7_int, ADDRB7);
buf b42(ADDRB8_int, ADDRB8);
buf b43(ADDRB9_int, ADDRB9);
buf b44(ADDRB10_int, ADDRB10);
buf b45(ADDRB11_int, ADDRB11);

buf b46(RESET_int, RESET);
buf b47(BLKA_int, BLKA);
buf b48(BLKB_int, BLKB);
buf b49(PIPEA_int, PIPEA);
buf b50(PIPEB_int, PIPEB);
buf b51(WMODEA_int, WMODEA);
buf b52(WMODEB_int, WMODEB);

pmos inst1(DOUTA0, DOUTAP0, 0);
pmos inst2(DOUTA1, DOUTAP1, 0);
pmos inst3(DOUTA2, DOUTAP2, 0);
pmos inst4(DOUTA3, DOUTAP3, 0);
pmos inst5(DOUTA4, DOUTAP4, 0);
pmos inst6(DOUTA5, DOUTAP5, 0);
pmos inst7(DOUTA6, DOUTAP6, 0);
pmos inst8(DOUTA7, DOUTAP7, 0);
pmos inst9(DOUTA8, DOUTAP8, 0);

pmos inst10(DOUTB0, DOUTBP0, 0);
pmos inst11(DOUTB1, DOUTBP1, 0);
pmos inst12(DOUTB2, DOUTBP2, 0);
pmos inst13(DOUTB3, DOUTBP3, 0);
pmos inst14(DOUTB4, DOUTBP4, 0);
pmos inst15(DOUTB5, DOUTBP5, 0);
pmos inst16(DOUTB6, DOUTBP6, 0);
pmos inst17(DOUTB7, DOUTBP7, 0);
pmos inst18(DOUTB8, DOUTBP8, 0);

parameter DYNAMIC = 1;
parameter MEMORYFILE = "";
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.

  initial
    begin
    
      if ( WARNING_MSGS_ON == 0 )
        $display("Note: RAM4K9 warnings disabled. Set WARNING_MSGS_ON = 1 to enable.");

      if ( MEMORYFILE != "")
        $readmemb ( MEMORYFILE, MEM_512_9 );
      else
        begin
          //if ( WARNING_MSGS_ON == 1 )
            //$display ( "Note: Module %m, memory initialization file parameter MEMORYFILE not defined" );
        end
    end


always @(CLKA_int === 1'bx )
begin
  if ($time > 0) begin
    if (BLKA_int == 1'b0) begin
      if ( WARNING_MSGS_ON == 1 )
                       if ( WARNING_MSGS_ON )
        $display("Warning : CLKA went unknown at time %0.1f\n",$realtime);
    end
  end
end

always @(CLKB_int === 1'bx )
begin
  if ($time > 0) begin
    if (BLKB_int == 1'b0) begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning : CLKB went unknown at time %0.1f\n",$realtime);
    end
  end
end

always @(RESET_int === 1'b0 )
begin

       if (PIPEA_int == 1'b0) begin 
        case (`BLKA_WIDTH_CFG)
            2'b00 : DOUTAP0 = 1'b0;
            2'b01 : begin
                    DOUTAP0 = 1'b0;
                    DOUTAP1 = 1'b0;
                end
            2'b10 : begin
                    DOUTAP0= 1'b0;
                    DOUTAP1 = 1'b0;
                    DOUTAP2 = 1'b0;
                    DOUTAP3 = 1'b0;
                end
            2'b11 : begin
                    DOUTAP0 = 1'b0;
                    DOUTAP1 = 1'b0;
                    DOUTAP2 = 1'b0;
                    DOUTAP3 = 1'b0;
                    DOUTAP4 = 1'b0;
                    DOUTAP5 = 1'b0;
                    DOUTAP6 = 1'b0;
                    DOUTAP7 = 1'b0;
                    DOUTAP8 = 1'b0;
                 end
             default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
               end
         endcase
       end else if (PIPEA_int == 1'b1) begin
          case (`BLKA_WIDTH_CFG)
            2'b00 : begin
                     DOUTAP0      = 1'b0;
                     DOUTAP0_stg1 = 1'b0;
                    end
            2'b01 : begin
                    DOUTAP0 = 1'b0;
                    DOUTAP1 = 1'b0;
                    DOUTAP0_stg1 = 1'b0;
                    DOUTAP1_stg1 = 1'b0;
                end
            2'b10 : begin
                    DOUTAP0= 1'b0;
                    DOUTAP1 = 1'b0;
                    DOUTAP2 = 1'b0;
                    DOUTAP3 = 1'b0;
                    DOUTAP0_stg1= 1'b0;
                    DOUTAP1_stg1 = 1'b0;
                    DOUTAP2_stg1 = 1'b0;
                    DOUTAP3_stg1 = 1'b0;
                end
            2'b11 : begin
                    DOUTAP0 = 1'b0;
                    DOUTAP1 = 1'b0;
                    DOUTAP2 = 1'b0;
                    DOUTAP3 = 1'b0;
                    DOUTAP4 = 1'b0;
                    DOUTAP5 = 1'b0;
                    DOUTAP6 = 1'b0;
                    DOUTAP7 = 1'b0;
                    DOUTAP8 = 1'b0;
                    DOUTAP0_stg1 = 1'b0;
                    DOUTAP1_stg1 = 1'b0;
                    DOUTAP2_stg1 = 1'b0;
                    DOUTAP3_stg1 = 1'b0;
                    DOUTAP4_stg1 = 1'b0;
                    DOUTAP5_stg1 = 1'b0;
                    DOUTAP6_stg1 = 1'b0;
                    DOUTAP7_stg1 = 1'b0;
                    DOUTAP8_stg1 = 1'b0;

                 end
             default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
               end
         endcase
       end

       if (PIPEB_int == 1'b0) begin  
        case (`BLKB_WIDTH_CFG)
            2'b00 : DOUTBP0 = 1'b0;
            2'b01 : begin
                    DOUTBP0 = 1'b0;
                    DOUTBP1 = 1'b0;
                end
            2'b10 : begin
                    DOUTBP0= 1'b0;
                    DOUTBP1 = 1'b0;
                    DOUTBP2 = 1'b0;
                    DOUTBP3 = 1'b0;
                end
            2'b11 : begin
                    DOUTBP0 = 1'b0;
                    DOUTBP1 = 1'b0;
                    DOUTBP2 = 1'b0;
                    DOUTBP3 = 1'b0;
                    DOUTBP4 = 1'b0;
                    DOUTBP5 = 1'b0;
                    DOUTBP6 = 1'b0;
                    DOUTBP7 = 1'b0;
                    DOUTBP8 = 1'b0;
                 end
             default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
               end
         endcase

       end else if (PIPEB_int == 1'b1) begin
           case (`BLKB_WIDTH_CFG)
            2'b00 : begin
                    DOUTBP0 = 1'b0;
                    DOUTBP0_stg1 = 1'b0;
                    end
            2'b01 : begin
                    DOUTBP0 = 1'b0;
                    DOUTBP1 = 1'b0;
                    DOUTBP0_stg1 = 1'b0;
                    DOUTBP1_stg1 = 1'b0;

                end
            2'b10 : begin
                    DOUTBP0= 1'b0;
                    DOUTBP1 = 1'b0;
                    DOUTBP2 = 1'b0;
                    DOUTBP3 = 1'b0;
                    DOUTBP0_stg1= 1'b0;
                    DOUTBP1_stg1 = 1'b0;
                    DOUTBP2_stg1 = 1'b0;
                    DOUTBP3_stg1 = 1'b0;

                end
            2'b11 : begin
                    DOUTBP0 = 1'b0;
                    DOUTBP1 = 1'b0;
                    DOUTBP2 = 1'b0;
                    DOUTBP3 = 1'b0;
                    DOUTBP4 = 1'b0;
                    DOUTBP5 = 1'b0;
                    DOUTBP6 = 1'b0;
                    DOUTBP7 = 1'b0;
                    DOUTBP8 = 1'b0;
                    DOUTBP0_stg1 = 1'b0;
                    DOUTBP1_stg1 = 1'b0;
                    DOUTBP2_stg1 = 1'b0;
                    DOUTBP3_stg1 = 1'b0;
                    DOUTBP4_stg1 = 1'b0;
                    DOUTBP5_stg1 = 1'b0;
                    DOUTBP6_stg1 = 1'b0;
                    DOUTBP7_stg1 = 1'b0;
                    DOUTBP8_stg1 = 1'b0;

                 end
             default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
               end
         endcase
     end

  end // Reset

// start the RAM BLKA write/read  behavior section
//

always @(posedge CLKA_int) begin
    // Write mode

  if (PIPEA_int == 1'b1) begin
    case (`BLKA_WIDTH_CFG)
      2'b00 : begin 
               DOUTAP0 = DOUTAP0_stg1;
              end
      2'b01 : begin
               DOUTAP0 = DOUTAP0_stg1;
               DOUTAP1 = DOUTAP1_stg1;
              end
      2'b10 : begin
               DOUTAP0 = DOUTAP0_stg1;
               DOUTAP1 = DOUTAP1_stg1;
               DOUTAP2 = DOUTAP2_stg1;
               DOUTAP3 = DOUTAP3_stg1;
              end
      2'b11 : begin
               DOUTAP0 = DOUTAP0_stg1;
               DOUTAP1 = DOUTAP1_stg1;
               DOUTAP2 = DOUTAP2_stg1;
               DOUTAP3 = DOUTAP3_stg1;
               DOUTAP4 = DOUTAP4_stg1;
               DOUTAP5 = DOUTAP5_stg1;
               DOUTAP6 = DOUTAP6_stg1;
               DOUTAP7 = DOUTAP7_stg1;
               DOUTAP8 = DOUTAP8_stg1;
             end
      default:
              begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
              end
    endcase
  end
  else if (PIPEA_int == 1'bx) begin
    if ( WARNING_MSGS_ON == 1 )
      $display ("Warning: PIPEA unknown at time %d ns, no data was read.", $time);
    DOUTAP0 = 1'bx;
    DOUTAP1 = 1'bx;
    DOUTAP2 = 1'bx;
    DOUTAP3 = 1'bx;
    DOUTAP4 = 1'bx;
    DOUTAP5 = 1'bx;
    DOUTAP6 = 1'bx;
    DOUTAP7 = 1'bx;
    DOUTAP8 = 1'bx;
  end

  if ((BLKA_int == 1'b0) && (RESET_int == 1'b1)) begin

    WENA_lat = WENA_int;

    ADDRA = get_address(`BLKA_ADDR, `BLKA_WIDTH_CFG);   // get the address (read or write ) 
    ADDRA_VALID = 1;

    if ( DYNAMIC == 1 ) begin
      ADDRA = ADDRA >> `BLKA_WIDTH_CFG;
    end

    if ((^ADDRA) === 1'bx) begin
      ADDRA_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f!", $realtime);
    end
    else if ((`BLKA_WIDTH_CFG == 2'b00) && (ADDRA > 4095)) begin
      ADDRA_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f!", $realtime);
    end
    else if ((`BLKA_WIDTH_CFG == 2'b01) && (ADDRA > 2047)) begin
      ADDRA_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f!", $realtime);
    end
    else if ((`BLKA_WIDTH_CFG == 2'b10) && (ADDRA > 1023)) begin
      ADDRA_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f!", $realtime);
    end
    else if ((`BLKA_WIDTH_CFG == 2'b11) && (ADDRA > 511)) begin
      ADDRA_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f!", $realtime);
    end


    if ( (WENA_int == 1'b0) && ADDRA_VALID ) begin 

      CLKA_wr_re = $time;

      // Check if Write from Port B and Write from Port A are to the same address, write data is non-deterministic
      if ( (WENB_lat == 1'b0) && same_addr(ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0} ) &&
                                                            ((CLKB_wr_re + `CLK_MIN) > CLKA_wr_re) ) begin
                       if ( WARNING_MSGS_ON )
        $display (" ** Warning: Port B Write and Port A Write to same address at same time. Write data conflict. Updating memory contents at conflicting address with X"); 
                       if ( WARNING_MSGS_ON )
        $display (" Time: %0.1f Instance: %m ", $realtime );
        // function call to determine conflicting write data bits based on address and width configuration
        `DATA_A_REG = drive_data_x (ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}, `DATA_A_IN);
      end
      else begin
        // assign write data to data registers for writing into the memory array
        `DATA_A_REG = `DATA_A_IN;
      end

      // assign write data to bypass registers for driving onto RD if MODE=1
      `DATA_A_BYP = `DATA_A_IN;

      // Check for Read from Port B and Write from Port A to the same address, read data on Port B is driven to X
      if ( (WENB_lat == 1'b1) && same_addr(ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}) &&
                                                              ((CLKB_rd_re + `CLK_MIN) > CLKA_wr_re) ) begin
                       if ( WARNING_MSGS_ON )
        $display (" ** Warning: Port B Read and Port A Write to same address at same time. Port B read data is unpredictable, driving read data to X");
                       if ( WARNING_MSGS_ON )
        $display (" Time: %0.1f Instance: %m ", $realtime );

        if (PIPEB_int == 1'b1)
          `DATAP_B_OUT = drive_data_x (ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}, `DATAP_B_OUT);
        else if (PIPEB_int == 1'b0)
          `DATA_B_OUT = drive_data_x (ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}, `DATA_B_OUT);
      end

        case (`BLKA_WIDTH_CFG)
            2'b00 : begin

                 MEM_512_9[ ADDRA[11:3] ] [ ADDRA[2:0] ] = DINA0_reg;

                 if (WMODEA_int == 1'b1) begin
                  if (PIPEA_int == 1'b0) begin 
                    DOUTAP0 = DINA0_bypass;
                  end else if (PIPEA_int == 1'b1) begin
                    DOUTAP0_stg1 = DINA0_bypass;
                  end 
                 end

                end

            2'b01 : begin

                 MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 ] = DINA0_reg;
                 MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 + 1 ] = DINA1_reg;

                 if (WMODEA_int == 1'b1) begin
                  if (PIPEA_int == 1'b0) begin
                    DOUTAP0 = DINA0_bypass;
                    DOUTAP1 = DINA1_bypass;
                  end else if (PIPEA_int == 1'b1) begin
                    DOUTAP0_stg1 = DINA0_bypass;
                    DOUTAP1_stg1 = DINA1_bypass;
                  end
                 end

                end
            2'b10 : begin

                 MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 ] = DINA0_reg;
                 MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 1 ] = DINA1_reg;
                 MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 2 ] = DINA2_reg;
                 MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 3 ] = DINA3_reg;
`ifdef FUSION_DEBUG
//                 $display("ram4k9: A write - ADDR = %x, DATA = %x", ADDRA, {DINA3_reg,DINA2_reg,DINA1_reg,DINA0_reg});
`endif

                 if (WMODEA_int == 1'b1) begin
                  if (PIPEA_int == 1'b0) begin
                   DOUTAP0 = DINA0_bypass;
                   DOUTAP1 = DINA1_bypass;
                   DOUTAP2 = DINA2_bypass;
                   DOUTAP3 = DINA3_bypass;
                  end else if (PIPEA_int == 1'b1) begin
                   DOUTAP0_stg1 = DINA0_bypass;
                   DOUTAP1_stg1 = DINA1_bypass;
                   DOUTAP2_stg1 = DINA2_bypass;
                   DOUTAP3_stg1 = DINA3_bypass;
                  end
                 end

                end
            2'b11 : begin

                 MEM_512_9[ ADDRA[8:0] ] = {DINA8_reg,DINA7_reg,DINA6_reg,DINA5_reg,DINA4_reg,DINA3_reg,DINA2_reg,DINA1_reg,DINA0_reg};
                  
                 if (WMODEA_int == 1'b1) begin
                  if (PIPEA_int == 1'b0) begin
                   DOUTAP0 = DINA0_bypass;
                   DOUTAP1 = DINA1_bypass;
                   DOUTAP2 = DINA2_bypass;
                   DOUTAP3 = DINA3_bypass;
                   DOUTAP4 = DINA4_bypass;
                   DOUTAP5 = DINA5_bypass;
                   DOUTAP6 = DINA6_bypass;
                   DOUTAP7 = DINA7_bypass;
                   DOUTAP8 = DINA8_bypass;
                  end else if (PIPEA_int == 1'b1) begin
                   DOUTAP0_stg1 = DINA0_bypass;
                   DOUTAP1_stg1 = DINA1_bypass;
                   DOUTAP2_stg1 = DINA2_bypass;
                   DOUTAP3_stg1 = DINA3_bypass;
                   DOUTAP4_stg1 = DINA4_bypass;
                   DOUTAP5_stg1 = DINA5_bypass;
                   DOUTAP6_stg1 = DINA6_bypass;
                   DOUTAP7_stg1 = DINA7_bypass;
                   DOUTAP8_stg1 = DINA8_bypass;
                  end
                 end

                 end
           default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: Invalid WIDTH configuration at time %d ns. Legal Width: 1, 2, 4, 9.", $time);
               end
         endcase
   end else if ( (WENA_int == 1'b1) && ADDRA_VALID ) begin // Read mode

        CLKA_rd_re = $time;

        if (PIPEA_int == 1'b0) begin
        case (`BLKA_WIDTH_CFG)
            2'b00 : begin 
                    DOUTAP0 = MEM_512_9[ ADDRA[11:3] ] [ ADDRA[2:0] ];
                    end
            2'b01 : begin
                    DOUTAP0 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 ];
                    DOUTAP1 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 + 1 ];
                end
            2'b10 : begin
                    DOUTAP0 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 ];
                    DOUTAP1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 1 ];
                    DOUTAP2 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 2 ];
                    DOUTAP3 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 3 ];
                end
            2'b11 : begin
                    {DOUTAP8, DOUTAP7, DOUTAP6, DOUTAP5, DOUTAP4, 
                              DOUTAP3, DOUTAP2, DOUTAP1, DOUTAP0} = MEM_512_9[ ADDRA[8:0] ];
                    end
             default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
               end
         endcase

         // Check for Write from Port B and Read from Port A to the same address, read data on Port A is driven to X
         if ( (WENB_lat == 1'b0) && same_addr(ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}) &&
                                                                  ((CLKB_wr_re + `TWRO) > CLKA_rd_re) ) begin
                       if ( WARNING_MSGS_ON )
           $display (" ** Warning: Port B Write and Port A Read to same address at same time. Port A read data is unpredictable, driving read data to X");
                       if ( WARNING_MSGS_ON )
            $display (" Time: %0.1f Instance: %m ", $realtime );
            `DATA_A_OUT = drive_data_x (ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}, `DATA_A_OUT);
         end

        end else if (PIPEA_int == 1'b1) begin
          case (`BLKA_WIDTH_CFG)
            2'b00 : begin 
                    DOUTAP0_stg1 = MEM_512_9[ ADDRA[11:3] ] [ ADDRA[2:0] ];
                    end
            2'b01 : begin
                    DOUTAP0_stg1 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 ];
                    DOUTAP1_stg1 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 + 1 ];
                    end
            2'b10 : begin
                    DOUTAP0_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 ];
                    DOUTAP1_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 1 ];
                    DOUTAP2_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 2 ];
                    DOUTAP3_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 3 ];
                    end
            2'b11 : begin
                    {DOUTAP8_stg1, DOUTAP7_stg1, DOUTAP6_stg1, DOUTAP5_stg1, DOUTAP4_stg1,
                                   DOUTAP3_stg1, DOUTAP2_stg1, DOUTAP1_stg1, DOUTAP0_stg1} = MEM_512_9[ ADDRA[8:0] ];
                    end
             default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
               end
         endcase

         // Check for Write from Port B and Read from Port A to the same address, read data on Port A is driven to X
         if ( (WENB_lat == 1'b0) && same_addr(ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}) &&
                                                                 ((CLKB_wr_re + `TWRO) > CLKA_rd_re) ) begin
                       if ( WARNING_MSGS_ON )
           $display (" ** Warning: Port B Write and Port A Read to same address at same time. Port A read data is unpredictable, driving read data to X");
                       if ( WARNING_MSGS_ON )
           $display (" Time: %0.1f Instance: %m ", $realtime );
           `DATAP_A_OUT = drive_data_x (ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}, `DATAP_A_OUT);
         end

        end else begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: PIPEA unknown at time %d ns, no data was read.", $time);
                DOUTAP0 = 1'bx;
                DOUTAP1 = 1'bx;
                DOUTAP2 = 1'bx;
                DOUTAP3 = 1'bx;
                DOUTAP4 = 1'bx;
                DOUTAP5 = 1'bx;
                DOUTAP6 = 1'bx;
                DOUTAP7 = 1'bx;
                DOUTAP8 = 1'bx;
              end
      end else if ( (WENA_int == 1'b0) && (ADDRA_VALID == 0) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Illegal Write Address on port A, Write Not Initiated.");
      end else if ( (WENA_int == 1'b1) && (ADDRA_VALID == 0) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Illegal Read Address on port A, Read Not Initiated.");
      end else begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Warning: WENAis unknown at time %d ns", $time);
      end
    end
 end
   
                          
  
// start the RAM BLKB write/read  behavior section

always @(posedge CLKB_int) begin

  if (PIPEB_int == 1'b1) begin
    case (`BLKB_WIDTH_CFG)
      2'b00 : begin 
               DOUTBP0 = DOUTBP0_stg1;
              end
      2'b01 : begin
               DOUTBP0 = DOUTBP0_stg1;
               DOUTBP1 = DOUTBP1_stg1;
              end
      2'b10 : begin
               DOUTBP0 = DOUTBP0_stg1;
               DOUTBP1 = DOUTBP1_stg1;
               DOUTBP2 = DOUTBP2_stg1;
               DOUTBP3 = DOUTBP3_stg1;
              end
      2'b11 : begin
               DOUTBP0 = DOUTBP0_stg1;
               DOUTBP1 = DOUTBP1_stg1;
               DOUTBP2 = DOUTBP2_stg1;
               DOUTBP3 = DOUTBP3_stg1;
               DOUTBP4 = DOUTBP4_stg1;
               DOUTBP5 = DOUTBP5_stg1;
               DOUTBP6 = DOUTBP6_stg1;
               DOUTBP7 = DOUTBP7_stg1;
               DOUTBP8 = DOUTBP8_stg1;
             end
      default:
              begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
              end
    endcase
  end
  else if (PIPEB_int == 1'bx) begin
    if ( WARNING_MSGS_ON == 1 )
      $display ("Warning: PIPEB unknown at time %d ns, no data was read.", $time); 
    DOUTBP0 = 1'bx;
    DOUTBP1 = 1'bx;
    DOUTBP2 = 1'bx;
    DOUTBP3 = 1'bx;
    DOUTBP4 = 1'bx;
    DOUTBP5 = 1'bx;
    DOUTBP6 = 1'bx;
    DOUTBP7 = 1'bx;
    DOUTBP8 = 1'bx;
  end
 

  if ((BLKB_int == 1'b0) && (RESET_int == 1'b1)) begin

    WENB_lat = WENB_int;

    ADDRB = get_address(`BLKB_ADDR, `BLKB_WIDTH_CFG);   // get the address (read or write )
    ADDRB_VALID = 1;

    if ( DYNAMIC == 1 ) begin
      ADDRB = ADDRB >> `BLKB_WIDTH_CFG;
    end

    if ((^ADDRB) === 1'bx) begin
      ADDRB_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port B at time %0.1f! %b, %b, %b", $realtime, ADDRB, `BLKB_ADDR, `BLKB_WIDTH_CFG);
    end                                                                            
    else if ((`BLKB_WIDTH_CFG == 2'b00) && (ADDRB > 4095)) begin                   
      ADDRB_VALID = 0;                                                             
      if ( WARNING_MSGS_ON == 1 )                                                  
        $display(" Warning: Illegal address on port B at time %0.1f! %b", $realtime, ADDRB);
    end                                                                            
    else if ((`BLKB_WIDTH_CFG == 2'b01) && (ADDRB > 2047)) begin                   
      ADDRB_VALID = 0;                                                             
      if ( WARNING_MSGS_ON == 1 )                                                  
        $display(" Warning: Illegal address on port B at time %0.1f! %b", $realtime, ADDRB);
    end                                                                            
    else if ((`BLKB_WIDTH_CFG == 2'b10) && (ADDRB > 1023)) begin                   
      ADDRB_VALID = 0;                                                             
      if ( WARNING_MSGS_ON == 1 )                                                  
        $display(" Warning: Illegal address on port B at time %0.1f! %b", $realtime, ADDRB);
    end                                                                            
    else if ((`BLKB_WIDTH_CFG == 2'b11) && (ADDRB > 511)) begin                    
      ADDRB_VALID = 0;                                                             
      if ( WARNING_MSGS_ON == 1 )                                                  
        $display(" Warning: Illegal address on port B at time %0.1f! %b", $realtime, ADDRB);
    end

    // Write mode

    if ( (WENB_int == 1'b0) && ADDRB_VALID ) begin

      CLKB_wr_re = $time;

      // Check if Write from Port A and Write from Port A are to the same address, write data is non-deterministic

      if ( (WENA_lat == 1'b0) && same_addr(ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0} ) &&
                                                            ((CLKA_wr_re + `CLK_MIN) > CLKB_wr_re) ) begin
                       if ( WARNING_MSGS_ON )
        $display (" ** Warning: Port A Write and Port B Write to same address at same time. Write data conflict. Updating memory contents at conflicting address with X");
        // function call to determine conflicting write data bits based on address and width configuration
                       if ( WARNING_MSGS_ON )
        $display (" Time: %0.1f Instance: %m ", $realtime );
        `DATA_B_REG = drive_data_x (ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}, `DATA_B_IN);
      end
      else begin
        // assign write data to data registers for writing into the memory array
        `DATA_B_REG = `DATA_B_IN;
      end

      // assign write data to bypass registers for driving onto RD if MODE=1
      `DATA_B_BYP = `DATA_B_IN;

      // Check for Read from Port A and Write from Port B to the same address, read data on Port A is driven to X
      if ( (WENA_lat == 1'b1) && same_addr(ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}) &&
                                                              ((CLKA_rd_re + `CLK_MIN) > CLKB_wr_re) ) begin
                       if ( WARNING_MSGS_ON )
        $display (" ** Warning: Port A Read and Port B Write to same address at same time. Port A read data is unpredictable, driving read data to X");
                       if ( WARNING_MSGS_ON )
        $display (" Time: %0.1f Instance: %m ", $realtime );

        if (PIPEA_int == 1'b1)
          `DATAP_A_OUT = drive_data_x (ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}, `DATAP_A_OUT);
        else if (PIPEA_int == 1'b0)
          `DATA_A_OUT = drive_data_x (ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}, `DATA_A_OUT);
      end

      case (`BLKB_WIDTH_CFG)
            2'b00 : begin

                 MEM_512_9[ ADDRB[11:3] ] [ ADDRB[2:0] ] = DINB0_reg;

                 if (WMODEB_int == 1'b1) begin
                  if (PIPEB_int == 1'b0) begin
                    DOUTBP0 = DINB0_bypass;
                  end else if (PIPEB_int == 1'b1) begin
                    DOUTBP0_stg1 = DINB0_bypass;
                  end
                 end
                end
            2'b01 : begin

                 MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 ] = DINB0_reg;
                 MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 + 1 ] = DINB1_reg;

                 if (WMODEB_int == 1'b1) begin
                   if (PIPEB_int == 1'b0) begin
                     DOUTBP0 = DINB0_bypass;
                     DOUTBP1 = DINB1_bypass;
                   end else if (PIPEB_int == 1'b1) begin
                     DOUTBP0_stg1 = DINB0_bypass;
                     DOUTBP1_stg1 = DINB1_bypass;
                   end
                 end 
                end
            2'b10 : begin

                 MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 ] = DINB0_reg;
                 MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 1 ] = DINB1_reg;
                 MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 2 ] = DINB2_reg;
                 MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 3 ] = DINB3_reg;

                 if (WMODEB_int == 1'b1) begin
                  if (PIPEB_int == 1'b0) begin
                   DOUTBP0 = DINB0_bypass;
                   DOUTBP1 = DINB1_bypass;
                   DOUTBP2 = DINB2_bypass;
                   DOUTBP3 = DINB3_bypass;
                  end else if (PIPEB_int == 1'b1) begin
                   DOUTBP0_stg1 = DINB0_bypass;
                   DOUTBP1_stg1 = DINB1_bypass;
                   DOUTBP2_stg1 = DINB2_bypass;
                   DOUTBP3_stg1 = DINB3_bypass;
                  end
                 end
                end
            2'b11 : begin

                 MEM_512_9[ ADDRB[8:0] ] = {DINB8_reg,DINB7_reg,DINB6_reg,DINB5_reg,DINB4_reg,DINB3_reg,DINB2_reg,DINB1_reg,DINB0_reg};

                 if (WMODEB_int == 1'b1) begin
                  if (PIPEB_int == 1'b0) begin
                   DOUTBP0 = DINB0_bypass;
                   DOUTBP1 = DINB1_bypass;
                   DOUTBP2 = DINB2_bypass;
                   DOUTBP3 = DINB3_bypass;
                   DOUTBP4 = DINB4_bypass;
                   DOUTBP5 = DINB5_bypass;
                   DOUTBP6 = DINB6_bypass;
                   DOUTBP7 = DINB7_bypass;
                   DOUTBP8 = DINB8_bypass;
                  end else if (PIPEB_int == 1'b1) begin
                   DOUTBP0_stg1 = DINB0_bypass;
                   DOUTBP1_stg1 = DINB1_bypass;
                   DOUTBP2_stg1 = DINB2_bypass;
                   DOUTBP3_stg1 = DINB3_bypass;
                   DOUTBP4_stg1 = DINB4_bypass;
                   DOUTBP5_stg1 = DINB5_bypass;
                   DOUTBP6_stg1 = DINB6_bypass;
                   DOUTBP7_stg1 = DINB7_bypass;
                   DOUTBP8_stg1 = DINB8_bypass;
                  end
                 end
                 end
           default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
               end
         endcase
   end else if ( (WENB_int == 1'b1) && ADDRB_VALID ) begin
 
        CLKB_rd_re = $time;

        if (PIPEB_int == 1'b0) begin 
        case (`BLKB_WIDTH_CFG)
            2'b00 : begin
                    DOUTBP0 = MEM_512_9[ ADDRB[11:3] ] [ ADDRB[2:0] ];
                    end
            2'b01 : begin
                    DOUTBP0 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 ];
                    DOUTBP1 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 + 1 ];
                    end
            2'b10 : begin
                    DOUTBP0 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 ];
                    DOUTBP1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 1 ];
                    DOUTBP2 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 2 ];
                    DOUTBP3 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 3 ];
                    end
            2'b11 : begin
                    {DOUTBP8, DOUTBP7, DOUTBP6, DOUTBP5, DOUTBP4,
                              DOUTBP3, DOUTBP2, DOUTBP1, DOUTBP0} = MEM_512_9[ ADDRB[8:0] ];
                    end
            default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
               end
         endcase

         // Check for Write from Port A and Read from Port B to the same address, read data on Port B is driven to X
         if ( (WENA_lat == 1'b0) && same_addr(ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}) &&
                                                                 ((CLKA_wr_re + `TWRO) > CLKB_rd_re) ) begin
                       if ( WARNING_MSGS_ON )
           $display (" ** Warning: Port A Write and Port B Read to same address at same time. Port B read data is unpredictable, driving read data to X");
                       if ( WARNING_MSGS_ON )
           $display (" Time: %0.1f Instance: %m ", $realtime );
           `DATA_B_OUT = drive_data_x (ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}, `DATA_B_OUT);
         end

        end else if (PIPEB_int == 1'b1) begin
            case (`BLKB_WIDTH_CFG)
            2'b00 : begin
                    DOUTBP0_stg1 = MEM_512_9[ ADDRB[11:3] ] [ ADDRB[2:0] ];
                    end
            2'b01 : begin
                    DOUTBP0_stg1 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 ];
                    DOUTBP1_stg1 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 + 1 ];
                    end
            2'b10 : begin
                    DOUTBP0_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 ];
                    DOUTBP1_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 1 ];
                    DOUTBP2_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 2 ];
                    DOUTBP3_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 3 ];
                    end
            2'b11 : begin
                    {DOUTBP8_stg1, DOUTBP7_stg1, DOUTBP6_stg1, DOUTBP5_stg1, DOUTBP4_stg1,
                                   DOUTBP3_stg1, DOUTBP2_stg1, DOUTBP1_stg1, DOUTBP0_stg1} = MEM_512_9[ ADDRB[8:0] ];
                    end
            default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
               end
         endcase

         // Check for Write from Port A and Read from Port B to the same address, read data on Port B is driven to X
         if ( (WENA_lat == 1'b0) && same_addr(ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}) &&
                                                                  ((CLKA_wr_re + `TWRO) > CLKB_rd_re) ) begin
                       if ( WARNING_MSGS_ON )
          $display (" ** Warning: Port A Write and Port B Read to same address at same time. Port B read data is unpredictable, driving read data to X");
                       if ( WARNING_MSGS_ON )
           $display (" Time: %0.1f Instance: %m ", $realtime );
           `DATAP_B_OUT = drive_data_x (ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}, `DATAP_B_OUT);
         end

       end else begin
                   if ( WARNING_MSGS_ON == 1 )
                     $display ("Warning: PIPEB unknown at time %d ns, no data was read.", $time); 
                   DOUTBP0 = 1'bx;
                   DOUTBP1 = 1'bx;
                   DOUTBP2 = 1'bx;
                   DOUTBP3 = 1'bx;
                   DOUTBP4 = 1'bx;
                   DOUTBP5 = 1'bx;
                   DOUTBP6 = 1'bx;
                   DOUTBP7 = 1'bx;
                   DOUTBP8 = 1'bx;
                end
      end else if ( (WENB_int == 1'b0) && (ADDRB_VALID == 0) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Illegal Write Address on port B, Write Not Initiated.");
      end else if ( (WENB_int == 1'b1) && (ADDRB_VALID == 0) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Illegal Read Address on port B, Read Not Initiated.");
      end else begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Warning: WENB is unknown at time %d ns", $time);
      end
    end
 end


 // function to check if write and read operations are accessing the same memory location

 function same_addr;
   input integer waddr, raddr;
   input [1:0]   ww, rw;
   integer       wr_addr, rd_addr;
   begin
     same_addr = 1'b0;
     if ( ww > rw ) begin
       rd_addr = raddr >> (  ww - rw );
       wr_addr = waddr;
     end
     else if ( rw > ww )begin
       rd_addr = raddr;
       wr_addr = waddr >> (  rw - ww );
     end
     else begin
       rd_addr = raddr;
       wr_addr = waddr;
     end
     if ( wr_addr == rd_addr ) begin
       same_addr = 1'b1;
     end
   end
 endfunction


 // function to drive read data bus to "x" depending on width configuration

 function [8:0] drive_data_x;
   input integer waddr, raddr;
   input [1:0]   ww, rw;
   input [8:0]   rd_data;
   integer       index, i;
   begin
     drive_data_x = rd_data;
     case(rw)
       2'b00 : begin
                 drive_data_x [ 0 ] = 1'bx;
               end
       2'b01 : begin
                 if ( ww == 2'b00 )
                   drive_data_x [ waddr[0] ] = 1'bx;
                 else
                   drive_data_x [ 1:0 ] = 2'bx;
               end
       2'b10 : begin
                 if ( ww == 2'b00 )
                   drive_data_x [ waddr[1:0] ] = 1'bx;
                 else if ( ww == 2'b01 ) begin
                   index = waddr[0] * 2;
                   for ( i=index; i<index+2; i=i+1 )
                     drive_data_x [ i ] = 1'bx;
                 end else
                   drive_data_x [ 3:0 ] = 4'bx;
               end
       2'b11 : begin
                 if ( ww == 2'b00 )
                   drive_data_x [ waddr[2:0] ] = 1'bx;
                 else if ( ww == 2'b01 ) begin
                   index = waddr[1:0] * 2;
                   for ( i=index; i<index+2; i=i+1 )
                     drive_data_x [ i ] = 1'bx;
                 end else if ( ww == 2'b10 ) begin
                   index = waddr[0] * 4;
                   for ( i=index; i<index+4; i=i+1 )
                     drive_data_x [ i ] = 1'bx;
                 end else
                   drive_data_x [ 8:0 ] = 9'bx;
               end
       default: begin
                       if ( WARNING_MSGS_ON )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
                end
      endcase
   end

 endfunction

 // function to convert addr vector to integer
 
 function integer get_address;
   input [11:0] addr_signal;
   input [ 1:0] width;

   reg   [11:0] addrsignal;
   integer ADDR;

   begin
     // the address calculation is based on  width,  because we assume that
     // users (or actgen) will connect low unused address pin to GND (1'b0), otherwise it may cause problem !

     // for dynamic configuration, shift address bits right by width, aligns them to 2**11 address space
     //if ( DYNAMIC == 1 ) 
     //  addrsignal = addr_signal >> width;
     //else
     addrsignal = addr_signal;


     ADDR =  addrsignal[11]*2048 + addrsignal[10]*1024 + addrsignal[9]*512 + addrsignal[8]*256 +
             addrsignal[7]*128   + addrsignal[6]*64    + addrsignal[5]*32  + addrsignal[4]*16  +
             addrsignal[3]*8     + addrsignal[2]*4     + addrsignal[1]*2   + addrsignal[0]*1   ;

     get_address = ADDR;
   end
 endfunction


endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CORERAM4K9 ----

//---- MODULE CORERAM512X18 ----
/*-----------------------------------------------------------------
 CELL NAME : CORERAM512X18
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 100 ps / 10 ps

`define TWRO      16
`define CLK_MIN   16

module CORERAM512X18(RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0,
                 WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0,
                 RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,
                 RD3,RD2,RD1,RD0,WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,
                 WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0,RW1,WW1,RW0,WW0,REN,RCLK,WEN,WCLK,RESET,PIPE); 


input RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0;
input WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0;
input WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0;
input RW1,WW1,RW0, WW0,REN,RCLK,WEN,WCLK,RESET,PIPE;

output RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,RD3,RD2,RD1,RD0;

reg RDP17,RDP16,RDP15,RDP14,RDP13,RDP12,RDP11,RDP10,RDP9,RDP8,RDP7,RDP6,RDP5,RDP4,RDP3,RDP2,RDP1,RDP0;
reg RDP17_stg,RDP16_stg,RDP15_stg,RDP14_stg,RDP13_stg,RDP12_stg,RDP11_stg,RDP10_stg,RDP9_stg;
reg RDP8_stg,RDP7_stg,RDP6_stg,RDP5_stg,RDP4_stg,RDP3_stg,RDP2_stg,RDP1_stg,RDP0_stg;

wire RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int;
wire WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int;
wire WD17_int,WD16_int,WD15_int,WD14_int,WD13_int,WD12_int,WD11_int,WD10_int,WD9_int,WD8_int;
wire WD7_int,WD6_int,WD5_int,WD4_int,WD3_int,WD2_int,WD1_int,WD0_int;
wire REN_int,RCLK_int,WEN_int,WCLK_int,RESET_int,PIPE_int;

time WCLK_re;
time RCLK_re;

reg [8:0] MEM_512_9 [0:511];

reg NOTIFY_REG;

integer RADDR;           
integer WADDR;           
integer DEPTH;
integer MAXADD;

reg RADDR_VALID;
reg WADDR_VALID;

reg WEN_lat, REN_lat;

`define WADDR_BUS {WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int}
`define RADDR_BUS {RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int}
`define DATA_WIDTH_18 {RDP17,RDP16,RDP15,RDP14,RDP13,RDP12,RDP11,RDP10,RDP9,RDP8,RDP7,RDP6,RDP5,RDP4,RDP3,RDP2,RDP1,RDP0}
`define DATAP_WIDTH_18 {RDP17_stg,RDP16_stg,RDP15_stg,RDP14_stg,RDP13_stg,RDP12_stg,RDP11_stg,RDP10_stg,RDP9_stg,RDP8_stg,                            RDP7_stg,RDP6_stg,RDP5_stg,RDP4_stg,RDP3_stg,RDP2_stg,RDP1_stg,RDP0_stg}

buf b0(WCLK_int, WCLK);
buf b1(RCLK_int, RCLK);
buf b2(WEN_int,WEN);
buf b3(REN_int,REN);
buf b4(RESET_int, RESET);

buf b5(RADDR8_int, RADDR8);
buf b6(RADDR7_int, RADDR7);
buf b7(RADDR6_int, RADDR6);
buf b8(RADDR5_int, RADDR5);
buf b9(RADDR4_int, RADDR4);
buf b10(RADDR3_int, RADDR3);
buf b11(RADDR2_int, RADDR2);
buf b12(RADDR1_int, RADDR1);
buf b13(RADDR0_int, RADDR0);

buf b14(WADDR8_int, WADDR8);
buf b15(WADDR7_int, WADDR7);
buf b16(WADDR6_int, WADDR6);
buf b17(WADDR5_int, WADDR5);
buf b18(WADDR4_int, WADDR4);
buf b19(WADDR3_int, WADDR3);
buf b20(WADDR2_int, WADDR2);
buf b21(WADDR1_int, WADDR1);
buf b22(WADDR0_int, WADDR0);

buf b23(WD17_int, WD17);
buf b24(WD16_int, WD16);
buf b25(WD15_int, WD15);
buf b26(WD14_int, WD14);
buf b27(WD13_int, WD13);
buf b28(WD12_int, WD12);
buf b29(WD11_int, WD11);
buf b30(WD10_int, WD10);
buf b31(WD9_int, WD9);
buf b32(WD8_int, WD8);
buf b33(WD7_int, WD7);
buf b34(WD6_int, WD6);
buf b35(WD5_int, WD5);
buf b36(WD4_int, WD4);
buf b37(WD3_int, WD3);
buf b38(WD2_int, WD2);
buf b39(WD1_int, WD1);
buf b40(WD0_int, WD0);
buf b41(PIPE_int,PIPE);

pmos inst0(RD17, RDP17, 0);
pmos inst1(RD16, RDP16, 0);
pmos inst2(RD15, RDP15, 0);
pmos inst3(RD14, RDP14, 0);
pmos inst4(RD13, RDP13, 0);
pmos inst5(RD12, RDP12, 0);
pmos inst6(RD11, RDP11, 0);
pmos inst7(RD10, RDP10, 0);
pmos inst8(RD9, RDP9, 0);
pmos inst9(RD8, RDP8, 0);
pmos inst10(RD7, RDP7, 0);
pmos inst11(RD6, RDP6, 0);
pmos inst12(RD5, RDP5, 0);
pmos inst13(RD4, RDP4, 0);
pmos inst14(RD3, RDP3, 0);
pmos inst15(RD2, RDP2, 0);
pmos inst16(RD1, RDP1, 0);
pmos inst17(RD0, RDP0, 0);

parameter DYNAMIC = 1;
parameter MEMORYFILE = "";
`ifdef WARNING_MSGS_ON
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
`else
parameter WARNING_MSGS_ON = 0; // Used to turn off warnings about read &
`endif
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.
  initial
    begin
    
      if ( WARNING_MSGS_ON == 1 )
        $display ( "Note: RAM512X18 warnings disabled. Set WARNING_MSGS_ON = 1 to enable." );

      if ( MEMORYFILE != "")
        $readmemb ( MEMORYFILE, MEM_512_9 );
      else
        begin
          //if ( WARNING_MSGS_ON == 1 )
            //$display ( "Note: Module %m, memory initialization file parameter MEMORYFILE not defined" );
        end
    end

always @(WCLK_int === 1'bx )
begin
  if ($time > 0) begin
    if (WEN_int == 1'b0) begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning : WCLK went unknown at time %0.1f\n",$realtime);
    end
  end
end

always @(RCLK_int === 1'bx )
begin
  if ($time > 0) begin
    if (REN_int == 1'b0) begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning : RCLK went unknown at time %0.1f\n",$realtime);
    end
  end
end

always @(RESET_int === 1'b0 )
begin

   
 case({RW1,RW0})
     2'b01 : begin
              RDP0 = 1'b0;
              RDP1 = 1'b0;
              RDP2 = 1'b0;
              RDP3 = 1'b0;
              RDP4 = 1'b0;
              RDP5 = 1'b0;
              RDP6 = 1'b0;
              RDP7 = 1'b0;
              RDP8 = 1'b0;
              if (PIPE_int == 1'b1) begin
              RDP0_stg = 1'b0;
              RDP1_stg = 1'b0;
              RDP2_stg = 1'b0;
              RDP3_stg = 1'b0;
              RDP4_stg = 1'b0;
              RDP5_stg = 1'b0;
              RDP6_stg = 1'b0;
              RDP7_stg = 1'b0;
              RDP8_stg = 1'b0;
              end
             end
     2'b10 : begin
              RDP0 = 1'b0;
              RDP1 = 1'b0;
              RDP2 = 1'b0;
              RDP3 = 1'b0;
              RDP4 = 1'b0;
              RDP5 = 1'b0;
              RDP6 = 1'b0;
              RDP7 = 1'b0;
              RDP8 = 1'b0;
              RDP9 = 1'b0;
              RDP10 = 1'b0;
              RDP11 = 1'b0;
              RDP12 = 1'b0;
              RDP13 = 1'b0;
              RDP14 = 1'b0;
              RDP15 = 1'b0;
              RDP16 = 1'b0;
              RDP17 = 1'b0;
              if (PIPE_int == 1'b1) begin
              RDP0_stg = 1'b0;
              RDP1_stg = 1'b0;
              RDP2_stg = 1'b0;
              RDP3_stg = 1'b0;
              RDP4_stg = 1'b0;
              RDP5_stg = 1'b0;
              RDP6_stg = 1'b0;
              RDP7_stg = 1'b0;
              RDP8_stg = 1'b0;
              RDP9_stg = 1'b0;
              RDP10_stg = 1'b0;
              RDP11_stg = 1'b0;
              RDP12_stg = 1'b0;
              RDP13_stg = 1'b0;
              RDP14_stg = 1'b0;
              RDP15_stg = 1'b0;
              RDP16_stg = 1'b0;
              RDP17_stg = 1'b0;
              end
            end
       default : begin
                   if ( WARNING_MSGS_ON == 1 )
                     $display ("Warning: RW at time %d ns.", $time);
                 end
       endcase

  end // Reset

always @(posedge WCLK_int) begin
  
  WEN_lat = WEN_int;

  if ((WEN_int == 1'b0) && (RESET_int == 1'b1))  begin

    WCLK_re     = $time;
    WADDR       = get_address( `WADDR_BUS, {WW1,WW0} ); // call address calculation function to get write address
    WADDR_VALID = 1;

    if ( DYNAMIC == 1 && {WW1,WW0} == 2'b10 ) begin
      WADDR = WADDR >> 1;
    end

    if ((^WADDR) === 1'bx) begin
      WADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on write port at time %0.1f!", $realtime);
    end
    else if (({WW1,WW0} == 2'b01) && (WADDR > 511)) begin
      WADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f!", $realtime);
    end
    else if (({WW1,WW0} == 2'b10) && (WADDR > 255)) begin
      WADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f!", $realtime);
    end

    if (WADDR_VALID) begin

      // Check for Write and Read to the same address, write is not affected
      if ( (REN_lat == 1'b0) && same_addr(WADDR, RADDR, {WW1,WW0}, {RW1,RW0} ) &&
                              ((RCLK_re + `CLK_MIN) > WCLK_re) ) begin
                       if ( WARNING_MSGS_ON )
        $display (" ** Warning: Read and Write to same address at same time.  RD is unpredictable, driving RD to X ");
                       if ( WARNING_MSGS_ON )
        $display (" Time: %0.1f Instance: %m ", $realtime );

        if (PIPE_int == 1'b1)
          `DATAP_WIDTH_18 = drive_rd_x (WADDR, RADDR, {WW1,WW0}, {RW1,RW0}, `DATAP_WIDTH_18);
        else if (PIPE_int == 1'b0)
          `DATA_WIDTH_18 = drive_rd_x (WADDR, RADDR, {WW1,WW0}, {RW1,RW0}, `DATA_WIDTH_18);
      end

      case ({WW1,WW0})
            2'b01 : begin
                    MEM_512_9 [ WADDR ] = {WD8_int, WD7_int, WD6_int, WD5_int, WD4_int, WD3_int, WD2_int, WD1_int, WD0_int};
                    end
            2'b10 : begin
                    MEM_512_9 [ WADDR[7:0] * 2 ] = {WD8_int,WD7_int,WD6_int,WD5_int,WD4_int,WD3_int,WD2_int,WD1_int,WD0_int};
                    MEM_512_9 [ WADDR[7:0] * 2  + 1 ] = {WD17_int,WD16_int,WD15_int,WD14_int,WD13_int,WD12_int,WD11_int,WD10_int,WD9_int};
                    end
          default : begin
                      if ( WARNING_MSGS_ON == 1 )
                        $display("Warning: WW value unknown at time %d",$time);
                    end
      endcase
    end
    else begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning: Illegal Write Address, Write Not Initiated.");
    end
  end else if (WEN_int == 1'bx) begin
    if ( WARNING_MSGS_ON == 1 )
      $display ("Warning: WEN went unknown at time %d ns", $time);
  end 
end


always @(posedge RCLK_int) begin

    REN_lat = REN_int;

    if (PIPE_int == 1'b1) begin
     case({RW1,RW0})
       2'b01 : begin
                RDP0 = RDP0_stg;
                RDP1 = RDP1_stg;
                RDP2 = RDP2_stg;
                RDP3 = RDP3_stg;
                RDP4 = RDP4_stg;
                RDP5 = RDP5_stg;
                RDP6 = RDP6_stg;
                RDP7 = RDP7_stg;
                RDP8 = RDP8_stg;
               end
       2'b10 : begin
                RDP0 = RDP0_stg;
                RDP1 = RDP1_stg;
                RDP2 = RDP2_stg;
                RDP3 = RDP3_stg;
                RDP4 = RDP4_stg;
                RDP5 = RDP5_stg;
                RDP6 = RDP6_stg;
                RDP7 = RDP7_stg;
                RDP8 = RDP8_stg;
                RDP9 = RDP9_stg;
                RDP10 = RDP10_stg;
                RDP11 = RDP11_stg;
                RDP12 = RDP12_stg;
                RDP13 = RDP13_stg;
                RDP14 = RDP14_stg;
                RDP15 = RDP15_stg;
                RDP16 = RDP16_stg;
                RDP17 = RDP17_stg;
              end
       default : begin
                  if ( WARNING_MSGS_ON == 1 )
                    $display ("Warning: RW unknown at time %d ns.", $time);
                 end
     endcase
    end 
    else if (PIPE_int == 1'bx) begin
      if ( WARNING_MSGS_ON == 1 )
        $display ("Warning: PIPE unknown at time %d ns, no data was read.", $time);
      RDP0 = 1'bx;
      RDP1 = 1'bx;
      RDP2 = 1'bx;
      RDP3 = 1'bx;
      RDP4 = 1'bx;
      RDP5 = 1'bx;
      RDP6 = 1'bx;
      RDP7 = 1'bx;
      RDP8 = 1'bx;
      RDP9 = 1'bx;
      RDP10 = 1'bx;
      RDP11 = 1'bx;
      RDP12 = 1'bx;
      RDP13 = 1'bx;
      RDP14 = 1'bx;
      RDP15 = 1'bx;
      RDP16 = 1'bx;
      RDP17 = 1'bx;
    end


  if ((REN_int == 1'b0 ) && (RESET_int == 1'b1)) begin

    RCLK_re     = $time;
    RADDR       = get_address( `RADDR_BUS, {RW1,RW0} );
    RADDR_VALID = 1;

    if ( DYNAMIC == 1 && ({RW1,RW0} == 2'b10) ) begin
      RADDR = RADDR >> 1;
    end

    if ((^RADDR) === 1'bx) begin
      RADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning: Illegal address on read port at time %0.1f!", $realtime);
    end
    else if (({RW1,RW0} == 2'b01) && (RADDR > 511)) begin
      RADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning: Illegal address on read port at time %0.1f!", $realtime);
    end
    else if (({RW1,RW0} == 2'b10) && (RADDR > 255)) begin
      RADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning: Illegal address on read port at time %0.1f!", $realtime);
    end


    // shift the address bits left by 1 while accessing the memory array with width=10
    //if ( {RW1,RW0} == 2'b10 )
    //  RADDR = RADDR << 1;

    if (RADDR_VALID) begin

      if (PIPE_int == 1'b0) begin
        case({RW1,RW0})
          2'b01 : begin
                  {RDP8, RDP7, RDP6, RDP5, RDP4, RDP3, RDP2, RDP1, RDP0} = MEM_512_9 [ RADDR ];
                end
          2'b10 : begin
                    {RDP8, RDP7, RDP6, RDP5, RDP4, RDP3, RDP2, RDP1, RDP0} = MEM_512_9 [ RADDR[7:0] * 2 ];
                    {RDP17, RDP16, RDP15, RDP14, RDP13, RDP12, RDP11, RDP10, RDP9} = MEM_512_9 [ RADDR[7:0] * 2 + 1 ];
                  end
        default : begin
                    if ( WARNING_MSGS_ON == 1 )
                      $display ("Warning: RW at time %d ns.", $time);
                  end
        endcase

        // Check for Write and Read to the same address
        if ( (WEN_lat == 1'b0) && same_addr(WADDR, RADDR, {WW1,WW0}, {RW1,RW0}) &&
                            ((WCLK_re + `TWRO) > RCLK_re)) begin
                       if ( WARNING_MSGS_ON )
          $display (" ** Warning: Write and Read to same address at same time.  RD is unpredictable, driving RD to X");
                       if ( WARNING_MSGS_ON )
          $display (" Time: %0.1f Instance: %m ", $realtime );
          `DATA_WIDTH_18 = drive_rd_x (WADDR, RADDR, {WW1,WW0}, {RW1,RW0}, `DATA_WIDTH_18);
        end

      end else if (PIPE_int == 1'b1) begin
        case({RW1,RW0})
          2'b01 : begin
                    {RDP8_stg,RDP7_stg,RDP6_stg,RDP5_stg,RDP4_stg,RDP3_stg,RDP2_stg,RDP1_stg,RDP0_stg} = MEM_512_9 [ RADDR ];
                  end
          2'b10 : begin
                    {RDP8_stg,RDP7_stg,RDP6_stg,RDP5_stg,RDP4_stg,RDP3_stg,RDP2_stg,RDP1_stg,RDP0_stg} = MEM_512_9 [ RADDR[7:0] * 2 ];
                    {RDP17_stg,RDP16_stg,RDP15_stg,RDP14_stg,RDP13_stg,RDP12_stg,RDP11_stg,RDP10_stg,RDP9_stg} = MEM_512_9 [ RADDR[7:0] * 2 + 1 ];
                  end
          default : begin
                      if ( WARNING_MSGS_ON == 1 )
                        $display ("Warning: RW unknown at time %d ns.", $time);
                    end
        endcase 

        // Check for Write and Read to the same address
        if ( (WEN_lat == 1'b0) && same_addr(WADDR, RADDR, {WW1,WW0}, {RW1,RW0}) &&
                            ((WCLK_re + `TWRO) > RCLK_re)) begin
                       if ( WARNING_MSGS_ON )
          $display (" ** Warning: Write and Read to same address at same time.  RD is unpredictable, driving RD to X");
                       if ( WARNING_MSGS_ON )
          $display (" Time: %0.1f Instance: %m ", $realtime );
          `DATAP_WIDTH_18 = drive_rd_x (WADDR, RADDR, {WW1,WW0}, {RW1,RW0}, `DATAP_WIDTH_18);
        end

      end else begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: PIPE unknown at time %d ns, no data was read.", $time);
                RDP0 = 1'bx;
                RDP1 = 1'bx;
                RDP2 = 1'bx;
                RDP3 = 1'bx;
                RDP4 = 1'bx;
                RDP5 = 1'bx;
                RDP6 = 1'bx;
                RDP7 = 1'bx;
                RDP8 = 1'bx;
                RDP9 = 1'bx;
                RDP10 = 1'bx;
                RDP11 = 1'bx;
                RDP12 = 1'bx;
                RDP13 = 1'bx;
                RDP14 = 1'bx;
                RDP15 = 1'bx;
                RDP16 = 1'bx;
                RDP17 = 1'bx;
              end
    end else begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning: Illegal Read Address, Read Not Initiated.");
    end

  end else if (REN_int == 1'bx) begin
    if ( WARNING_MSGS_ON == 1 )
      $display ("Warning: REN went unknown at time %d ns", $time);
  end 

 end


 // function to check if write and read operations are accessing the same memory location

 function same_addr;
   input integer waddr, raddr;
   input [1:0]   ww, rw;
   integer wr_addr, rd_addr;
   begin
     same_addr = 1'b0;
     if ( ww > rw ) begin
       rd_addr = raddr >> (  ww - rw );
       wr_addr = waddr;
     end
     else if ( rw > ww )begin
       rd_addr = raddr;
       wr_addr = waddr >> (  rw - ww );
     end
     else begin
       rd_addr = raddr;
       wr_addr = waddr;
     end
     if ( wr_addr == rd_addr ) begin
       same_addr = 1'b1;
     end
   end
 endfunction


 // function to drive read data bus to "x" depending on width configuration

 function [17:0] drive_rd_x;
   input integer waddr, raddr;
   input [1:0]   ww, rw;
   input [17:0]  rd_data;
   integer       index, i;
   begin
     drive_rd_x = rd_data;
     case(rw)
       2'b01 : begin
                 drive_rd_x [ 8:0 ] =  9'bx;
               end
       2'b10 : begin
                 if ( ww == 2'b01 ) begin
                   index = waddr[0] * 9;
                   for ( i=index; i<index+9; i=i+1 )
                     drive_rd_x [ i ] =  1'bx;
                 end else
                   drive_rd_x [ 17:0 ] =  18'bx;
               end
       default: begin
                       if ( WARNING_MSGS_ON )
                  $display("Warning : Invalid READ WIDTH at time %d ns,Legal Width: 9,18",$time);
                end
      endcase
   end

 endfunction


 function integer get_address;

   input [8:0] addr_signal;
   input [1:0] width;

   reg   [8:0] addrsignal;
   integer     ADDR;

   begin
     // the address calculation is based on  width,  because we assume that
     // users (or actgen) will connect upper unused address pin to GND (1'b0), otherwise it may cause problem !

     // if instantiated in FLEXRAM and if WW/RW[1:0] = 2'b10, right shift address bits by 1 for address checks

     //if ( DYNAMIC == 1 && width == 2'b10 )
     //  addrsignal = addr_signal >> 1;
     //else
     addrsignal = addr_signal;

     ADDR =  addrsignal[8]*256 + addrsignal[7]*128 + addrsignal[6]*64 + addrsignal[5]*32 +
             addrsignal[4]*16  + addrsignal[3]*8   + addrsignal[2]*4  + addrsignal[1]*2  + addrsignal[0]*1;

     get_address = ADDR;
   end

 endfunction


endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CORERAM512X18 ----

//---- MODULE RAM4K9 ----
/*-----------------------------------------------------------------
 CELL NAME : RAM4K9
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 100 ps  / 10 ps

module RAM4K9 (
          ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5, 
          ADDRA4,  ADDRA3,  ADDRA2, ADDRA1, ADDRA0, DINA8,  DINA7,  DINA6,
          DINA5,   DINA4,   DINA3,  DINA2,  DINA1,  DINA0,  DOUTA8, DOUTA7,
          DOUTA6,  DOUTA5,  DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0,
          WIDTHA1, WIDTHA0, PIPEA,  WMODEA, BLKA,   WENA,   CLKA,
          ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5,
          ADDRB4,  ADDRB3,  ADDRB2, ADDRB1, ADDRB0, DINB8,  DINB7,  DINB6,
          DINB5,   DINB4,   DINB3,  DINB2,  DINB1,  DINB0,  DOUTB8, DOUTB7,
          DOUTB6,  DOUTB5,  DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0,
          WIDTHB1, WIDTHB0, PIPEB,  WMODEB, BLKB,   WENB,   CLKB,   RESET
       );


input ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5, ADDRA4, ADDRA3, ADDRA2, ADDRA1, ADDRA0;
input DINA8,   DINA7,   DINA6,  DINA5,  DINA4,  DINA3,  DINA2, DINA1, DINA0;
input WIDTHA1, WIDTHA0, PIPEA,  WMODEA, BLKA,   WENA,   CLKA;

input ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5, ADDRB4, ADDRB3, ADDRB2, ADDRB1, ADDRB0;
input DINB8,   DINB7,   DINB6,  DINB5,  DINB4,  DINB3,  DINB2,  DINB1,  DINB0;
input WIDTHB1, WIDTHB0, PIPEB,  WMODEB, BLKB,   WENB,   CLKB,   RESET;

output DOUTA8, DOUTA7, DOUTA6, DOUTA5, DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0;
output DOUTB8, DOUTB7, DOUTB6, DOUTB5, DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0; 

wire CLKA_int,    CLKB_int;
wire WENA_int,    WENB_int,    WMODEA_int,  WMODEB_int;
wire BLKA_int,    BLKB_int,    RESET_int,   PIPEA_int,   PIPEB_int;
wire WIDTHA1_int, WIDTHA0_int, WIDTHB1_int, WIDTHB0_int;

wire ADDRA11_int, ADDRA10_int, ADDRA9_int, ADDRA8_int, ADDRA7_int, ADDRA6_int;
wire ADDRA5_int,  ADDRA4_int,  ADDRA3_int, ADDRA2_int, ADDRA1_int, ADDRA0_int;

wire ADDRB11_int, ADDRB10_int, ADDRB9_int, ADDRB8_int, ADDRB7_int, ADDRB6_int;
wire ADDRB5_int,  ADDRB4_int,  ADDRB3_int, ADDRB2_int, ADDRB1_int, ADDRB0_int;

wire DINA8_int, DINA7_int, DINA6_int, DINA5_int, DINA4_int, DINA3_int, DINA2_int, DINA1_int, DINA0_int;
wire DINB8_int, DINB7_int, DINB6_int, DINB5_int, DINB4_int, DINB3_int, DINB2_int, DINB1_int, DINB0_int;

reg NOTIFY_REG;

wire BLKA_EN;
wire BLKB_EN;

wire BLKA_WEN;
wire BLKB_WEN;

parameter MEMORYFILE = "";
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.

assign BLKA_EN  = ~BLKA_int & RESET_int;
assign BLKB_EN  = ~BLKB_int & RESET_int;
assign BLKA_WEN = ~BLKA_int & RESET_int  & ~WENA_int;
assign BLKB_WEN = ~BLKB_int & RESET_int  & ~WENB_int;

buf b0  ( CLKA_int,       CLKA );
buf b1  ( CLKB_int,       CLKB );
buf b2  ( WENA_int,       WENA );
buf b3  ( WENB_int,       WENB );
 
buf b4  ( DINA0_int,     DINA0 );
buf b5  ( DINA1_int,     DINA1 );
buf b6  ( DINA2_int,     DINA2 );
buf b7  ( DINA3_int,     DINA3 );
buf b8  ( DINA4_int,     DINA4 );
buf b9  ( DINA5_int,     DINA5 );
buf b10 ( DINA6_int,     DINA6 );
buf b11 ( DINA7_int,     DINA7 );
buf b12 ( DINA8_int,     DINA8 );
 

buf b13 ( DINB0_int,     DINB0 );
buf b14 ( DINB1_int,     DINB1 );
buf b15 ( DINB2_int,     DINB2 );
buf b16 ( DINB3_int,     DINB3 );
buf b17 ( DINB4_int,     DINB4 );
buf b18 ( DINB5_int,     DINB5 );
buf b19 ( DINB6_int,     DINB6 );
buf b20 ( DINB7_int,     DINB7 );
buf b21 ( DINB8_int,     DINB8 );

buf b22 ( ADDRA0_int,   ADDRA0 );
buf b23 ( ADDRA1_int,   ADDRA1 );
buf b24 ( ADDRA2_int,   ADDRA2 );
buf b25 ( ADDRA3_int,   ADDRA3 );
buf b26 ( ADDRA4_int,   ADDRA4 );
buf b27 ( ADDRA5_int,   ADDRA5 );
buf b28 ( ADDRA6_int,   ADDRA6 );
buf b29 ( ADDRA7_int,   ADDRA7 );
buf b30 ( ADDRA8_int,   ADDRA8 );
buf b31 ( ADDRA9_int,   ADDRA9 );
buf b32 ( ADDRA10_int, ADDRA10 );
buf b33 ( ADDRA11_int, ADDRA11 );
 
buf b34 ( ADDRB0_int,   ADDRB0 );
buf b35 ( ADDRB1_int,   ADDRB1 );
buf b36 ( ADDRB2_int,   ADDRB2 );
buf b37 ( ADDRB3_int,   ADDRB3 );
buf b38 ( ADDRB4_int,   ADDRB4 );
buf b39 ( ADDRB5_int,   ADDRB5 );
buf b40 ( ADDRB6_int,   ADDRB6 );
buf b41 ( ADDRB7_int,   ADDRB7 );
buf b42 ( ADDRB8_int,   ADDRB8 );
buf b43 ( ADDRB9_int,   ADDRB9 );
buf b44 ( ADDRB10_int, ADDRB10 );
buf b45 ( ADDRB11_int, ADDRB11 );

buf b46 ( RESET_int,     RESET );
buf b47 ( BLKA_int,       BLKA );
buf b48 ( BLKB_int,       BLKB );
buf b49 ( PIPEA_int,     PIPEA );
buf b50 ( PIPEB_int,     PIPEB );
buf b51 ( WMODEA_int,   WMODEA );
buf b52 ( WMODEB_int,   WMODEB );

buf b53 ( WIDTHA1_int, WIDTHA1 );
buf b54 ( WIDTHA0_int, WIDTHA0 );
buf b55 ( WIDTHB1_int, WIDTHB1 );
buf b56 ( WIDTHB0_int, WIDTHB0 );

  // Instantiation of core ram4k9 cell with pure functionality

  CORERAM4K9 STATCONFIG (

                .ADDRA11 ( ADDRA11_int ), .ADDRA10 ( ADDRA10_int ), .ADDRA9 ( ADDRA9_int ), 
                .ADDRA8  ( ADDRA8_int  ), .ADDRA7  ( ADDRA7_int  ), .ADDRA6 ( ADDRA6_int ),
                .ADDRA5  ( ADDRA5_int  ), .ADDRA4  ( ADDRA4_int  ), .ADDRA3 ( ADDRA3_int ),
                .ADDRA2  ( ADDRA2_int  ), .ADDRA1  ( ADDRA1_int  ), .ADDRA0 ( ADDRA0_int ), 
                .DINA8   ( DINA8_int   ), .DINA7   ( DINA7_int   ), .DINA6  ( DINA6_int  ),
                .DINA5   ( DINA5_int   ), .DINA4   ( DINA4_int   ), .DINA3  ( DINA3_int  ), 
                .DINA2   ( DINA2_int   ), .DINA1   ( DINA1_int   ), .DINA0  ( DINA0_int  ),
                .DOUTA8  ( DOUTA8      ), .DOUTA7  ( DOUTA7      ), .DOUTA6 ( DOUTA6     ),
                .DOUTA5  ( DOUTA5      ), .DOUTA4  ( DOUTA4      ), .DOUTA3 ( DOUTA3     ),
                .DOUTA2  ( DOUTA2      ), .DOUTA1  ( DOUTA1      ), .DOUTA0 ( DOUTA0     ),
                .WIDTHA1 ( WIDTHA1_int ), .WIDTHA0 ( WIDTHA0_int ), .PIPEA  ( PIPEA_int  ), 
                .WMODEA  ( WMODEA_int  ), .BLKA    ( BLKA_int    ), .WENA   ( WENA_int   ),
                .CLKA    ( CLKA_int    ),
                .ADDRB11 ( ADDRB11_int ), .ADDRB10 ( ADDRB10_int ), .ADDRB9 ( ADDRB9_int ), 
                .ADDRB8  ( ADDRB8_int  ), .ADDRB7  ( ADDRB7_int  ), .ADDRB6 ( ADDRB6_int ), 
                .ADDRB5  ( ADDRB5_int  ), .ADDRB4  ( ADDRB4_int  ), .ADDRB3 ( ADDRB3_int ),
                .ADDRB2  ( ADDRB2_int  ), .ADDRB1  ( ADDRB1_int  ), .ADDRB0 ( ADDRB0_int ),
                .DINB8   ( DINB8_int   ), .DINB7   ( DINB7_int   ), .DINB6  ( DINB6_int  ),
                .DINB5   ( DINB5_int   ), .DINB4   ( DINB4_int   ), .DINB3  ( DINB3_int  ),
                .DINB2   ( DINB2_int   ), .DINB1   ( DINB1_int   ), .DINB0  ( DINB0_int  ),
                .DOUTB8  ( DOUTB8      ), .DOUTB7  ( DOUTB7      ), .DOUTB6 ( DOUTB6     ),
                .DOUTB5  ( DOUTB5      ), .DOUTB4  ( DOUTB4      ), .DOUTB3 ( DOUTB3     ),
                .DOUTB2  ( DOUTB2      ), .DOUTB1  ( DOUTB1      ), .DOUTB0 ( DOUTB0     ),
                .WIDTHB1 ( WIDTHB1_int ), .WIDTHB0 ( WIDTHB0_int ), .PIPEB  ( PIPEB_int  ), 
                .WMODEB  ( WMODEB_int  ), .BLKB    ( BLKB_int    ), .WENB   ( WENB_int   ),
                .CLKB    ( CLKB_int    ), 
                .RESET   ( RESET_int   )
   
             );

  defparam STATCONFIG.DYNAMIC = 0;
  defparam STATCONFIG.MEMORYFILE = MEMORYFILE;
  defparam STATCONFIG.WARNING_MSGS_ON = WARNING_MSGS_ON;


  // timing section
  specify

      specparam   LibName     = "fusion";
      (posedge CLKA => (DOUTA0+:DOUTA0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA1+:DOUTA1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA2+:DOUTA2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA3+:DOUTA3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA4+:DOUTA4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA5+:DOUTA5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA6+:DOUTA6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA7+:DOUTA7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA8+:DOUTA8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (posedge CLKB => (DOUTB0+:DOUTB0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB1+:DOUTB1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB2+:DOUTB2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB3+:DOUTB3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB4+:DOUTB4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB5+:DOUTB5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB6+:DOUTB6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB7+:DOUTB7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB8+:DOUTB8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);


      (negedge RESET => (DOUTA0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (negedge RESET => (DOUTB0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);


      $width(posedge CLKA, 0.0, 0, NOTIFY_REG);
      $width(negedge CLKA, 0.0, 0, NOTIFY_REG);
      $width(posedge CLKB, 0.0, 0, NOTIFY_REG);
      $width(negedge CLKB, 0.0, 0, NOTIFY_REG);

     
      $setup(posedge ADDRA11, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA11, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA11, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA11, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA10, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA10, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA10, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA10, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA9, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA9, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA9, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA9, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA8, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA8, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA8, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA8, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA7, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA7, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA7, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA7, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA6, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA6, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA6, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA6, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA5, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA5, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA5, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA5, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA4, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA4, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA4, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA4, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA3, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA3, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA3, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA3, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA2, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA2, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA2, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA2, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA1, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA1, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA1, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA1, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA0, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA0, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA0, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA0, 0.0, NOTIFY_REG);

      $setup(posedge DINA8, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA8, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA8, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA8, 0.0, NOTIFY_REG);
      $setup(posedge DINA7, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA7, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA7, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA7, 0.0, NOTIFY_REG);
      $setup(posedge DINA6, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA6, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA6, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA6, 0.0, NOTIFY_REG);
      $setup(posedge DINA5, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA5, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA5, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA5, 0.0, NOTIFY_REG);
      $setup(posedge DINA4, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA4, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA4, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA4, 0.0, NOTIFY_REG);
      $setup(posedge DINA3, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA3, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA3, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA3, 0.0, NOTIFY_REG);
      $setup(posedge DINA2, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA2, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA2, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA2, 0.0, NOTIFY_REG);
      $setup(posedge DINA1, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA1, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA1, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA1, 0.0, NOTIFY_REG);
      $setup(posedge DINA0, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA0, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA0, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA0, 0.0, NOTIFY_REG);


      $setup(posedge WENA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WENA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, posedge WENA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&&RESET, negedge WENA, 0.0, NOTIFY_REG);

      $setup(posedge BLKA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge BLKA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, posedge BLKA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, negedge BLKA, 0.0, NOTIFY_REG);

      $recovery(posedge RESET, posedge CLKA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA,posedge RESET, 0.0, NOTIFY_REG);
      
      $recovery(posedge RESET, posedge CLKB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB,posedge RESET, 0.0, NOTIFY_REG);

      $width(negedge RESET, 0.0, 0, NOTIFY_REG);


      $setup(posedge ADDRB11, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB11, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB11, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB11, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB10, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB10, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB10, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB10, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB9, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB9, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB9, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB9, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB8, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB8, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB8, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB8, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB7, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB7, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB7, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB7, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB6, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB6, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB6, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB6, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB5, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB5, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB5, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB5, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB4, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB4, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB4, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB4, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB3, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB3, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB3, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB3, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB2, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB2, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB2, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB2, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB1, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB1, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB1, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB1, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB0, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB0, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB0, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB0, 0.0, NOTIFY_REG);

      $setup(posedge DINB8, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB8, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB8, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB8, 0.0, NOTIFY_REG);
      $setup(posedge DINB7, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB7, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB7, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB7, 0.0, NOTIFY_REG);
      $setup(posedge DINB6, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB6, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB6, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB6, 0.0, NOTIFY_REG);
      $setup(posedge DINB5, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB5, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB5, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB5, 0.0, NOTIFY_REG);
      $setup(posedge DINB4, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB4, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB4, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB4, 0.0, NOTIFY_REG);
      $setup(posedge DINB3, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB3, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB3, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB3, 0.0, NOTIFY_REG);
      $setup(posedge DINB2, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB2, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB2, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB2, 0.0, NOTIFY_REG);
      $setup(posedge DINB1, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB1, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB1, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB1, 0.0, NOTIFY_REG);
      $setup(posedge DINB0, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB0, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB0, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB0, 0.0, NOTIFY_REG);


      $setup(posedge WENB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WENB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, posedge WENB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, negedge WENB, 0.0, NOTIFY_REG);

      $setup(posedge BLKB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge BLKB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, posedge BLKB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, negedge BLKB, 0.0, NOTIFY_REG);

   endspecify
 endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE RAM4K9 ----

//---- MODULE RAM512X18 ----
/*-----------------------------------------------------------------
 CELL NAME : RAM512X18
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 100 ps / 10 ps

module RAM512X18(RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0,
                     WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0,
                     RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,
                     RD3,RD2,RD1,RD0,WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,
                     WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0,RW1,WW1,RW0,WW0,REN,RCLK,WEN,WCLK,RESET,PIPE); 


input RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0;
input WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0;
input WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0;
input RW1,WW1,RW0, WW0,REN,RCLK,WEN,WCLK,RESET,PIPE;

output RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,RD3,RD2,RD1,RD0;

wire RDP17,RDP16,RDP15,RDP14,RDP13,RDP12,RDP11,RDP10,RDP9,RDP8,RDP7,RDP6,RDP5,RDP4,RDP3,RDP2,RDP1,RDP0;

wire RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int;
wire WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int;
wire WD17_int,WD16_int,WD15_int,WD14_int,WD13_int,WD12_int,WD11_int,WD10_int,WD9_int,WD8_int;
wire WD7_int,WD6_int,WD5_int,WD4_int,WD3_int,WD2_int,WD1_int,WD0_int;
wire REN_int,RCLK_int,WEN_int,WCLK_int,RESET_int,PIPE_int;

wire RENABLE;
wire WENABLE;

reg NOTIFY_REG;




`define WADDR_BUS {WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int}
`define RADDR_BUS {RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int}

parameter MEMORYFILE = "";
`ifdef WARNING_MSGS_ON
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
`else
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
`endif
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.

assign RENABLE = ~REN_int & RESET_int;
assign WENABLE = ~WEN_int & RESET_int;

buf b0 ( WCLK_int,   WCLK );
buf b1 ( RCLK_int,   RCLK );
buf b2 ( WEN_int,     WEN );
buf b3 ( REN_int,     REN );
buf b4 ( RESET_int, RESET );

buf b5(RADDR8_int, RADDR8);
buf b6(RADDR7_int, RADDR7);
buf b7(RADDR6_int, RADDR6);
buf b8(RADDR5_int, RADDR5);
buf b9(RADDR4_int, RADDR4);
buf b10(RADDR3_int, RADDR3);
buf b11(RADDR2_int, RADDR2);
buf b12(RADDR1_int, RADDR1);
buf b13(RADDR0_int, RADDR0);

buf b14(WADDR8_int, WADDR8);
buf b15(WADDR7_int, WADDR7);
buf b16(WADDR6_int, WADDR6);
buf b17(WADDR5_int, WADDR5);
buf b18(WADDR4_int, WADDR4);
buf b19(WADDR3_int, WADDR3);
buf b20(WADDR2_int, WADDR2);
buf b21(WADDR1_int, WADDR1);
buf b22(WADDR0_int, WADDR0);

buf b23(WD17_int, WD17);
buf b24(WD16_int, WD16);
buf b25(WD15_int, WD15);
buf b26(WD14_int, WD14);
buf b27(WD13_int, WD13);
buf b28(WD12_int, WD12);
buf b29(WD11_int, WD11);
buf b30(WD10_int, WD10);
buf b31(WD9_int, WD9);
buf b32(WD8_int, WD8);
buf b33(WD7_int, WD7);
buf b34(WD6_int, WD6);
buf b35(WD5_int, WD5);
buf b36(WD4_int, WD4);
buf b37(WD3_int, WD3);
buf b38(WD2_int, WD2);
buf b39(WD1_int, WD1);
buf b40(WD0_int, WD0);
buf b41(PIPE_int,PIPE);

buf b42 ( WW1_int, WW1 );
buf b43 ( WW0_int, WW0 );
buf b44 ( RW1_int, RW1 );
buf b45 ( RW0_int, RW0 );

pmos inst0(RD17, RDP17, 0);
pmos inst1(RD16, RDP16, 0);
pmos inst2(RD15, RDP15, 0);
pmos inst3(RD14, RDP14, 0);
pmos inst4(RD13, RDP13, 0);
pmos inst5(RD12, RDP12, 0);
pmos inst6(RD11, RDP11, 0);
pmos inst7(RD10, RDP10, 0);
pmos inst8(RD9, RDP9, 0);
pmos inst9(RD8, RDP8, 0);
pmos inst10(RD7, RDP7, 0);
pmos inst11(RD6, RDP6, 0);
pmos inst12(RD5, RDP5, 0);
pmos inst13(RD4, RDP4, 0);
pmos inst14(RD3, RDP3, 0);
pmos inst15(RD2, RDP2, 0);
pmos inst16(RD1, RDP1, 0);
pmos inst17(RD0, RDP0, 0);

  CORERAM512X18 STATCONFIG (
                .RADDR8  ( RADDR8_int  ), .RADDR7  ( RADDR7_int  ), .RADDR6 ( RADDR6_int ),
                .RADDR5  ( RADDR5_int  ), .RADDR4  ( RADDR4_int  ), .RADDR3 ( RADDR3_int ),
                .RADDR2  ( RADDR2_int  ), .RADDR1  ( RADDR1_int  ), .RADDR0 ( RADDR0_int ),
                .WADDR8  ( WADDR8_int  ), .WADDR7  ( WADDR7_int  ), .WADDR6 ( WADDR6_int ),
                .WADDR5  ( WADDR5_int  ), .WADDR4  ( WADDR4_int  ), .WADDR3 ( WADDR3_int ),
                .WADDR2  ( WADDR2_int  ), .WADDR1  ( WADDR1_int  ), .WADDR0 ( WADDR0_int ),
                .RD17    ( RDP17       ), .RD16    ( RDP16       ), .RD15   ( RDP15      ),
                .RD14    ( RDP14       ), .RD13    ( RDP13       ), .RD12   ( RDP12      ),
                .RD11    ( RDP11       ), .RD10    ( RDP10       ), .RD9    ( RDP9       ),
                .RD8     ( RDP8        ), .RD7     ( RDP7        ), .RD6    ( RDP6       ),
                .RD5     ( RDP5        ), .RD4     ( RDP4        ), .RD3    ( RDP3       ),
                .RD2     ( RDP2        ), .RD1     ( RDP1        ), .RD0    ( RDP0       ),
                .WD17    ( WD17_int    ), .WD16    ( WD16_int    ), .WD15   ( WD15_int   ),
                .WD14    ( WD14_int    ), .WD13    ( WD13_int    ), .WD12   ( WD12_int   ),
                .WD11    ( WD11_int    ), .WD10    ( WD10_int    ), .WD9    ( WD9_int    ),
                .WD8     ( WD8_int     ), .WD7     ( WD7_int     ), .WD6    ( WD6_int    ),
                .WD5     ( WD5_int     ), .WD4     ( WD4_int     ), .WD3    ( WD3_int    ),
                .WD2     ( WD2_int     ), .WD1     ( WD1_int     ), .WD0    ( WD0_int    ),
                .RW1     ( RW1_int     ), .RW0     ( RW0_int     ), .REN    ( REN_int    ),
                .RCLK    ( RCLK_int    ), .WCLK    ( WCLK_int    ), .PIPE   ( PIPE_int   ),
                .WW1     ( WW1_int     ), .WW0     ( WW0_int     ), .WEN    ( WEN_int    ),
                .RESET   ( RESET_int   )

               );

  defparam STATCONFIG.DYNAMIC = 0;
  defparam STATCONFIG.MEMORYFILE = MEMORYFILE;
  defparam STATCONFIG.WARNING_MSGS_ON = WARNING_MSGS_ON;

  specify

      specparam   LibName     = "fusion";
      (posedge RCLK => (RD0+:RD0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD1+:RD1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD2+:RD2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD3+:RD3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD4+:RD4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD5+:RD5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD6+:RD6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD7+:RD7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD8+:RD8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD9+:RD9) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD10+:RD10) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD11+:RD11) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD12+:RD12) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD13+:RD13) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD14+:RD14) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD15+:RD15) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD16+:RD16) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD17+:RD17) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (negedge RESET => (RD0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD9+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD10+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD11+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD12+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD13+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD14+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD15+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD16+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD17+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

 
      $setup(posedge RADDR8, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG);
      $setup(negedge RADDR8, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RENABLE, posedge RADDR8, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RENABLE, negedge RADDR8, 0.0, NOTIFY_REG);
      $setup(posedge RADDR7, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR7, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR7, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR7, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR6, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR6, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR6, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR6, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR5, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR5, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR5, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR5, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR4, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR4, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR4, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR4, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR3, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR3, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR3, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR3, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR2, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR2, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR2, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR2, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR1, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR1, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR1, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR1, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR0, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR0, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR0, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR0, 0.0, NOTIFY_REG);

      $setup(posedge REN, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge REN, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge REN, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge REN, 0.0, NOTIFY_REG);
 

      $setup(posedge WADDR8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR8, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR8, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR7, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR7, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR6, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR6, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR5, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR5, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR4, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR4, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR3, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR3, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR2, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR2, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR1, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR1, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR0, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR0, 0.0, NOTIFY_REG); 

      $setup(posedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD17, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD17, 0.0, NOTIFY_REG); 
      $setup(posedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD16, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD16, 0.0, NOTIFY_REG); 
      $setup(posedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD15, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD15, 0.0, NOTIFY_REG); 
      $setup(posedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD14, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD14, 0.0, NOTIFY_REG); 
      $setup(posedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD13, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD13, 0.0, NOTIFY_REG); 
      $setup(posedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD12, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD12, 0.0, NOTIFY_REG); 
      $setup(posedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD11, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD11, 0.0, NOTIFY_REG); 
      $setup(posedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD10, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD10, 0.0, NOTIFY_REG); 
      $setup(posedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD9, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD9, 0.0, NOTIFY_REG);

      $setup(posedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD8, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD8, 0.0, NOTIFY_REG); 
      $setup(posedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD7, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD7, 0.0, NOTIFY_REG); 
      $setup(posedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD6, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD6, 0.0, NOTIFY_REG); 
      $setup(posedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD5, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD5, 0.0, NOTIFY_REG); 
      $setup(posedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD4, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD4, 0.0, NOTIFY_REG); 
      $setup(posedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD3, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD3, 0.0, NOTIFY_REG); 
      $setup(posedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD2, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD2, 0.0, NOTIFY_REG); 
      $setup(posedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD1, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD1, 0.0, NOTIFY_REG); 
      $setup(posedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD0, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD0, 0.0, NOTIFY_REG);

      $setup(posedge WEN, posedge WCLK, 0.0, NOTIFY_REG); 
      $setup(negedge WEN, posedge WCLK, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK, posedge WEN, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK, negedge WEN, 0.0, NOTIFY_REG); 
 
      $recovery(posedge RESET, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK,posedge RESET, 0.0, NOTIFY_REG);

      $recovery(posedge RESET, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK,posedge RESET, 0.0, NOTIFY_REG);

      $width(negedge RESET, 0.0, 0, NOTIFY_REG);
      $width(posedge RCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge RCLK, 0.0, 0, NOTIFY_REG);
      $width(posedge WCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge WCLK, 0.0, 0, NOTIFY_REG);
 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE RAM512X18 ----

//---- MODULE FLEXRAM4K9 ----
/*-----------------------------------------------------------------
 CELL NAME : FLEXRAM4K9
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 100 ps  / 10 ps

module FLEXRAM4K9 (
          ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5, 
          ADDRA4,  ADDRA3,  ADDRA2, ADDRA1, ADDRA0, DINA8,  DINA7,  DINA6,
          DINA5,   DINA4,   DINA3,  DINA2,  DINA1,  DINA0,  DOUTA8, DOUTA7,
          DOUTA6,  DOUTA5,  DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0,
          WIDTHA1, WIDTHA0, PIPEA,  WMODEA, BLKA,   WENA,   CLKA,
          ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5,
          ADDRB4,  ADDRB3,  ADDRB2, ADDRB1, ADDRB0, DINB8,  DINB7,  DINB6,
          DINB5,   DINB4,   DINB3,  DINB2,  DINB1,  DINB0,  DOUTB8, DOUTB7,
          DOUTB6,  DOUTB5,  DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0,
          WIDTHB1, WIDTHB0, PIPEB,  WMODEB, BLKB,   WENB,   CLKB,   RESET
       );


input ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5, ADDRA4, ADDRA3, ADDRA2, ADDRA1, ADDRA0;
input DINA8,   DINA7,   DINA6,  DINA5,  DINA4,  DINA3,  DINA2, DINA1, DINA0;
input WIDTHA1, WIDTHA0, PIPEA,  WMODEA, BLKA,   WENA,   CLKA;

input ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5, ADDRB4, ADDRB3, ADDRB2, ADDRB1, ADDRB0;
input DINB8,   DINB7,   DINB6,  DINB5,  DINB4,  DINB3,  DINB2,  DINB1,  DINB0;
input WIDTHB1, WIDTHB0, PIPEB,  WMODEB, BLKB,   WENB,   CLKB,   RESET;

output DOUTA8, DOUTA7, DOUTA6, DOUTA5, DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0;
output DOUTB8, DOUTB7, DOUTB6, DOUTB5, DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0; 

wire CLKA_int,    CLKB_int;
wire WENA_int,    WENB_int,    WMODEA_int,  WMODEB_int;
wire BLKA_int,    BLKB_int,    RESET_int,   PIPEA_int,   PIPEB_int;
wire WIDTHA1_int, WIDTHA0_int, WIDTHB1_int, WIDTHB0_int;

wire ADDRA11_int, ADDRA10_int, ADDRA9_int, ADDRA8_int, ADDRA7_int, ADDRA6_int;
wire ADDRA5_int,  ADDRA4_int,  ADDRA3_int, ADDRA2_int, ADDRA1_int, ADDRA0_int;

wire ADDRB11_int, ADDRB10_int, ADDRB9_int, ADDRB8_int, ADDRB7_int, ADDRB6_int;
wire ADDRB5_int,  ADDRB4_int,  ADDRB3_int, ADDRB2_int, ADDRB1_int, ADDRB0_int;

wire DINA8_int, DINA7_int, DINA6_int, DINA5_int, DINA4_int, DINA3_int, DINA2_int, DINA1_int, DINA0_int;
wire DINB8_int, DINB7_int, DINB6_int, DINB5_int, DINB4_int, DINB3_int, DINB2_int, DINB1_int, DINB0_int;

reg NOTIFY_REG;

wire BLKA_EN;
wire BLKB_EN;

wire BLKA_WEN;
wire BLKB_WEN;

parameter MEMORYFILE = "";
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.

assign BLKA_EN  = ~BLKA_int & RESET_int;
assign BLKB_EN  = ~BLKB_int & RESET_int;
assign BLKA_WEN = ~BLKA_int & RESET_int  & ~WENA_int;
assign BLKB_WEN = ~BLKB_int & RESET_int  & ~WENB_int;

buf b0  ( CLKA_int,       CLKA );
buf b1  ( CLKB_int,       CLKB );
buf b2  ( WENA_int,       WENA );
buf b3  ( WENB_int,       WENB );
 
buf b4  ( DINA0_int,     DINA0 );
buf b5  ( DINA1_int,     DINA1 );
buf b6  ( DINA2_int,     DINA2 );
buf b7  ( DINA3_int,     DINA3 );
buf b8  ( DINA4_int,     DINA4 );
buf b9  ( DINA5_int,     DINA5 );
buf b10 ( DINA6_int,     DINA6 );
buf b11 ( DINA7_int,     DINA7 );
buf b12 ( DINA8_int,     DINA8 );
 

buf b13 ( DINB0_int,     DINB0 );
buf b14 ( DINB1_int,     DINB1 );
buf b15 ( DINB2_int,     DINB2 );
buf b16 ( DINB3_int,     DINB3 );
buf b17 ( DINB4_int,     DINB4 );
buf b18 ( DINB5_int,     DINB5 );
buf b19 ( DINB6_int,     DINB6 );
buf b20 ( DINB7_int,     DINB7 );
buf b21 ( DINB8_int,     DINB8 );

buf b22 ( ADDRA0_int,   ADDRA0 );
buf b23 ( ADDRA1_int,   ADDRA1 );
buf b24 ( ADDRA2_int,   ADDRA2 );
buf b25 ( ADDRA3_int,   ADDRA3 );
buf b26 ( ADDRA4_int,   ADDRA4 );
buf b27 ( ADDRA5_int,   ADDRA5 );
buf b28 ( ADDRA6_int,   ADDRA6 );
buf b29 ( ADDRA7_int,   ADDRA7 );
buf b30 ( ADDRA8_int,   ADDRA8 );
buf b31 ( ADDRA9_int,   ADDRA9 );
buf b32 ( ADDRA10_int, ADDRA10 );
buf b33 ( ADDRA11_int, ADDRA11 );
 
buf b34 ( ADDRB0_int,   ADDRB0 );
buf b35 ( ADDRB1_int,   ADDRB1 );
buf b36 ( ADDRB2_int,   ADDRB2 );
buf b37 ( ADDRB3_int,   ADDRB3 );
buf b38 ( ADDRB4_int,   ADDRB4 );
buf b39 ( ADDRB5_int,   ADDRB5 );
buf b40 ( ADDRB6_int,   ADDRB6 );
buf b41 ( ADDRB7_int,   ADDRB7 );
buf b42 ( ADDRB8_int,   ADDRB8 );
buf b43 ( ADDRB9_int,   ADDRB9 );
buf b44 ( ADDRB10_int, ADDRB10 );
buf b45 ( ADDRB11_int, ADDRB11 );

buf b46 ( RESET_int,     RESET );
buf b47 ( BLKA_int,       BLKA );
buf b48 ( BLKB_int,       BLKB );
buf b49 ( PIPEA_int,     PIPEA );
buf b50 ( PIPEB_int,     PIPEB );
buf b51 ( WMODEA_int,   WMODEA );
buf b52 ( WMODEB_int,   WMODEB );

buf b53 ( WIDTHA1_int, WIDTHA1 );
buf b54 ( WIDTHA0_int, WIDTHA0 );
buf b55 ( WIDTHB1_int, WIDTHB1 );
buf b56 ( WIDTHB0_int, WIDTHB0 );

  // Instantiation of core ram4k9 cell with pure functionality

  CORERAM4K9 DYNCONFIG (

                .ADDRA11 ( ADDRA11_int ), .ADDRA10 ( ADDRA10_int ), .ADDRA9 ( ADDRA9_int ), 
                .ADDRA8  ( ADDRA8_int  ), .ADDRA7  ( ADDRA7_int  ), .ADDRA6 ( ADDRA6_int ),
                .ADDRA5  ( ADDRA5_int  ), .ADDRA4  ( ADDRA4_int  ), .ADDRA3 ( ADDRA3_int ),
                .ADDRA2  ( ADDRA2_int  ), .ADDRA1  ( ADDRA1_int  ), .ADDRA0 ( ADDRA0_int ), 
                .DINA8   ( DINA8_int   ), .DINA7   ( DINA7_int   ), .DINA6  ( DINA6_int  ),
                .DINA5   ( DINA5_int   ), .DINA4   ( DINA4_int   ), .DINA3  ( DINA3_int  ), 
                .DINA2   ( DINA2_int   ), .DINA1   ( DINA1_int   ), .DINA0  ( DINA0_int  ),
                .DOUTA8  ( DOUTA8      ), .DOUTA7  ( DOUTA7      ), .DOUTA6 ( DOUTA6     ),
                .DOUTA5  ( DOUTA5      ), .DOUTA4  ( DOUTA4      ), .DOUTA3 ( DOUTA3     ),
                .DOUTA2  ( DOUTA2      ), .DOUTA1  ( DOUTA1      ), .DOUTA0 ( DOUTA0     ),
                .WIDTHA1 ( WIDTHA1_int ), .WIDTHA0 ( WIDTHA0_int ), .PIPEA  ( PIPEA_int  ), 
                .WMODEA  ( WMODEA_int  ), .BLKA    ( BLKA_int    ), .WENA   ( WENA_int   ),
                .CLKA    ( CLKA_int    ),
                .ADDRB11 ( ADDRB11_int ), .ADDRB10 ( ADDRB10_int ), .ADDRB9 ( ADDRB9_int ), 
                .ADDRB8  ( ADDRB8_int  ), .ADDRB7  ( ADDRB7_int  ), .ADDRB6 ( ADDRB6_int ), 
                .ADDRB5  ( ADDRB5_int  ), .ADDRB4  ( ADDRB4_int  ), .ADDRB3 ( ADDRB3_int ),
                .ADDRB2  ( ADDRB2_int  ), .ADDRB1  ( ADDRB1_int  ), .ADDRB0 ( ADDRB0_int ),
                .DINB8   ( DINB8_int   ), .DINB7   ( DINB7_int   ), .DINB6  ( DINB6_int  ),
                .DINB5   ( DINB5_int   ), .DINB4   ( DINB4_int   ), .DINB3  ( DINB3_int  ),
                .DINB2   ( DINB2_int   ), .DINB1   ( DINB1_int   ), .DINB0  ( DINB0_int  ),
                .DOUTB8  ( DOUTB8      ), .DOUTB7  ( DOUTB7      ), .DOUTB6 ( DOUTB6     ),
                .DOUTB5  ( DOUTB5      ), .DOUTB4  ( DOUTB4      ), .DOUTB3 ( DOUTB3     ),
                .DOUTB2  ( DOUTB2      ), .DOUTB1  ( DOUTB1      ), .DOUTB0 ( DOUTB0     ),
                .WIDTHB1 ( WIDTHB1_int ), .WIDTHB0 ( WIDTHB0_int ), .PIPEB  ( PIPEB_int  ), 
                .WMODEB  ( WMODEB_int  ), .BLKB    ( BLKB_int    ), .WENB   ( WENB_int   ),
                .CLKB    ( CLKB_int    ), 
                .RESET   ( RESET_int   )
   
             );

  defparam DYNCONFIG.DYNAMIC = 1;
  defparam DYNCONFIG.MEMORYFILE = MEMORYFILE;
  defparam DYNCONFIG.WARNING_MSGS_ON = WARNING_MSGS_ON;

  
  // timing section
  specify

      specparam   LibName     = "fusion";
      (posedge CLKA => (DOUTA0+:DOUTA0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA1+:DOUTA1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA2+:DOUTA2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA3+:DOUTA3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA4+:DOUTA4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA5+:DOUTA5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA6+:DOUTA6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA7+:DOUTA7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA8+:DOUTA8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (posedge CLKB => (DOUTB0+:DOUTB0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB1+:DOUTB1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB2+:DOUTB2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB3+:DOUTB3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB4+:DOUTB4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB5+:DOUTB5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB6+:DOUTB6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB7+:DOUTB7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB8+:DOUTB8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);


      (negedge RESET => (DOUTA0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (negedge RESET => (DOUTB0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);


      $width(posedge CLKA, 0.0, 0, NOTIFY_REG);
      $width(negedge CLKA, 0.0, 0, NOTIFY_REG);
      $width(posedge CLKB, 0.0, 0, NOTIFY_REG);
      $width(negedge CLKB, 0.0, 0, NOTIFY_REG);

     
      $setup(posedge ADDRA11, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA11, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA11, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA11, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA10, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA10, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA10, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA10, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA9, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA9, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA9, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA9, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA8, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA8, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA8, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA8, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA7, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA7, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA7, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA7, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA6, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA6, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA6, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA6, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA5, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA5, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA5, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA5, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA4, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA4, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA4, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA4, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA3, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA3, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA3, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA3, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA2, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA2, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA2, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA2, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA1, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA1, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA1, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA1, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA0, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA0, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA0, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA0, 0.0, NOTIFY_REG);

      $setup(posedge DINA8, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA8, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA8, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA8, 0.0, NOTIFY_REG);
      $setup(posedge DINA7, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA7, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA7, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA7, 0.0, NOTIFY_REG);
      $setup(posedge DINA6, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA6, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA6, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA6, 0.0, NOTIFY_REG);
      $setup(posedge DINA5, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA5, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA5, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA5, 0.0, NOTIFY_REG);
      $setup(posedge DINA4, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA4, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA4, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA4, 0.0, NOTIFY_REG);
      $setup(posedge DINA3, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA3, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA3, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA3, 0.0, NOTIFY_REG);
      $setup(posedge DINA2, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA2, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA2, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA2, 0.0, NOTIFY_REG);
      $setup(posedge DINA1, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA1, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA1, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA1, 0.0, NOTIFY_REG);
      $setup(posedge DINA0, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA0, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA0, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA0, 0.0, NOTIFY_REG);


      $setup(posedge WENA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WENA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, posedge WENA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&&RESET, negedge WENA, 0.0, NOTIFY_REG);

      $setup(posedge BLKA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge BLKA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, posedge BLKA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, negedge BLKA, 0.0, NOTIFY_REG);

      $recovery(posedge RESET, posedge CLKA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA,posedge RESET, 0.0, NOTIFY_REG);
      
      $recovery(posedge RESET, posedge CLKB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB,posedge RESET, 0.0, NOTIFY_REG);

      $width(negedge RESET, 0.0, 0, NOTIFY_REG);


      $setup(posedge ADDRB11, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB11, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB11, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB11, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB10, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB10, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB10, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB10, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB9, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB9, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB9, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB9, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB8, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB8, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB8, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB8, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB7, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB7, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB7, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB7, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB6, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB6, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB6, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB6, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB5, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB5, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB5, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB5, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB4, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB4, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB4, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB4, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB3, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB3, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB3, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB3, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB2, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB2, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB2, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB2, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB1, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB1, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB1, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB1, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB0, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB0, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB0, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB0, 0.0, NOTIFY_REG);

      $setup(posedge DINB8, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB8, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB8, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB8, 0.0, NOTIFY_REG);
      $setup(posedge DINB7, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB7, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB7, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB7, 0.0, NOTIFY_REG);
      $setup(posedge DINB6, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB6, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB6, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB6, 0.0, NOTIFY_REG);
      $setup(posedge DINB5, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB5, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB5, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB5, 0.0, NOTIFY_REG);
      $setup(posedge DINB4, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB4, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB4, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB4, 0.0, NOTIFY_REG);
      $setup(posedge DINB3, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB3, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB3, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB3, 0.0, NOTIFY_REG);
      $setup(posedge DINB2, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB2, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB2, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB2, 0.0, NOTIFY_REG);
      $setup(posedge DINB1, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB1, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB1, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB1, 0.0, NOTIFY_REG);
      $setup(posedge DINB0, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB0, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB0, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB0, 0.0, NOTIFY_REG);


      $setup(posedge WENB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WENB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, posedge WENB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, negedge WENB, 0.0, NOTIFY_REG);

      $setup(posedge BLKB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge BLKB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, posedge BLKB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, negedge BLKB, 0.0, NOTIFY_REG);

   endspecify
 endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE FLEXRAM4K9 ----

//---- MODULE FLEXRAM512X18 ----
/*-----------------------------------------------------------------
 CELL NAME : FLEXRAM512X18
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 100 ps / 10 ps

module FLEXRAM512X18(RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0,
                     WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0,
                     RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,
                     RD3,RD2,RD1,RD0,WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,
                     WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0,RW1,WW1,RW0,WW0,REN,RCLK,WEN,WCLK,RESET,PIPE); 


input RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0;
input WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0;
input WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0;
input RW1,WW1,RW0, WW0,REN,RCLK,WEN,WCLK,RESET,PIPE;

output RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,RD3,RD2,RD1,RD0;

wire RDP17,RDP16,RDP15,RDP14,RDP13,RDP12,RDP11,RDP10,RDP9,RDP8,RDP7,RDP6,RDP5,RDP4,RDP3,RDP2,RDP1,RDP0;

wire RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int;
wire WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int;
wire WD17_int,WD16_int,WD15_int,WD14_int,WD13_int,WD12_int,WD11_int,WD10_int,WD9_int,WD8_int;
wire WD7_int,WD6_int,WD5_int,WD4_int,WD3_int,WD2_int,WD1_int,WD0_int;
wire REN_int,RCLK_int,WEN_int,WCLK_int,RESET_int,PIPE_int;

wire RENABLE;
wire WENABLE;


reg NOTIFY_REG;

`define WADDR_BUS {WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int}
`define RADDR_BUS {RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int}

parameter MEMORYFILE = "";
`ifdef WARNING_MSGS_ON
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
`else
parameter WARNING_MSGS_ON = 0; // Used to turn off warnings about read &
`endif
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.

assign RENABLE = ~REN_int & RESET_int;
assign WENABLE = ~WEN_int & RESET_int;

buf b0 ( WCLK_int,   WCLK );
buf b1 ( RCLK_int,   RCLK );
buf b2 ( WEN_int,     WEN );
buf b3 ( REN_int,     REN );
buf b4 ( RESET_int, RESET );

buf b5(RADDR8_int, RADDR8);
buf b6(RADDR7_int, RADDR7);
buf b7(RADDR6_int, RADDR6);
buf b8(RADDR5_int, RADDR5);
buf b9(RADDR4_int, RADDR4);
buf b10(RADDR3_int, RADDR3);
buf b11(RADDR2_int, RADDR2);
buf b12(RADDR1_int, RADDR1);
buf b13(RADDR0_int, RADDR0);

buf b14(WADDR8_int, WADDR8);
buf b15(WADDR7_int, WADDR7);
buf b16(WADDR6_int, WADDR6);
buf b17(WADDR5_int, WADDR5);
buf b18(WADDR4_int, WADDR4);
buf b19(WADDR3_int, WADDR3);
buf b20(WADDR2_int, WADDR2);
buf b21(WADDR1_int, WADDR1);
buf b22(WADDR0_int, WADDR0);

buf b23(WD17_int, WD17);
buf b24(WD16_int, WD16);
buf b25(WD15_int, WD15);
buf b26(WD14_int, WD14);
buf b27(WD13_int, WD13);
buf b28(WD12_int, WD12);
buf b29(WD11_int, WD11);
buf b30(WD10_int, WD10);
buf b31(WD9_int, WD9);
buf b32(WD8_int, WD8);
buf b33(WD7_int, WD7);
buf b34(WD6_int, WD6);
buf b35(WD5_int, WD5);
buf b36(WD4_int, WD4);
buf b37(WD3_int, WD3);
buf b38(WD2_int, WD2);
buf b39(WD1_int, WD1);
buf b40(WD0_int, WD0);
buf b41(PIPE_int,PIPE);

buf b42 ( WW1_int, WW1 );
buf b43 ( WW0_int, WW0 );
buf b44 ( RW1_int, RW1 );
buf b45 ( RW0_int, RW0 );

pmos inst0(RD17, RDP17, 0);
pmos inst1(RD16, RDP16, 0);
pmos inst2(RD15, RDP15, 0);
pmos inst3(RD14, RDP14, 0);
pmos inst4(RD13, RDP13, 0);
pmos inst5(RD12, RDP12, 0);
pmos inst6(RD11, RDP11, 0);
pmos inst7(RD10, RDP10, 0);
pmos inst8(RD9, RDP9, 0);
pmos inst9(RD8, RDP8, 0);
pmos inst10(RD7, RDP7, 0);
pmos inst11(RD6, RDP6, 0);
pmos inst12(RD5, RDP5, 0);
pmos inst13(RD4, RDP4, 0);
pmos inst14(RD3, RDP3, 0);
pmos inst15(RD2, RDP2, 0);
pmos inst16(RD1, RDP1, 0);
pmos inst17(RD0, RDP0, 0);

  CORERAM512X18 DYNCONFIG (
                .RADDR8  ( RADDR8_int  ), .RADDR7  ( RADDR7_int  ), .RADDR6 ( RADDR6_int ),
                .RADDR5  ( RADDR5_int  ), .RADDR4  ( RADDR4_int  ), .RADDR3 ( RADDR3_int ),
                .RADDR2  ( RADDR2_int  ), .RADDR1  ( RADDR1_int  ), .RADDR0 ( RADDR0_int ),
                .WADDR8  ( WADDR8_int  ), .WADDR7  ( WADDR7_int  ), .WADDR6 ( WADDR6_int ),
                .WADDR5  ( WADDR5_int  ), .WADDR4  ( WADDR4_int  ), .WADDR3 ( WADDR3_int ),
                .WADDR2  ( WADDR2_int  ), .WADDR1  ( WADDR1_int  ), .WADDR0 ( WADDR0_int ),
                .RD17    ( RDP17       ), .RD16    ( RDP16       ), .RD15   ( RDP15      ),
                .RD14    ( RDP14       ), .RD13    ( RDP13       ), .RD12   ( RDP12      ),
                .RD11    ( RDP11       ), .RD10    ( RDP10       ), .RD9    ( RDP9       ),
                .RD8     ( RDP8        ), .RD7     ( RDP7        ), .RD6    ( RDP6       ),
                .RD5     ( RDP5        ), .RD4     ( RDP4        ), .RD3    ( RDP3       ),
                .RD2     ( RDP2        ), .RD1     ( RDP1        ), .RD0    ( RDP0       ),
                .WD17    ( WD17_int    ), .WD16    ( WD16_int    ), .WD15   ( WD15_int   ),
                .WD14    ( WD14_int    ), .WD13    ( WD13_int    ), .WD12   ( WD12_int   ),
                .WD11    ( WD11_int    ), .WD10    ( WD10_int    ), .WD9    ( WD9_int    ),
                .WD8     ( WD8_int     ), .WD7     ( WD7_int     ), .WD6    ( WD6_int    ),
                .WD5     ( WD5_int     ), .WD4     ( WD4_int     ), .WD3    ( WD3_int    ),
                .WD2     ( WD2_int     ), .WD1     ( WD1_int     ), .WD0    ( WD0_int    ),
                .RW1     ( RW1_int     ), .RW0     ( RW0_int     ), .REN    ( REN_int    ),
                .RCLK    ( RCLK_int    ), .WCLK    ( WCLK_int    ), .PIPE   ( PIPE_int   ),
                .WW1     ( WW1_int     ), .WW0     ( WW0_int     ), .WEN    ( WEN_int    ),
                .RESET   ( RESET_int   )

               );

  defparam DYNCONFIG.DYNAMIC = 1;
  defparam DYNCONFIG.MEMORYFILE = MEMORYFILE;
  defparam DYNCONFIG.WARNING_MSGS_ON = WARNING_MSGS_ON;

  specify

      specparam   LibName     = "fusion";
      (posedge RCLK => (RD0+:RD0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD1+:RD1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD2+:RD2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD3+:RD3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD4+:RD4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD5+:RD5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD6+:RD6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD7+:RD7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD8+:RD8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD9+:RD9) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD10+:RD10) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD11+:RD11) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD12+:RD12) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD13+:RD13) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD14+:RD14) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD15+:RD15) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD16+:RD16) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD17+:RD17) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (negedge RESET => (RD0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD9+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD10+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD11+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD12+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD13+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD14+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD15+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD16+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD17+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

 
      $setup(posedge RADDR8, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG);
      $setup(negedge RADDR8, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RENABLE, posedge RADDR8, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RENABLE, negedge RADDR8, 0.0, NOTIFY_REG);
      $setup(posedge RADDR7, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR7, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR7, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR7, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR6, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR6, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR6, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR6, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR5, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR5, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR5, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR5, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR4, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR4, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR4, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR4, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR3, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR3, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR3, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR3, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR2, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR2, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR2, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR2, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR1, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR1, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR1, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR1, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR0, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR0, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR0, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR0, 0.0, NOTIFY_REG);

      $setup(posedge REN, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge REN, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge REN, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge REN, 0.0, NOTIFY_REG);
 

      $setup(posedge WADDR8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR8, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR8, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR7, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR7, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR6, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR6, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR5, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR5, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR4, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR4, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR3, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR3, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR2, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR2, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR1, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR1, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR0, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR0, 0.0, NOTIFY_REG); 

      $setup(posedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD17, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD17, 0.0, NOTIFY_REG); 
      $setup(posedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD16, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD16, 0.0, NOTIFY_REG); 
      $setup(posedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD15, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD15, 0.0, NOTIFY_REG); 
      $setup(posedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD14, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD14, 0.0, NOTIFY_REG); 
      $setup(posedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD13, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD13, 0.0, NOTIFY_REG); 
      $setup(posedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD12, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD12, 0.0, NOTIFY_REG); 
      $setup(posedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD11, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD11, 0.0, NOTIFY_REG); 
      $setup(posedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD10, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD10, 0.0, NOTIFY_REG); 
      $setup(posedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD9, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD9, 0.0, NOTIFY_REG);

      $setup(posedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD8, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD8, 0.0, NOTIFY_REG); 
      $setup(posedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD7, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD7, 0.0, NOTIFY_REG); 
      $setup(posedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD6, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD6, 0.0, NOTIFY_REG); 
      $setup(posedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD5, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD5, 0.0, NOTIFY_REG); 
      $setup(posedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD4, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD4, 0.0, NOTIFY_REG); 
      $setup(posedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD3, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD3, 0.0, NOTIFY_REG); 
      $setup(posedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD2, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD2, 0.0, NOTIFY_REG); 
      $setup(posedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD1, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD1, 0.0, NOTIFY_REG); 
      $setup(posedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD0, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD0, 0.0, NOTIFY_REG);

      $setup(posedge WEN, posedge WCLK, 0.0, NOTIFY_REG); 
      $setup(negedge WEN, posedge WCLK, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK, posedge WEN, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK, negedge WEN, 0.0, NOTIFY_REG); 
 
      $recovery(posedge RESET, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK,posedge RESET, 0.0, NOTIFY_REG);

      $recovery(posedge RESET, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK,posedge RESET, 0.0, NOTIFY_REG);

      $width(negedge RESET, 0.0, 0, NOTIFY_REG);
      $width(posedge RCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge RCLK, 0.0, 0, NOTIFY_REG);
      $width(posedge WCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge WCLK, 0.0, 0, NOTIFY_REG);
 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE FLEXRAM512X18 ----

//---- MODULE NVM ----
//************************************************************************************
//     Copyright (C) 2002. Actel Corporation  - All Rights Reserved.
//                      PROPRIETARY INFORMATION
//
//     This document is CONFIDENATIAL and PROPRIETARY and is for
//     the use of Actel Corporation personnel only, except to the
//     extent that permission is expressly granted elsewhere.
//
// File Name   :    nvm.v
// Author      :    Sreenivasulu Angitapalli 
//
// Function    :    NVM Model for G3SoC
//
//************************************************************************************
// Detailed Revision History:
//
// Rev. Date(YY/MM/DD)   Submitter              Description
//
// 1.0  01/20/05         Sreeni Angitapalli     First Version
// 
// 1.1  02/28/05         Sreeni Angitapalli     Port Names updated. Aux Block 
//                                              fields are now initialised. PAGE
//                                              STATUS not dependent on AUXBLOCK
// 
// 1.2  03/25/05         Sreeni Angitapalli     Updates as per NVM Req. rev1.5.
//                                              (dated, 08/15/04). SAR fixes.
// 
// 1.3  04/03/05         Sreeni Angitapalli     SAR fixes. PIPE read added.
//                                              Timing checked added.
//
// 1.4  04/11/05         Sreeni Angitapalli     SAR fixes.
//
// 1.5  04/29/05         Sreeni Angitapalli     READNEXT implemented. PIPE read 
//                                              updated. Updates NVM. Req. ver1.6
//
// 1.6  05/31/05         Sreeni Angitapalli     Fixes for issues with READNEXT
//                                              from RTL test-suite
//
// 1.7  11/01/05         Sreeni Angitapalli     Implementation changed to state machine
//                                              based for better maintenance.
//                                              Passed all RTL BMOD tests.
//
// 1.8  11/11/05         Sreeni Angitapalli     Implementation changed to state machine
//                                              based for better maintenance.
//                                              Passed all RTL BMOD tests.
//
// 1.9  03/09/06         Sreeni Angitapalli     Added Over Threshold flag generation logic
//                                              to page status read.
//
// 2.0  05/01/06         Sreeni Angitapalli     Replaced $readmemh with logic built around
//                                              $fopen and $fgets to work-around problem
//                                              with Cadence NC-Vlog/Verilog (SARno54852)
//
// 2.1  07/05/06         Sreeni Angitapalli     Period check for pin CLK hard-coded to 10ns
//                                              as requested by TPP (SARno55352)
//
// 2.2  10/11/06         Sreeni Angitapalli     Fix program+overwrite page aux block copying
//                                              issue reported in SARno59645
//
// This model is being developed for delivery to customers as part of CAE
// Verilog library. The model will handle 3-level logic (0,1,X).
//
// Specifications:
// ***************
// Reference specs are G3SoC Architecture specification(rev.9), NVM Requirement
// Spec. (rev1.6) and FUSION CAE Library Specfication(rev4.3).
//
// Memory File Initialisation feature is enabled. File format should conform 
// to the format documented in FUSION CAE Library Specfication(rev4.3)
//
// LOCKREQUEST pin is not modeled. Needed for jtag access.
//
// Cycle-accuracy:
// ***************
// All operations except Program are modelled close to cycle-accuracy of RTL.
// Program operation has 2 modes. Default, fast mode, BUSY is asserted for 4us.
// User can edit the netlist and over-ride the parameter FAST_SIM to "0". BUSY
// BUSY will be asserted for 8.4us which is close to real hardware.
//
// Verification Status:
// ********************
// a. Passed unit level testing for all individual operations and sequences.
// b. Passed all operations exercised through RTL BMOD test-suite
//
// Known Issues:
// a. BUSY assertion for certain combinations of READ+READNEXT is not cycle-accurate
//    compared to RTL. But, Read data matches at all times (sampled when BUSY=0).
// 
//************************************************************************************

`timescale 1ns/100ps

module NVM ( 

   // input port definitions

   ADDR,             // input address for read or write
   WD,               // read/write data
   DATAWIDTH,        // read/write data width select, can chose 8/16/32 on WD, RD
   REN,              // read control signal
   READNEXT,         // burst for successive read/writes
   PAGESTATUS,       // status of page will be output, when set along with read
   WEN,              // write control signal
   ERASEPAGE,        // erase contents of page in AB 
   PROGRAM,          // copy contents in AB to CA (program)
   SPAREPAGE,        // spare page access
   AUXBLOCK,         // auxiliary block access
   UNPROTECTPAGE,    // unprotect page command
   OVERWRITEPAGE,    // when asserted with program, overwrite page in CA with that in AB
   DISCARDPAGE,      // discard page in AB
   OVERWRITEPROTECT, // with program, set overwrite protect bit in aux block in CA
   PAGELOSSPROTECT,  // protect page contents in AB
   PIPE,             // active high, pipelined read, 6 clks/5 clks  
   LOCKREQUEST,      // active low, locks out NVM from pc_access
   CLK,              // clock, rising edge triggered
   RESET,            // active low reset
 
   // output port definitions
            
   RD,               // read data from NVM, select 8/16/32 controlled by WIDTH
   BUSY,             // when asserted, indicates nvm cannot handle a new command
   STATUS            // status of command executed, to be sampled when BUSY is low
 
);

`ifdef WARNING_MSGS_ON
  parameter WARNING_MSGS_ON = 1; 
`else
  parameter WARNING_MSGS_ON = 1; 
`endif
   // input port declarations
  
   input [ 17 : 0 ]     ADDR;
   input [ 31 : 0 ]     WD;
   input [  1 : 0 ]     DATAWIDTH;
   input                REN;
   input                READNEXT;
   input                PAGESTATUS;
   input                WEN;
   input                ERASEPAGE;
   input                PROGRAM;
   input                SPAREPAGE;
   input                AUXBLOCK;
   input                UNPROTECTPAGE;
   input                OVERWRITEPAGE;
   input                DISCARDPAGE;
   input                OVERWRITEPROTECT;
   input                PAGELOSSPROTECT;
   input                PIPE;
   input                LOCKREQUEST;
   input                CLK;
   input                RESET;
 
   // output port declarations
 
   output [ 31 : 0 ]    RD;
   output               BUSY;
   output [  1 : 0 ]    STATUS;
 
   // registers driven by internal logic, connected to pmos cells for driving outputs
   reg    [ 31 : 0 ]    RD_zd;
   reg                  BUSY_zd;
   reg    [  1 : 0 ]    STATUS_zd;
 
   reg                  NOTIFY_REG;
 
   wire   [  1 : 0 ]    DATAWIDTH_int;
   wire   [ 17 : 0 ]    ADDR_int;
   wire   [ 31 : 0 ]    WD_int;
 
   // constant declarations, usef for state machine counter to control state transitions
   `define              rd_latency            4 // access time from cell array is 4 clks
   `define              cp_pg_latency        64 // number of cycles for copying page from CA to AB
   `define              rd_ab_latency         1 // page buffer is modeled as register set
   `define              wr_ab_latency         1 // page buffer is modeled as register set
   `define              wr_blk_latency        2 // write to AB, BLK Addr change, asserts BUSY for 3 clks
   `define              erase_error_latency   4 // Erase error assert busy for 4 clock cycles
   `define              sp0_overwrite_latency 9 // Number of busy cycles for sp0 with overwrite page set
   `define              sim_prg_delay      400 // 4us delay for program, for faster functional simulations
   `define              real_prg_delay  8400000 // 8.4ms, closer to real-time, for post-layout simulations

   `define              sim_rst_latency       3 // 3 clock simulated delay for BUSY de-assertion on RESET removal
   `define              real_rst_delay    25000 // 25us real delay for BUSY de-assertion on RESET removal
  
   `define              RD_BYTE RD_zd  [  7:0 ] 
   `define              RD_WORD RD_zd  [ 15:0 ] 
   `define              RD_QUAD RD_zd  [ 31:0 ] 
 
   `define              OVWRPRTC             70
   `define              WRPRTC               71
   `define              RDPRTC              128
   `define              WR_CNT            95:72
   `define              USER_DATA        127:96
 
   // user configurable, simulation specific parameters
 
   // MEMORYFILE parameter for pre-loading NVM
   parameter            MEMORYFILE = "";
 
   // fast simulation is the default option, BUSY is asserted for 4us in response to PROGRAM operaiton.
   // user could override parameter     FAST_SIM in netlist to 0, seeking real delay which is approx. 8.4ms 
 
   parameter            FAST_SIM   = 1;
 
   // if write count exceeds WR_THR, returns status code 11                          
   parameter            WR_THR     = 24'd1024;
   
   // state values for main state machine 

   parameter            CHK_CLK_RST      = 0; 
   parameter            RST_UNKNOWN      = 1; 
   parameter            POWERON_RESET    = 2; 
   parameter            CLK_UNKNOWN      = 3; 
   parameter            SAMPLE_CMD       = 4; 
   parameter            RD_DATA          = 5; 
   parameter            RD_LAST_WR       = 6; 
   parameter            COPY_PAGE_CA     = 7; 
   parameter            COPY_PAGE_CA1    = 8; 
   parameter            WR_DIFF_BLK      = 9; 
   parameter            WR_DIFF_BLK1     = 10; 
   parameter            WR_UPDATE_DATA   = 11; 
   parameter            WAIT_SP0_OVWR    = 12; 
   parameter            WAIT_SP0_OVWR1   = 13; 
   parameter            UPDATE_PG_CA     = 14; 
   parameter            UPDATE_PG_CA1    = 15; 
   parameter            PR_CHK_OVWRPRTC  = 16; 
   parameter            RD_BLK_DLY       = 17; 
   parameter            RD_BLK_DLY1      = 18; 
   parameter            PR_OVWR_PROP     = 19; 
   parameter            PR_CHK_PROP      = 20; 
   parameter            RD_WAIT_CA       = 21; 
   parameter            RD_NEXT_BUSY     = 22; 
   parameter            DS_AB_INVALID    = 23; 
   parameter            ER_CHK_OVWRPRTC  = 24; 
   parameter            ER_CHK_OVWRPRTC1 = 25; 
   parameter            ER_AB_DLY        = 26; 
   parameter            ER_AB_DLY1       = 27; 
   parameter            UN_AB_PROP       = 28; 
   parameter            RD_WR_PIPE       = 29; 
   parameter            REMOVE_RESET     = 30; 

   // state values for nvm cell array access state machine 

   parameter            RD_BLK_CA        =  0; 
   parameter            RD_BLK_CA1       =  1; 
   parameter            RD_DATA_CA       =  2; 
   parameter            RD_PIPE_DR       =  3; 
 
   // state variables for main state machine 

   reg [ 4 : 0 ]        CURR_STATE     = 4'b0; 
   reg [ 4 : 0 ]        NEXT_STATE     = 4'b0; 

   // state variables for nvm cell array access state machine 
   reg [ 1 : 0 ]        RD_CA_CS       = 2'b0; 
   reg [ 1 : 0 ]        RD_CA_NS       = 2'b0; 

   // variable for internal memory array, page and block buffers

   reg [ 139 : 0 ]      MEM_64K_140[0:65535];
   reg [ 139 : 0 ]      ASM_BUF[0:9];
   reg [ 139 : 0 ]      ASM_BH;
   reg [ 139 : 0 ]      BH;
   reg [ 139 : 0 ]      DR;
   reg [ 139 : 0 ]      AUX_BLK;
   reg [ 139 : 0 ]      AUX_BLK1;

   // internal variables

   reg                   LAST_CYCLE_WRITE;
   reg                   CURR_CYCLE_WRITE;
   reg                   BUSY_INIT;
   reg                   BUSY_REN;
   reg                   BUSY_WEN;
   reg                   BUSY_PRGM;
   reg                   BUSY_UNPR;
   reg                   BUSY_DSCR;
   reg                   BUSY_ER;
   reg [  1 : 0 ]        STATUS_INIT;
   reg [  1 : 0 ]        STATUS_REN;
   reg [  1 : 0 ]        STATUS_WEN;
   reg [  1 : 0 ]        STATUS_PRGM;
   reg [  1 : 0 ]        STATUS_UNPR;
   reg [  1 : 0 ]        STATUS_DSCR;
   reg [  1 : 0 ]        STATUS_ER;
   reg [ 19 : 0 ]        MEM_ADDR;
   reg [ 19 : 0 ]        PG_ADDR;
   reg [ 19 : 0 ]        WR_ADDR;
   reg [ 19 : 0 ]        AB_ADDR;
   reg [ 19 : 0 ]        CA_ADDR;
   reg [ 19 : 0 ]        DR_ADDR;
   reg [ 19 : 0 ]        PR_ADDR;
   reg [ 19 : 0 ]        UN_ADDR;
   reg [ 19 : 0 ]        ER_ADDR;
   reg [ 19 : 0 ]        NEXT_ADDR;
   reg [ 19 : 0 ]        R_ADDR;
   reg [ 19 : 0 ]        OVWR_ADDR;
   reg [ 31 : 0 ]        WR_DATA;

   reg                   R_PAGESTATUS;
   reg                   R_READNEXT;
   reg                   R_PAGELOSSPROTECT;
   reg                   R_SPAREPAGE;
   reg                   R_AUXBLOCK;
   reg                   R_OVERWRITEPAGE;
   reg                   R_OVERWRITEPROTECT;
   reg                   R_PIPE;
   reg                   PREV_PAGESTATUS;
   reg                   RD_INIT;
   reg                   RD_COMPLETE;
   reg                   AB_MOD;
   reg                   AB_VALID;
   reg                   DR_VALID;
   reg                   CA_VALID;
   reg                   AB_UNPRTC;
   reg                   RD_DR;
   reg                   RD_AB;
   reg                   RD_CA;
   reg                   RD_ACTIVE;
   reg                   WR_ACTIVE;
   reg                   PR_ACTIVE;
   reg                   UN_ACTIVE;
   reg                   ER_ACTIVE;
   reg                   ERASE_SP0;
 
   integer               WR_WIDTH;
   integer               RD_WIDTH;
   integer               TIMER_COUNT;
 
   // loop variables for initialising contents of aux block

   integer               i, page, sector;           

   // variables for detecting clock period and converting absolute delay into number of clocks

   reg                   PERIOD_SAMPLED   = 1'b0;
   reg                   FIRST_CLK        = 1'b0;
   reg                   SECOND_CLK       = 1'b0;
   time                  FIRST_EDGE;
   integer               SIM_PRG_LATENCY  = 10;
   integer               REAL_PRG_LATENCY = 21000;
   integer               REAL_RST_LATENCY = 1;

   // memory file initialisation logic variables; replaces $readmemh system task

   reg [ 36*8-1 : 0 ]    STR_REG;          // to hold 35 addr or data chars and one new line char(\n)
   reg [ 139    : 0 ]    BIN_STR_RT;       // return value of function for converting string to binary
   integer               FILE_PTR;         // file descriptor returned by $fopen
   integer               MEM_INDEX = 0;    // index for loading memory file data into memory array
 
   // instantiate buffers for viewing port delayed version of input signals
 
   buf  buf_ren      ( REN_int,              REN              );
   buf  buf_rdnext   ( READNEXT_int,         READNEXT         );
   buf  buf_pgstatus ( PAGESTATUS_int,       PAGESTATUS       );
   buf  buf_wen      ( WEN_int,              WEN              );
   buf  buf_erase    ( ERASEPAGE_int,        ERASEPAGE        );
   buf  buf_program  ( PROGRAM_int,          PROGRAM          );
   buf  buf_sppage   ( SPAREPAGE_int,        SPAREPAGE        );
   buf  buf_auxblk   ( AUXBLOCK_int,         AUXBLOCK         );
   buf  buf_unprtc   ( UNPROTECTPAGE_int,    UNPROTECTPAGE    );
   buf  buf_ovwrpg   ( OVERWRITEPAGE_int,    OVERWRITEPAGE    );
   buf  buf_dscrd    ( DISCARDPAGE_int,      DISCARDPAGE      );
   buf  buf_ovwrprtc ( OVERWRITEPROTECT_int, OVERWRITEPROTECT );
   buf  buf_pglsprtc ( PAGELOSSPROTECT_int,  PAGELOSSPROTECT  );
   buf  buf_pipe     ( PIPE_int,             PIPE             );
   buf  buf_reset    ( RESET_int,            RESET            );
   buf  buf_clock    ( CLK_int,              CLK              );
 
   // generate logic to instantiate buffers for viewing port delayed version of input signals

   genvar           index;
 
   generate
     for ( index = 0; index < 2; index = index + 1 )
       begin : dwidth_buffers
         buf buf_dwidth ( DATAWIDTH_int [ index ], DATAWIDTH [ index ] );
       end
   endgenerate
 
   generate
     for ( index = 0; index < 18; index = index + 1 )
       begin : addr_buffers
         buf buf_addr   ( ADDR_int [ index ],      ADDR [ index ]      );
       end
   endgenerate
 
   generate
     for ( index = 0; index < 32; index = index + 1 )
       begin : wd_buffers
         buf buf_wd     ( WD_int [ index ],        WD [ index ]        );
       end
   endgenerate
 
   // generate logic to instantiate pmos cells for driving RD, STATUS (acceptance with ncverilog)
 
   generate
     for ( index = 0; index < 32; index = index + 1 )
       begin : rd_drivers
         pmos pmos_rd     ( RD [ index ],     RD_zd [ index ],     0   );
       end
   endgenerate
  
   generate
     for ( index = 0; index < 2; index = index + 1 )
       begin : status_drivers
         pmos pmos_status ( STATUS [ index ], STATUS_zd [ index ], 0   );
       end
   endgenerate
 
   pmos pmos_busy         ( BUSY,              BUSY_zd,            0   );
 
 
   // internal signals for conditionally applying timing checks
 
   wire   SAMPLE_REN        = ( RESET_int        &&  !BUSY              );
   wire   SAMPLE_WEN        = ( SAMPLE_REN       &&  !REN_int           );
   wire   SAMPLE_ERASEPAGE  = ( SAMPLE_WEN       &&  !WEN_int           );
   wire   SAMPLE_PROGRAM    = ( SAMPLE_ERASEPAGE &&  !ERASEPAGE_int     );
   wire   SAMPLE_UNPROTECT  = ( SAMPLE_PROGRAM   &&  !PROGRAM_int       );
   wire   SAMPLE_DISCARD    = ( SAMPLE_UNPROTECT &&  !UNPROTECTPAGE_int );
 
   wire   TCHK_REN          = ( SAMPLE_REN  &&   REN_int );
   wire   TCHK_WEN          = ( SAMPLE_REN  &&  !REN_int &&  WEN_int );
   wire   TCHK_ERASEPAGE    = ( SAMPLE_REN  &&  !REN_int && !WEN_int &&  ERASEPAGE_int );
   wire   TCHK_PROGRAM      = ( SAMPLE_REN  &&  !REN_int && !WEN_int && !ERASEPAGE_int &&
                                                                           PROGRAM_int );
   wire   TCHK_UNPROTECT    = ( SAMPLE_REN  &&  !REN_int && !WEN_int && !ERASEPAGE_int &&
                                                     !PROGRAM_int && UNPROTECTPAGE_int );
   wire   TCHK_DISCARD      = ( SAMPLE_REN  &&  !REN_int && !WEN_int && !ERASEPAGE_int &&
                                 !PROGRAM_int && !UNPROTECTPAGE_int && DISCARDPAGE_int );
 
   // common signal to enable timing checks on block, byte level address bits (write, read)
   wire   TCHK_BLK_ADDR     = ( TCHK_REN || TCHK_WEN );
 
   // common signal to enable timing checks on page level address bits, sparepage signal
   wire   TCHK_PAGE_ADDR    = ( TCHK_REN || TCHK_WEN || TCHK_ERASEPAGE || TCHK_PROGRAM || 
                                                        TCHK_UNPROTECT || TCHK_DISCARD );

   // --------------------------------------
   // memory file initialisation capability
   // --------------------------------------
 
   initial
   begin
      // initialize page levele protections to factory default values ("0")

      for ( sector = 0; sector < 64; sector = sector + 1 )
      begin
         for ( page = 0; page < 33; page = page + 1 )
         begin
            if ( ( sector == 0 ) && ( page == 32 ) )
            begin
               //$display( " Module %m: Note: skipping initialisation, Sector0-SparePage-AuxBlock " );
            end
            else
            begin
               AUX_BLK = MEM_64K_140 [ { sector [ 5:0 ], page [ 5:0 ], 1'b1, 3'b0 } ];
               AUX_BLK [    `RDPRTC ] =  1'b0;
               AUX_BLK [    `WR_CNT ] = 24'b0;
               AUX_BLK [    `WRPRTC ] =  1'b0;
               AUX_BLK [  `OVWRPRTC ] =  1'b0;
               AUX_BLK [ `USER_DATA ] = 32'b0;
               MEM_64K_140 [ { sector [ 5:0 ], page [ 5:0 ], 1'b1, 3'b0 } ] = AUX_BLK;
            end
         end
      end

      // if memory initialisation file is present, pre-load contents into memory arrary 

      if ( MEMORYFILE != "" )
      begin
         //$readmemh ( MEMORYFILE, MEM_64K_140 );

         // replaced $readmemh system task with logic build around $fopen and $fgets system tasks
         FILE_PTR = $fopen( MEMORYFILE, "r" );

         if ( FILE_PTR == 0 )
         begin
                       if ( WARNING_MSGS_ON )
            $display( " ************************************************************************************ " );
                       if ( WARNING_MSGS_ON )
            $display( " Module %m: Note: FAILED TO OPEN MEMORY INITIALIZATION FILE IN READ MODE " );
                       if ( WARNING_MSGS_ON )
            $display( " ************************************************************************************ " );
         end

         // read each line as a string if file is opened successfully (FILE_PTR is non-zero) and index is within
         // limits (0-65355) until end-of-file is reached ($fgets returns 0)

         while ( ( FILE_PTR != 0 ) && ( MEM_INDEX < 65536 ) && $fgets( STR_REG, FILE_PTR ) )
         begin
            if ( STR_REG [ 287 : 280 ] == "@" )
            begin
              BIN_STR_RT = fun_conv_str_bin( {"0", STR_REG [ 279 : 8 ]} );  // replace "@" with "0" in addr string
              MEM_INDEX  = BIN_STR_RT [ 15 : 0 ];
            end
            else
            begin
              MEM_64K_140 [ MEM_INDEX ] = fun_conv_str_bin( STR_REG[ 287 : 8 ] ); // data string conversion
              MEM_INDEX  = MEM_INDEX + 1; 
            end 
         end

         $fclose( FILE_PTR );
      end
      else
      begin
                       if ( WARNING_MSGS_ON )
         $display( " ************************************************************************************ " );
                       if ( WARNING_MSGS_ON )
         $display( " Module %m: Note: memory initialization file parameter MEMORYFILE not defined " );
                       if ( WARNING_MSGS_ON )
         $display( " ************************************************************************************ " );
      end
   end

   function [ 139 : 0 ] fun_conv_str_bin;

      input [ 279 : 0 ] mem_string;
      integer           str_ind;
      reg   [   7 : 0 ] str_ch;
      reg   [   3 : 0 ] bin_ch;
      reg   [ 139 : 0 ] bin_str;

      begin
         // convert each character (in hexadecimal format) of input string to its binary equivalent
         for ( str_ind = 0; str_ind < 280; str_ind = str_ind + 8 ) begin
            // load a character (8 bits) from lsbs of input string into str_ch variable
            str_ch = mem_string[ 7 : 0 ];
            case ( str_ch )
               "F" : bin_ch = 4'b1111;
               "f" : bin_ch = 4'b1111;
               "E" : bin_ch = 4'b1110;
               "e" : bin_ch = 4'b1110;
               "D" : bin_ch = 4'b1101;
               "d" : bin_ch = 4'b1101;
               "C" : bin_ch = 4'b1100;
               "c" : bin_ch = 4'b1100;
               "B" : bin_ch = 4'b1011;
               "b" : bin_ch = 4'b1011;
               "A" : bin_ch = 4'b1010;
               "a" : bin_ch = 4'b1010;
               "9" : bin_ch = 4'b1001;
               "8" : bin_ch = 4'b1000;
               "7" : bin_ch = 4'b0111;
               "6" : bin_ch = 4'b0110;
               "5" : bin_ch = 4'b0101;
               "4" : bin_ch = 4'b0100;
               "3" : bin_ch = 4'b0011;
               "2" : bin_ch = 4'b0010;
               "1" : bin_ch = 4'b0001;
               "0" : bin_ch = 4'b0000;
               default :
                     begin
                       if ( WARNING_MSGS_ON )
                        $display( " Module %m: Error: MEMORY INITIALIZATION FILE HAS INVALID DATA CHARACTERS = %s", str_ch );
                        $stop;
                     end
            endcase
            // load the binary equivalent at msbs of bin_str variable
            bin_str [ 139 : 136 ] = bin_ch;
            // right shift binary variable until last character is encountered
            if ( str_ind < 272 )
               bin_str = bin_str >> 4 ;
            // shift-in a new character for conversion by right shifting input string
            mem_string = mem_string >> 8;
         end
         fun_conv_str_bin = bin_str;
      end

   endfunction

 
   //-------------------------------------------------------------------------------------
   // procedure and functional declarations and definitions
   //-------------------------------------------------------------------------------------

   // function to mux data from WD into AB/DR based on read address, data width, aux block;

   function [ 139 : 0 ]  mux_wr_data;

      input [  19 : 0 ]  WR_ADDR; 
      input              WR_WIDTH; 
      input              R_AUXBLOCK; 
      input [ 139 : 0 ]  AUX_BLK; 
      input [  31 : 0 ]  WR_DATA; 

      integer            WR_WIDTH;

      reg   [ 139 : 0 ]  AUX_BLOCK; 

      begin
         case ( WR_WIDTH )
            0 :
              begin
                if ( R_AUXBLOCK )
                begin
                   case ( WR_ADDR % 4)
                      0 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 104], WR_DATA [ 7 : 0 ], AUX_BLK [ 95 : 0 ] };
                               end
                      1 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 112 ], WR_DATA[ 7 : 0 ], AUX_BLK [ 103 : 0 ] };
                               end
                      2 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 120 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 111 : 0 ] };
                               end
                      3 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 128 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 119 : 0 ] };
                               end
                      default :
                               begin
                       if ( WARNING_MSGS_ON )
                                  $display( " ** Warning: WRITE OPERATION: ADDR = %b has unknown bits, WRITE FAILED ", WR_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                  $display( " Time: %0.1f Instance: %m ", $realtime );
                               end
                   endcase 
                end
                else
                begin
                   case ( WR_ADDR % 16 )
                      0 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 8 ], WR_DATA [ 7 : 0 ] };
                               end
                      1 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 16 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 7 : 0 ] };
                               end
                      2 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 24 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 15 : 0 ] };
                               end
                      3 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 32 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 23 : 0 ] };
                               end
                      4 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 40 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 31 : 0 ] };
                               end
                      5 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 48 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 39 : 0 ] };
                               end
                      6 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 56 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 47 : 0 ] };
                               end
                      7 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 64 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 55 : 0 ] };
                               end
                      8 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 72 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 63 : 0 ] };
                               end
                      9 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 80 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 71 : 0 ] };
                               end
                      10 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 88 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 79 : 0 ] };
                               end
                      11 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 96 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 87 : 0 ] };
                               end
                      12 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 104 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 95 : 0 ] };
                               end
                      13 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 112 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 103 : 0 ] };
                               end
                      14 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 120 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 111 : 0 ] };
                               end
                      15 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 128 ], WR_DATA [ 7 : 0 ], AUX_BLK [ 119 : 0 ] };
                               end
                      default :
                               begin
                       if ( WARNING_MSGS_ON )
                                  $display( " ** Warning: WRITE OPERATION: ADDR = %b has unknown bits, WRITE FAILED ", WR_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                  $display( " Time: %0.1f Instance: %m ", $realtime );
                               end
                   endcase 
                end 
             end
           1 :
             begin
                if ( R_AUXBLOCK )
                begin
                   case ( WR_ADDR [ 1 ] )
                      1'b0 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 112 ], WR_DATA [ 15 : 0 ], AUX_BLK [ 95 : 0 ] };
                               end
                      1'b1 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 128 ], WR_DATA [ 15 : 0 ], AUX_BLK [ 111 : 0 ] };
                               end
                      default :
                               begin
                       if ( WARNING_MSGS_ON )
                                  $display( " ** Warning: WRITE OPERATION: ADDR = %b has unknown bits, WRITE FAILED ", WR_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                  $display( " Time: %0.1f Instance: %m ", $realtime );
                               end
                   endcase 
                end
                else
                begin
                   case ( WR_ADDR [ 3 : 1 ] % 8 )
                      0 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 16 ], WR_DATA [ 15 : 0 ] };
                               end
                      1 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 32 ], WR_DATA [ 15 : 0 ], AUX_BLK [ 15 : 0 ] };
                               end
                      2 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [139 : 48 ], WR_DATA [ 15 : 0 ], AUX_BLK [ 31 : 0 ] };
                               end
                      3 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 64 ], WR_DATA [ 15 : 0 ], AUX_BLK [ 47 : 0 ] };
                               end
                      4 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 80 ], WR_DATA [ 15 : 0 ], AUX_BLK [ 63 : 0 ] };
                               end
                      5 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 96], WR_DATA [ 15 : 0 ], AUX_BLK [ 79 : 0 ] };
                               end
                      6 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 112 ], WR_DATA [ 15 : 0 ], AUX_BLK [ 95 : 0 ] };
                               end
                      7 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 128 ], WR_DATA [ 15 : 0 ], AUX_BLK [ 111 : 0 ] };
                               end
                      default :
                               begin
                       if ( WARNING_MSGS_ON )
                                  $display( " ** Warning: WRITE OPERATION: ADDR = %b has unknown bits, WRITE FAILED ", WR_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                  $display( " Time: %0.1f Instance: %m ", $realtime );
                               end
                   endcase 
                end
             end

           2, 3 :
             begin
                if ( R_AUXBLOCK )
                begin
                   AUX_BLOCK = { AUX_BLK [ 139 : 128 ], WR_DATA [ 31 : 0 ], AUX_BLK [ 95 : 0 ] };
                end
                else
                begin
                   case ( WR_ADDR [ 3 : 2 ] % 4 )
                      0 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 32 ], WR_DATA [ 31 : 0 ] }; 
                               end
                      1 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 64 ], WR_DATA [ 31 : 0 ], AUX_BLK [ 31 : 0 ] }; 
                               end
                      2 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 96 ], WR_DATA [ 31 : 0 ], AUX_BLK [ 63 : 0 ] }; 
                               end
                      3 :
                               begin
                                  AUX_BLOCK = { AUX_BLK [ 139 : 128 ], WR_DATA [ 31 : 0 ], AUX_BLK [ 95 : 0 ] };
                               end
                      default :
                               begin
                       if ( WARNING_MSGS_ON )
                                  $display( " ** Warning: WRITE OPERATION: ADDR = %b has unknown bits, WRITE FAILED ", WR_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                  $display( " Time: %0.1f Instance: %m ", $realtime );
                               end
                   endcase 
                end
             end

          default :
             begin
                       if ( WARNING_MSGS_ON )
                $display( " ** Warning: WRITE OPERATION: DATAWIDTH = %b has unknown bits, WRITE FAILED ", WR_WIDTH ); 
                       if ( WARNING_MSGS_ON )
                $display( " Time: %0.1f Instance: %m ", $realtime );
             end
        endcase 

        // return local variable AUX_BLOCK, this block updated will be updated into AB, DR
        mux_wr_data = AUX_BLOCK; 
      end
   endfunction

   // function to mux data on BH onto RD_zd based on read address, data width etc.,; local variable names same as global variables

   function [ 31 : 0 ]  mux_rd_data;

      input [ 19 : 0 ]  R_ADDR; 
      input             RD_WIDTH; 
      input             R_PAGESTATUS; 
      input             R_AUXBLOCK; 
      input [ 139 : 0 ] BH; 

      integer           RD_WIDTH;
      reg   [ 31 : 0 ]  RD_zd; 
      reg               OVER_THR;

      begin
         // initialize RD to all 0s such that data read is updated into desired LSBs only
         RD_zd = 32'h0; 

         // set OVER_THR flag if write count in AUX_BLK[95:72] exceeds user WR_THR
         if ( BH [ 95 : 72 ] > WR_THR ) 
           OVER_THR = 1'b1;
         else
           OVER_THR = 1'b0;

         case ( RD_WIDTH )
            0 :
                     begin
                        if ( R_PAGESTATUS )
                        begin
                           case ( R_ADDR % 4 )
                              0 :
                                       begin
                                          `RD_BYTE = { 2'b0, 2'b0, OVER_THR, BH [ 128], BH [ 71], BH [ 70] };
                                       end
                              1 :
                                       begin
                                          `RD_BYTE = BH [ 79 : 72 ]; 
                                       end
                              2 :
                                       begin
                                          `RD_BYTE = BH [ 87 : 80 ]; 
                                       end
                              3 :
                                       begin
                                          `RD_BYTE = BH [ 95 : 88 ]; 
                                       end
                              default :
                                       begin
                       if ( WARNING_MSGS_ON )
                                          $display( " ** Warning: READ OPERATION: ADDR = %b has unknown bits, READ FAILED ", R_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                          $display( " Time: %0.1f Instance: %m ", $realtime );
                                       end
                           endcase 
                        end
                        else if ( R_AUXBLOCK )
                        begin
                           case ( R_ADDR % 4)
                              0 :
                                       begin
                                          `RD_BYTE = BH [ 103 : 96 ]; 
                                       end
                              1 :
                                       begin
                                          `RD_BYTE = BH [ 111 : 104 ]; 
                                       end
                              2 :
                                       begin
                                          `RD_BYTE = BH [ 119 : 112]; 
                                       end
                              3 :
                                       begin
                                          `RD_BYTE = BH [ 127 : 120]; 
                                       end
                              default :
                                       begin
                       if ( WARNING_MSGS_ON )
                                          $display( " ** Warning: READ OPERATION: ADDR = %b has unknown bits, READ FAILED ", R_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                          $display( " Time: %0.1f Instance: %m ", $realtime );
                                       end
                           endcase 
                        end
                        else
                        begin
                           case ( R_ADDR % 16)
                              0 :
                                       begin
                                          `RD_BYTE = BH [ 7 : 0 ]; 
                                       end
                              1 :
                                       begin
                                          `RD_BYTE = BH [ 15 : 8 ]; 
                                       end
                              2 :
                                       begin
                                          `RD_BYTE = BH [ 23 : 16 ]; 
                                       end
                              3 :
                                       begin
                                          `RD_BYTE = BH [ 31 : 24 ]; 
                                       end
                              4 :
                                       begin
                                          `RD_BYTE = BH [ 39 : 32 ]; 
                                       end
                              5 :
                                       begin
                                          `RD_BYTE = BH [ 47 : 40 ]; 
                                       end
                              6 :
                                       begin
                                          `RD_BYTE = BH [ 55 : 48 ]; 
                                       end
                              7 :
                                       begin
                                          `RD_BYTE = BH [ 63 : 56 ]; 
                                       end
                              8 :
                                       begin
                                          `RD_BYTE = BH [ 71 : 64 ]; 
                                       end
                              9 :
                                       begin
                                          `RD_BYTE = BH [ 79 : 72 ]; 
                                       end
                              10 :
                                       begin
                                          `RD_BYTE = BH [ 87 : 80 ]; 
                                       end
                              11 :
                                       begin
                                          `RD_BYTE = BH [ 95 : 88 ]; 
                                       end
                              12 :
                                       begin
                                          `RD_BYTE = BH [ 103 : 96 ]; 
                                       end
                              13 :
                                       begin
                                          `RD_BYTE = BH [ 111 : 104 ]; 
                                       end
                              14 :
                                       begin
                                          `RD_BYTE = BH [ 119 : 112 ]; 
                                       end
                              15 :
                                       begin
                                          `RD_BYTE = BH [ 127 : 120 ]; 
                                       end
                              default :
                                       begin
                       if ( WARNING_MSGS_ON )
                                          $display( " ** Warning: READ OPERATION: ADDR = %b has unknown bits, READ FAILED ", R_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                          $display( " Time: %0.1f Instance: %m ", $realtime );
                                       end
                           endcase 
                        end 
                     end
            1 :
                     begin
                        if ( R_PAGESTATUS )
                        begin
                           case ( R_ADDR [ 1 ] )
                              1'b0 :
                                       begin
                                          `RD_WORD = { BH [ 79 : 72], 2'b0, 2'b0, OVER_THR, BH [ 128 ], BH [ 71 ], BH [ 70 ] };
                                       end
                              1'b1 :
                                       begin
                                          `RD_WORD = BH [ 95 : 80 ]; 
                                       end
                              default :
                                       begin
                       if ( WARNING_MSGS_ON )
                                          $display( " ** Warning: READ OPERATION: ADDR = %b has unknown bits, READ FAILED ", R_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                          $display( " Time: %0.1f Instance: %m ", $realtime );
                                       end
                           endcase 
                        end
                        else if ( R_AUXBLOCK )
                        begin
                           case ( R_ADDR [ 1 ] )
                              1'b0 :
                                       begin
                                          `RD_WORD = BH [ 111 : 96 ]; 
                                       end
                              1'b1 :
                                       begin
                                          `RD_WORD = BH [ 127 : 112 ]; 
                                       end
                              default :
                                       begin
                       if ( WARNING_MSGS_ON )
                                          $display( " ** Warning: READ OPERATION: ADDR = %b has unknown bits, READ FAILED ", R_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                          $display( " Time: %0.1f Instance: %m ", $realtime );
                                       end
                           endcase 
                        end
                        else
                        begin
                           case ( R_ADDR [ 3 : 1 ] % 8 )
                              0 :
                                       begin
                                          `RD_WORD = BH [ 15 : 0 ]; 
                                       end
                              1 :
                                       begin
                                          `RD_WORD = BH [ 31 : 16 ]; 
                                       end
                              2 :
                                       begin
                                          `RD_WORD = BH [ 47 : 32 ]; 
                                       end
                              3 :
                                       begin
                                          `RD_WORD = BH [ 63 : 48 ]; 
                                       end
                              4 :
                                       begin
                                          `RD_WORD = BH [ 79 : 64 ]; 
                                       end
                              5 :
                                       begin
                                          `RD_WORD = BH [ 95 : 80 ]; 
                                       end
                              6 :
                                       begin
                                          `RD_WORD = BH [ 111 : 96 ]; 
                                       end
                              7 :
                                       begin
                                          `RD_WORD = BH [ 127 : 112 ]; 
                                       end
                              default :
                                       begin
                       if ( WARNING_MSGS_ON )
                                          $display( " ** Warning: READ OPERATION: ADDR = %b has unknown bits, READ FAILED ", R_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                          $display( " Time: %0.1f Instance: %m ", $realtime );
                                       end
                           endcase 
                        end 
                     end
            2, 3 :
                     begin
                        if ( R_PAGESTATUS )
                        begin
                           `RD_QUAD = { BH [ 95 : 72 ], 2'b0, 2'b0, OVER_THR, BH [ 128 ], BH [ 71 ], BH [ 70 ] };
                        end
                        else if ( R_AUXBLOCK )
                        begin
                           `RD_QUAD = BH [ 127 : 96 ]; 
                        end
                        else
                        begin
                           case ( R_ADDR [ 3 : 2 ] % 4)
                              0 :
                                       begin
                                          `RD_QUAD = BH [ 31 : 0 ]; 
                                       end
                              1 :
                                       begin
                                          `RD_QUAD = BH [ 63 : 32 ]; 
                                       end
                              2 :
                                       begin
                                          `RD_QUAD = BH [ 95 : 64 ]; 
                                       end
                              3 :
                                       begin
                                          `RD_QUAD = BH [ 127 : 96 ]; 
                                       end
                              default :
                                       begin
                       if ( WARNING_MSGS_ON )
                                          $display( " ** Warning: READ OPERATION: ADDR = %b has unknown bits, READ FAILED ", R_ADDR ); 
                       if ( WARNING_MSGS_ON )
                                          $display( " Time: %0.1f Instance: %m ", $realtime );
                                       end
                           endcase 
                        end 
                     end
            default :
                     begin
                       if ( WARNING_MSGS_ON )
                        $display( " ** Warning: READ OPERATION: DATAWIDTH = %b has unknown bits, READ FAILED ", RD_WIDTH ); 
                       if ( WARNING_MSGS_ON )
                        $display( " Time: %0.1f Instance: %m ", $realtime );
                     end
         endcase 
         mux_rd_data = RD_zd; // return local variable RD_zd; will be assigned to global RD_zd
      end
   endfunction

   //---------------------------------------------------------------------
   // function to check if 2 input addresses point to different data block
   //---------------------------------------------------------------------

   function diff_block;

      input [ 19 : 0 ] addr1; 
      input [ 19 : 0 ] addr2; 

      reg              is_diff; 

      begin
         is_diff = 1'b0;
         is_diff = ( (  addr1 [ 7 ] !=  addr2 [ 7 ] ) || 
                     (  addr1 [ 7 ] &&  addr2 [ 7 ] && ( addr1 [ 19 : 8 ] != addr2 [ 19 : 8 ] ) ) || 
                     ( !addr1 [ 7 ] && !addr2 [ 7 ] && ( addr1 [ 19 : 4 ] != addr2 [ 19 : 4 ] ) ) );
         diff_block = is_diff; 
      end

   endfunction

   //----------------------------------------------------------------
   // function to check if 2 input addresses point to same data block
   //-----------------------------------------------------------------

   function same_block;

      input [ 19 : 0 ] addr1; 
      input [ 19 : 0 ] addr2; 

      reg              is_same; 

      begin
         is_same = 1'b0;
         is_same = ( ( addr1[19:4] == addr2[19:4] ) || 
                     ( ( addr1[19:8] == addr2[19:8] ) && addr1[7] && addr2[7] ) );
         same_block = is_same; 
      end

   endfunction

   //--------------------------------------------------------------------------
   // function to check if any of the "num_bits" in the input "address" is "x"
   //--------------------------------------------------------------------------

   function is_addr_x;

      input [19:0] address; 
      reg          addr_x; 

      begin
         addr_x = 0; 
         begin : addr_chk 
            integer i;
            for ( i = 0; i <= 19; i = i + 1 )
            begin
               if ( address [ i ] === 1'bx )
               begin
                  addr_x = 1; 
                  disable addr_chk;
               end 
            end
         end 
         is_addr_x = addr_x; 
      end

   endfunction

   //------------------------------------------------------------------------------------
   // function to calculate the next address based on present address, asp, aab signals.

   function [ 19 : 0 ] get_next_addr;

      input [ 19 : 0 ] address; 

      reg   [ 19 : 0 ] next_address; 
      reg              spare_page; 
      reg              aux_block; 

      begin
         next_address = address; 
         spare_page   = address [ 13 ]; 
         aux_block    = address [ 7  ]; 

         if (spare_page && aux_block )
         begin
            next_address [ 19 : 14 ] = address [ 19 : 14 ] + 1; 
         end
         else if ( spare_page  && aux_block != 1'b1 )
         begin
            next_address [ 6 : 4 ]   = address [ 6 : 4 ] + 1; 
            if ( next_address [ 6 : 4 ] == 3'b0 )
            begin
               next_address [ 19 : 14 ] = address [ 19 : 14 ] + 1; 
            end 
         end
         else if ( spare_page != 1'b1 && aux_block )
         begin
            next_address [ 12 : 8 ]     = address [ 12 : 8 ] + 1; 
            if ( next_address [ 12 : 8 ] == 5'b0 )
            begin
               next_address [ 19 : 14 ] = address [ 19 : 14 ] + 1; 
            end 
         end
         else if ( spare_page != 1'b1 && aux_block != 1'b1 )
         begin
            next_address [ 6 :4 ] = address [ 6 : 4 ] + 1; 
            if ( next_address [ 6 : 4 ] == 3'b0 )
            begin
               next_address [ 12 : 8 ] = address [ 12 : 8 ] + 1; 
            end 
            if ( next_address [ 12 : 8 ] == 5'b0 && next_address [ 6 : 4 ] == 3'b0 )
            begin
               next_address [ 19 : 14 ] = address [ 19 : 14 ] + 1; 
            end 
         end 
         get_next_addr = next_address; 
      end

   endfunction

   // initialize certain internal variables, required in the main state machine
   initial
   begin
      TIMER_COUNT  = 0;
      R_PAGESTATUS = 1'b0;
      RD_INIT      = 1'b0;
      RD_COMPLETE  = 1'b0;
   end

   // logic to convert absolute delay to number of clocks required for timer count
   // controlling state transitions
 
   always @ ( posedge CLK_int or negedge RESET_int )
   begin
      if ( !RESET_int )
      begin
         FIRST_CLK      = 1'b0;
         SECOND_CLK     = 1'b0;
         PERIOD_SAMPLED = 1'b0;
      end
      else if ( CLK_int && !PERIOD_SAMPLED )
      begin
         if ( FIRST_CLK && !SECOND_CLK )
         begin
            REAL_RST_LATENCY = ( `real_rst_delay / ( $time - FIRST_EDGE ) );
            SECOND_CLK     = 1'b1;
            PERIOD_SAMPLED = 1'b1;
         end
         else if ( !FIRST_CLK )
         begin
            FIRST_EDGE  = $time;
            FIRST_CLK   = 1'b1;
         end
      end
   end

   // #########################################################
   // # BEHAVIORAL SECTION
   // #########################################################

   // --------------------------------------------------------------
   // MOORE state machine implementation, outputs driven from states
   // process sensitive to CLOCK, RESET
   // --------------------------------------------------------------

   always @( posedge CLK_int or negedge RESET_int or ( CLK_int === 1'bx ) or ( RESET_int === 1'bx ) )
   begin 

      // ----------------------------------------------------------------------
      // assign input address to MEM_ADDR variable for accessing the cell array
      // ----------------------------------------------------------------------
      if ( SPAREPAGE_int && AUXBLOCK_int )
      begin
         MEM_ADDR = { ADDR_int [ 17 : 12 ], 1'b1, 5'b0, 1'b1, 3'b0, ADDR_int [ 3 : 0 ] }; 
      end
      else if ( SPAREPAGE_int && !AUXBLOCK_int )
      begin
         MEM_ADDR = { ADDR_int [ 17 : 12 ], 1'b1, 5'b0, 1'b0, ADDR_int [ 6 : 0 ] }; 
      end
      else if ( !SPAREPAGE_int && AUXBLOCK_int )
      begin
         MEM_ADDR = { ADDR_int [ 17 : 12 ], 1'b0, ADDR_int [ 11 : 7 ], 1'b1, 3'b0, ADDR_int [ 3 : 0 ] }; 
      end
      else if ( !SPAREPAGE_int && !AUXBLOCK_int )
      begin
         MEM_ADDR = { ADDR_int [ 17 : 12 ], 1'b0, ADDR_int [ 11 : 7 ], 1'b0, ADDR_int [ 6 : 0 ] }; 
      end
      else
      begin
         MEM_ADDR = { ADDR_int [ 17 : 12 ], SPAREPAGE_int, ADDR_int [ 11 : 7 ], AUXBLOCK_int, ADDR_int [ 6 : 0 ] };
      end


      // ---------------------------------------------------------
      // STATE MACHINE IMPLEMENTATION FOR ACCESSING CELL ARRAY
      // ---------------------------------------------------------
 
      // State machine is triggered by rising edge of CLK when RD_INIT is asserted
 
      if ( RD_INIT && CLK_int )
      begin

      // assign next state from previous clock to current state
      RD_CA_CS = RD_CA_NS; 

      // current state logic
      case (RD_CA_CS)
         // beginning state for accessing cell array
         RD_BLK_CA :
                  begin
                     CA_VALID = 1'b0; 
                     if (TIMER_COUNT == `rd_latency)
                     begin
                        TIMER_COUNT = 0; 
                        RD_CA_NS    = RD_DATA_CA; 
                     end
                     else
                     begin
                        TIMER_COUNT = TIMER_COUNT + 3; 
                        RD_CA_NS    = RD_BLK_CA1; 
                     end 
                  end
         // wait state, increments timer count and returns to the called state
         RD_BLK_CA1 :
                  begin
                     TIMER_COUNT = TIMER_COUNT + 1; 
                     RD_CA_NS    = RD_BLK_CA; 
                  end
         // data from addressed block is read from cell array to sense amp registers in this state
         RD_DATA_CA :
                  begin
                     BUSY_REN = 1'b0; 
                     // access to spare page 0 should default data to all 0s
                     if ( CA_ADDR [ 19 : 14 ] == 6'b0 && R_SPAREPAGE )
                     begin
                        BH = 140'b0;
                     end
                     else
                     begin
                        // if AUXBLOCK or PAGESTATUS read, load aux block data into sense amp
                        // else load addressed block of data into sense amp
                        if ( R_PAGESTATUS || R_AUXBLOCK )
                        begin
                           BH = MEM_64K_140 [ { CA_ADDR [ 19 : 8 ], 1'b1, 3'b0 }];
                        end
                        else
                        begin
                           BH = MEM_64K_140 [ CA_ADDR [ 19 : 4 ] ]; 
                        end 
                     end 
                     // check if this access was initiated by read or program operation
                     if (RD_ACTIVE)
                     begin
                        // if read operation initiated read from cell array, check if PIPE is asserted 
                        // add one clock latency, if PIPE is set
                        if ( R_PIPE )
                        begin
                           RD_CA_NS = RD_PIPE_DR; 
                        end
                        else
                        begin
                           RD_INIT     = 1'b0; 
                           RD_COMPLETE = 1'b1; 
                           CA_VALID    = 1'b1; 
                           RD_CA_NS    = RD_BLK_CA; 
                        end 
                     end
                     else
                     begin
                        RD_INIT     = 1'b0; 
                        RD_COMPLETE = 1'b1; 
                        CA_VALID    = 1'b1; 
                        RD_CA_NS    = RD_BLK_CA; 
                     end 
                  end
         // if PIPE is asserted with REN, data is loaded into block buffer and then o/p to data mux
         RD_PIPE_DR :
                  begin
                     RD_INIT     = 1'b0; 
                     RD_COMPLETE = 1'b1; 
                     CA_VALID    = 1'b1; 
                     RD_CA_NS    = RD_BLK_CA; 
                  end
      endcase 
      if ( RD_CA_CS != RD_DATA_CA )
      begin
         BUSY_REN = 1'b1; 
         RD_zd    = 32'b0; 
      end  

     end  // end of read from cell array state machine

   // --------------------------------------------------
   // MAIN STATE MACHINE FOR HANDLING ALL NVM OPERATIONS
   // --------------------------------------------------

   if ( CLK_int || ( CLK_int === 1'bx ) || !RESET_int || ( RESET_int === 1'bx ) )
   begin

      if ( RESET_int == 1'b0 )
      begin
         NEXT_STATE = POWERON_RESET; 
      end
      else if ( RESET_int === 1'bx && ( $time > 0 ) )
      begin
         NEXT_STATE = RST_UNKNOWN; 
      end
      else if ( CLK_int === 1'bx && ( $time > 0 ) && NEXT_STATE != CHK_CLK_RST )
      begin
         NEXT_STATE = CLK_UNKNOWN; 
      end 

      CURR_STATE = NEXT_STATE; 

      case ( CURR_STATE )

         // state machine enters this state by default
         CHK_CLK_RST :
           begin
             if ( RESET_int )
             begin
                NEXT_STATE = POWERON_RESET; 
             end
             else if ( RESET_int === 1'bx )
             begin
                NEXT_STATE = RST_UNKNOWN; 
             end
          end

         // CLK or RESET is unknown state
         RST_UNKNOWN :
           begin
             RD_zd       = 32'bx; 
             STATUS_INIT =  2'bx; 
             BUSY_INIT   =  1'bx; 
                       if ( WARNING_MSGS_ON )
             $display( " ** Warning: RESET went unknown "); 
                       if ( WARNING_MSGS_ON )
             $display( " Time: %0.1f Instance: %m ", $realtime );
             if ( RESET_int )
             begin
                NEXT_STATE = POWERON_RESET; 
             end 
          end
         // CLK or RESET is unknown state
         CLK_UNKNOWN :
           begin
             RD_zd       = 32'bx; 
             STATUS_INIT =  2'bx; 
             BUSY_INIT   =  1'bx; 
                       if ( WARNING_MSGS_ON )
             $display( " ** Warning: CLK went unknown " ); 
                       if ( WARNING_MSGS_ON )
             $display( " Time: %0.1f Instance: %m ", $realtime );
             if ( CLK_int !== 1'bx )
             begin
                TIMER_COUNT = 0;
                NEXT_STATE  = REMOVE_RESET;
             end 
          end
         // RESET state
         POWERON_RESET :
           begin
             // output signals related variables 
             RD_zd       = 32'b0; 

             STATUS_INIT = 2'b0; 
             STATUS_REN  = 2'b0; 
             STATUS_WEN  = 2'b0; 
             STATUS_PRGM = 2'b0; 
             STATUS_ER   = 2'b0; 
             STATUS_UNPR = 2'b0; 
             STATUS_DSCR = 2'b0; 

             BUSY_INIT   = 1'b1; 
             BUSY_REN    = 1'b0; 
             BUSY_WEN    = 1'b0; 
             BUSY_PRGM   = 1'b0; 
             BUSY_ER     = 1'b0; 
             BUSY_UNPR   = 1'b0; 
             BUSY_DSCR   = 1'b0; 

             // internal variables
             AB_VALID    = 1'b0; 
             DR_VALID    = 1'b0;
             AB_MOD      = 1'b0;
             CA_VALID    = 1'b0;
             AB_UNPRTC   = 1'b0;

             RD_ACTIVE   = 1'b0;
             WR_ACTIVE   = 1'b0;
             PR_ACTIVE   = 1'b0;
             UN_ACTIVE   = 1'b0;
             ER_ACTIVE   = 1'b0;
             ERASE_SP0   = 1'b0;

             R_PAGESTATUS= 1'b0;
             RD_INIT     = 1'b0;
             RD_COMPLETE = 1'b0;

             LAST_CYCLE_WRITE = 1'b0;
             CURR_CYCLE_WRITE = 1'b0;

             // variables for clock period detection, start-off with some known value
             SIM_PRG_LATENCY  = 10;
             REAL_PRG_LATENCY = 21000;

             // wait for RESET removal
             if ( RESET_int )
             begin
               TIMER_COUNT = 0;
               NEXT_STATE  = REMOVE_RESET;
             end
           end
             
         // Coming out of reset, BUSY will be de-asserted to enable interface operations
         REMOVE_RESET :
           begin
             TIMER_COUNT    = TIMER_COUNT + 1; 
             if ( (  FAST_SIM && TIMER_COUNT == `sim_rst_latency  ) || ( !FAST_SIM && TIMER_COUNT == REAL_RST_LATENCY ) )
             begin
                TIMER_COUNT = 0;
                BUSY_INIT   = 1'b0;
                NEXT_STATE  = SAMPLE_CMD;
             end
           end

         // sample operations on interface, when BUSY is de-asserted
         SAMPLE_CMD :
           begin
             if ( !BUSY_zd )
             begin
                // check for "x" on any of the input operations considering the operation priority order
                if ( REN_int === 1'bx )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: REN is unknown, ignoring READ "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( ( WEN_int === 1'bx ) && ( !REN_int ) )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: WEN is unknown, ignoring WRITE "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( ERASEPAGE_int === 1'bx && !REN_int && !WEN_int )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: ERASEPAGE is unknown, ignoring ERASEPAGE "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( PROGRAM_int === 1'bx && !REN_int && !WEN_int && !ERASEPAGE_int )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: PROGRAM is unknown, ignoring PROGRAM "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( UNPROTECTPAGE_int === 1'bx && !REN_int && !WEN_int && !ERASEPAGE_int && !PROGRAM_int )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: UNPROTECTPAGE is unknown, ignoring UNPROTECTPAGE "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( DISCARDPAGE_int === 1'bx && !REN_int && !WEN_int && !ERASEPAGE_int && !PROGRAM_int 
                                                                                             && !UNPROTECTPAGE_int )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: DISCARDPAGE is unknown, ignoring DISCARDPAGE "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
             end 
             if ( !BUSY_zd )
             begin
                // reset status and busy signals from a previous operation, upon sensing a new operation
                if ( ( REN_int ) ||
                     ( WEN_int && !REN_int ) ||
                     ( ERASEPAGE_int && !WEN_int && !REN_int ) ||
                     ( PROGRAM_int && !ERASEPAGE_int && !WEN_int && !REN_int ) ||
                     ( UNPROTECTPAGE_int && !PROGRAM_int && !ERASEPAGE_int && !WEN_int && !REN_int ) ||
                     ( DISCARDPAGE_int && !UNPROTECTPAGE_int && !PROGRAM_int && !ERASEPAGE_int && !WEN_int && !REN_int ) )
                begin
                   STATUS_INIT = 2'b0; 
                   STATUS_REN  = 2'b0; 
                   STATUS_WEN  = 2'b0; 
                   STATUS_ER   = 2'b0; 
                   STATUS_PRGM = 2'b0; 
                   STATUS_UNPR = 2'b0; 
                   STATUS_DSCR = 2'b0; 
                   BUSY_INIT   = 1'b0; 
                   BUSY_REN    = 1'b0; 
                   BUSY_WEN    = 1'b0; 
                   BUSY_ER     = 1'b0; 
                   BUSY_PRGM   = 1'b0; 
                   BUSY_UNPR   = 1'b0; 
                   BUSY_DSCR   = 1'b0; 
                end 
             end 
             if ( !BUSY_zd )
             begin
                // reset read data when REN is removed
                if ( REN_int )
                begin
                   RD_zd = RD_zd; 
                end
                else
                begin
                   RD_zd    = 32'b0; 
                   CA_VALID = 1'b0; 
                end 
             end 

             // latch last cycle write condition to generate 1 clock busy for following read operations
             if ( !BUSY_zd && !REN_int && WEN_int )
             begin
                LAST_CYCLE_WRITE = CURR_CYCLE_WRITE; 
                CURR_CYCLE_WRITE = 1'b1; 
             end
             else if ( !BUSY_zd && ( STATUS_zd == 2'b01 ) )
             begin
                LAST_CYCLE_WRITE = 1'b0; 
                CURR_CYCLE_WRITE = 1'b0; 
             end
             else if ( !BUSY_zd )
             begin
                LAST_CYCLE_WRITE = CURR_CYCLE_WRITE; 
                CURR_CYCLE_WRITE = 1'b0; 
             end 

             // -----------------------------------------------------------------
             // Select an NVM operation to be performed, based on priority scheme
             // -----------------------------------------------------------------
             // when BUSY is low, execute READ operation, if REN is high
             // first check for error conditions on the control signals

             if ( !BUSY_zd && REN_int )
             begin
                if ( DATAWIDTH_int [ 1 ] === 1'bx || DATAWIDTH_int [ 0 ] === 1'bx )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: DATAWIDTH = %b has unknown bits, ignoring READ ", DATAWIDTH_int  ); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( SPAREPAGE_int === 1'bx)
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: SPAREPAGE is unknown, ignoring READ "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( AUXBLOCK_int === 1'bx)
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: AUXBLOCK is unknown, ignoring READ "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( DATAWIDTH_int [ 1 ] && is_addr_x ( { 4'b0, MEM_ADDR [ 19 : 14 ], MEM_ADDR [ 12 : 8 ], MEM_ADDR [ 6 : 2 ] } ) )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: ADDR = %b has unknown bits, ignoring READ ", ADDR_int ); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( DATAWIDTH_int [ 1 : 0 ] == 2'b01 && is_addr_x ( { 3'b0, MEM_ADDR [ 19 : 14 ], MEM_ADDR [ 12 : 8 ], MEM_ADDR [ 6 : 1 ] } ) )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: ADDR = %b has unknown bits, ignoring READ ", ADDR_int ); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( DATAWIDTH_int [ 1 : 0 ] == 2'b00 && is_addr_x ( {2'b0, MEM_ADDR [ 19 : 14 ], MEM_ADDR [ 12 : 8 ], MEM_ADDR [ 6 : 0 ] } ) )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: ADDR = %b has unknown bits, ignoring READ ", ADDR_int ); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( PAGESTATUS_int === 1'bx )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: PAGESTATUS is unknown, ignoring READ "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( READNEXT_int === 1'bx )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: READNEXT is unknown, ignoring READ "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( PIPE_int === 1'bx )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: PIPE is unknown, ignoring READ "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else
                begin
                   // reset internal variables from previous read
                   RD_DR = 1'b0; 
                   RD_AB = 1'b0; 
                   RD_CA = 1'b0; 

                   // latch input signals to be used in read spanning over multiple clock cycles
                   RD_WIDTH        = DATAWIDTH_int[1:0];
                   R_READNEXT      = READNEXT_int; 
                   R_AUXBLOCK      = AUXBLOCK_int; 
                   R_SPAREPAGE     = SPAREPAGE_int; 
                   R_PIPE          = PIPE_int; 
                   PREV_PAGESTATUS = R_PAGESTATUS; 
                   R_PAGESTATUS    = PAGESTATUS_int; 

                   // load aux_block address into R_ADDR
                   if ( PAGESTATUS_int || AUXBLOCK_int )
                     R_ADDR = { MEM_ADDR [ 19 : 8 ], 1'b1, MEM_ADDR [ 6 : 0 ] }; 
                   else begin
                     R_ADDR = MEM_ADDR; 
`ifdef FUSION_DEBUG
                       if ( WARNING_MSGS_ON )
		     $display("Fusion: Latched rd addr: %d",R_ADDR);
`endif
		   end

                   // calculate next address for READNEXT operation 
                   if ( READNEXT_int )
                      NEXT_ADDR = get_next_addr ( R_ADDR  ); 

                   // Read would fetch data from any one of the following sources based on address match and 
                   // valid state, in the decreasing order of match
                   // if data in block buffer is valid and if interface address matches with address of
                   // data block stored in the block buffer, read data from block buffer

                   if (  DR_VALID )
                   begin
                      if ( same_block ( R_ADDR, DR_ADDR ) )
                      begin
                         RD_DR    = 1'b1; 
                         // mux data from DR onto RD based on read width, block address and pagestatus
                         RD_zd    = mux_rd_data ( R_ADDR, RD_WIDTH, R_PAGESTATUS, R_AUXBLOCK, DR );
                         BUSY_REN = 1'b0; 
                      end 
                   end 
                   if ( !RD_DR && AB_VALID )
                   begin
                      // check if page buffer is valid and if yes, if interface address matches with address of
                      // data page stored in the page buffer. If yes, read data is fetched from page buffer
                      if ( R_ADDR [ 19 : 8 ] == AB_ADDR [ 19 : 8 ] )
                      begin
                         // if pagestatus or auxblock is asserted along with ren, data should be fetched from auxblock
                         if ( PAGESTATUS_int || AUXBLOCK_int ) 
                         begin
                            ASM_BH = ASM_BUF[8]; 
                         end
                         else
                         begin
`ifdef FUSION_DEBUG
			    $display("Fusion_fm: Page buffer Read on addr == %d, data == %d",R_ADDR, ASM_BUF[R_ADDR [ 6 : 4 ]]);
`endif
                            ASM_BH = ASM_BUF[R_ADDR [ 6 : 4 ]]; 
                         end 
                         // load data block from page buffer to block buffer (interface address is also loaded)
                         RD_AB    = 1'b1; 
                         DR       = ASM_BH; 
                         DR_ADDR  = R_ADDR; 
                         DR_VALID = 1'b1; 
                         BH       = ASM_BH; 
                         // if present read is preceded by write in previous cycle, block buffer access has 
                         // 1 clock latency
                         if (LAST_CYCLE_WRITE  || PIPE_int )
                         begin
                            BUSY_REN   = 1'b1; 
                            RD_zd      = 32'b0; 
                            NEXT_STATE = RD_LAST_WR; 
                         end
                         else
                         begin
                            // mux data from BH onto RD based on read width, block address and pagestatus
                            RD_zd    = mux_rd_data ( R_ADDR, RD_WIDTH, R_PAGESTATUS, R_AUXBLOCK, BH );
                            BUSY_REN = 1'b0; 
                         end 
                      end 
                   end 
                   // check if read next address matches with read address and if previously initiated read next
                   // is complete, in which case, data is already fetched from cell array, 
                   // if no match, read data should be fetched from cell array
                   if ( !RD_AB && !RD_DR && CA_VALID && same_block ( R_ADDR, CA_ADDR ) && RD_COMPLETE )
                   begin
                      RD_CA    = 1'b1; 
                      DR       = BH; 
                      DR_ADDR  = CA_ADDR; 
                      DR_VALID = 1'b1; 
                      // mux data from BH onto RD based on read width, block address and pagestatus
                      RD_zd    = mux_rd_data ( R_ADDR, RD_WIDTH, R_PAGESTATUS, R_AUXBLOCK, BH ); 
                      BUSY_REN = 1'b0; 
                   end
                   else if ( !RD_AB && !RD_DR && RD_INIT && same_block ( R_ADDR, CA_ADDR ) && 
                             ( ( !PIPE_int && RD_CA_CS != RD_DATA_CA ) || ( PIPE_int && RD_CA_CS != RD_PIPE_DR ) ) )
                   begin
                      BUSY_REN   = 1'b1; 
                      RD_zd      = 32'b0; 
                      NEXT_STATE = RD_NEXT_BUSY; 
                   end
                   else if ( !RD_AB && !RD_DR && !RD_INIT )
                   begin
                      RD_ACTIVE  = 1'b1; 
                      CA_ADDR    = R_ADDR; 
                      BUSY_REN   = 1'b1; 
                      RD_zd      = 32'b0; 
                      RD_INIT    = 1'b1; 
                      NEXT_STATE = RD_WAIT_CA; 
                   end 

                   // if READNEXT is asserted with REN and if read from cell arrary is not initiated
                   // and if the block address in next address is not same as block address of data
                   // being fetched from cell array, then initiate read from cell array

                   if ( R_READNEXT && !RD_INIT && diff_block ( CA_ADDR, NEXT_ADDR ) )
                   begin
                      if ( RD_AB  || RD_DR  || RD_CA )
                      begin
                         BUSY_REN = 1'b0; 
                      end
                      else
                      begin
                         BUSY_REN = 1'b1; 
                         RD_zd    = 32'b0; 
                      end 
                      CA_ADDR    = NEXT_ADDR; 
                      RD_INIT    = 1'b1; 
                      NEXT_STATE = SAMPLE_CMD; 
                   end 
                end 
             end
             else if ( !BUSY_zd && WEN_int ) 
             begin
                if ( DATAWIDTH_int [ 1 ] === 1'bx || DATAWIDTH_int [ 0 ] === 1'bx )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: DATAWIDTH = %b has unknown bits, ignoring WRITE ", DATAWIDTH_int ); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( SPAREPAGE_int === 1'bx )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: SPAREPAGE is unknown, ignoring WRITE "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( AUXBLOCK_int === 1'bx )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: AUXBLOCK is unknown, ignoring WRITE "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( DATAWIDTH_int [ 1 ] && is_addr_x ( { 4'b0, MEM_ADDR [ 19 : 14 ], MEM_ADDR [ 12 : 8 ], MEM_ADDR [ 6 : 2 ]} ) ) 
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: ADDR = %b has unknown bits, ignoring WRITE ", ADDR_int ); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if (DATAWIDTH_int [ 1 : 0 ] == 2'b01 && is_addr_x ( { 3'b0, MEM_ADDR [ 19 : 14 ], MEM_ADDR [ 12 : 8 ], MEM_ADDR [ 6 : 1 ] } ) )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: ADDR = %b has unknown bits, ignoring WRITE ", ADDR_int ); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if (DATAWIDTH_int [ 1 : 0 ] == 2'b00 && is_addr_x ( { 2'b0, MEM_ADDR [ 19 : 14 ], MEM_ADDR [ 12 : 8 ], MEM_ADDR [ 6 : 0 ] } ) ) 
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: ADDR = %b has unknown bits, ignoring WRITE ", ADDR_int ); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( PAGELOSSPROTECT_int === 1'bx )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: PAGELOSSPROTECT is unknown, ignoring WRITE "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else
                begin
                   // latch interface signals for write spanning over multiple cycles
                   R_PAGELOSSPROTECT = PAGELOSSPROTECT_int; 
                   R_SPAREPAGE       = SPAREPAGE_int; 
                   R_AUXBLOCK        = AUXBLOCK_int; 

                   // convert 2 bit data width input to integer for case processing
                   WR_WIDTH = DATAWIDTH_int; 

                   // latch write control signals
                   WR_DATA = WD_int; 
                   WR_ADDR = MEM_ADDR; 
                   PG_ADDR = MEM_ADDR; 
`ifdef FUSION_DEBUG
		   $display("Fusion_fm: Latched write addr %d, data: %d",ADDR_int, WD_int);
`endif

                   // check if write is trying to update addresses not allowed in cell array
                   // write operation should fail with status code 01, if accessing spare page of sector 0
                   if ( ( MEM_ADDR [ 19 : 14 ] == 6'b0 ) && SPAREPAGE_int ) 
                   begin
                      STATUS_WEN = 2'b01; 
                      NEXT_STATE = SAMPLE_CMD; 
                   end
                   else
                   begin
                      // write operation should fail with status code 11, if write is to a different page and 
                      // page in page buffer is modified and pagelossprotect is asserted
                      if ( PAGELOSSPROTECT_int && AB_MOD && ( MEM_ADDR [ 19 : 8 ] != AB_ADDR [ 19 : 8 ] ) )
                      begin
                         // write operation should fail with status code 11
                         STATUS_WEN = 2'b11; 
                         NEXT_STATE = SAMPLE_CMD; 
                      end
                      else
                      begin
                         // copy page if addressed page is not in page buffer or if page in page buffer has been discarded
                         if ( ( WR_ADDR [ 19 : 8 ] != AB_ADDR [ 19 : 8 ] ) || !AB_VALID )
                         begin
                            BUSY_WEN   = 1'b1; 
                            WR_ACTIVE  = 1; 
                            NEXT_STATE = COPY_PAGE_CA; 

                            if ( ( WR_ADDR [ 19 : 8 ] != AB_ADDR [ 19 : 8 ] ) && AB_MOD )
                            begin
                       if ( WARNING_MSGS_ON )
                               $display( " ** Warning: WRITE OPERATION: COPYING NEW PAGE, DATA IN PAGE BUFFER WILL BE LOST " );
                       if ( WARNING_MSGS_ON )
                               $display( "                                          ASSERT PAGELOSSPROTECT TO PROTECT DATA " );
                       if ( WARNING_MSGS_ON )
                               $display( " Time: %0.1f Instance: %m ", $realtime );
                            end
                         end
                         else
                         begin
                            DR_VALID = 1'b1; 
                            // update contents of page buffer with interface data. if AUXBLOCK is set, ignore WR_ADDR(6 downto 4)
                            // BUSY to be asserted  for 3 clocks if addressed block is different from data block in block buffer
                            if ( diff_block ( WR_ADDR, DR_ADDR ) )
                            begin
                               BUSY_WEN   = 1'b1; 
                               NEXT_STATE = WR_DIFF_BLK; 
                            end
                            else
                            begin
                               BUSY_WEN = 1'b0; 
                               AUX_BLK  = ASM_BUF [ 8 ]; 
                               // check overwrite protect bit in Aux Block, before updating contents of AB
                               if ( AUX_BLK [ 70 ] === 1'bx )
                               begin
                                  STATUS_WEN = 2'b01; 
                                  BUSY_WEN   = 1'b0; 
                                  NEXT_STATE = SAMPLE_CMD; 
                               end
                               else if ( AUX_BLK [ 70 ] && !AB_UNPRTC ) 
                               begin
                                  STATUS_WEN = 2'b01; 
                                  BUSY_WEN   = 1'b0; 
                                  NEXT_STATE = SAMPLE_CMD; 
                               end
                               else
                               begin
                                  // mux write data into assumbly buffer and block buffer, based on auxblock, width and address
                                  // initially, copy data from appropriate block into temp register, update temp register
                                  // with write data chose between auxblock or regular data block in page buffer
                                  if ( R_AUXBLOCK )
                                  begin
                                     AUX_BLK = ASM_BUF [ 8 ]; 
                                  end
                                  else
                                  begin
                                     AUX_BLK = ASM_BUF [ WR_ADDR [ 6 : 4 ] ]; 
                                  end 

                                  // call to function mux_wr_data to update write data into temp register, AUX_BLK
                                  AUX_BLK  = mux_wr_data ( WR_ADDR, WR_WIDTH, R_AUXBLOCK, AUX_BLK, WR_DATA );


                                  // update write data, address to block buffer upon successful write
                                  DR       = AUX_BLK; 
                                  DR_VALID = 1'b1; 

                                  // update data returned from function mux_wr_data into the page buffer and the block buffer
`ifdef FUSION_DEBUG
		                  $display("Fusion_fm: page buff write, data %d, addr = %d",mux_wr_data ( WR_ADDR, WR_WIDTH, R_AUXBLOCK, AUX_BLK, WR_DATA ),WR_ADDR);
`endif
                                  if ( R_AUXBLOCK )
                                  begin
                                     ASM_BUF[8] = DR; 
                                  end
                                  else
                                  begin
                                     ASM_BUF [ WR_ADDR [ 6 : 4 ] ] = DR; 
                                  end 

                                  // write operation returned success, busy is de-asserted and page buffer is marked as modified 
                                  BUSY_WEN = 1'b0; 
                                  AB_MOD = 1'b1; 
                                  NEXT_STATE = SAMPLE_CMD; 
                               end 
                            end 
                         end 
                      end 
                   end 
                end 
             end

             // execute erase page operation if write is not active
             else if ( !BUSY_zd && ERASEPAGE_int ) 
             begin
                if ( SPAREPAGE_int === 1'bx )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: SPAREPAGE is unknown, ignoring ERASEPAGE "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( is_addr_x ( { 11'b0, MEM_ADDR [ 19 : 14 ], MEM_ADDR [ 12 : 8 ] } ) )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: ADDR = %b has unknown bits, ignoring ERASEPAGE ", ADDR_int ); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else if ( PAGELOSSPROTECT_int === 1'bx )
                begin
                       if ( WARNING_MSGS_ON )
                   $display( " ** Warning: PAGELOSSPROTECT is unknown, ignoring ERASEPAGE "); 
                       if ( WARNING_MSGS_ON )
                   $display( " Time: %0.1f Instance: %m ", $realtime );
                end
                else
                begin
                   // execute erase, if no error conditions exist
                   R_PAGELOSSPROTECT = PAGELOSSPROTECT_int; 
                   ER_ADDR           = MEM_ADDR; 
                   PG_ADDR           = MEM_ADDR; 
                   // check for error conditions on control signals for erase operation
                   if ( ( MEM_ADDR [ 19 : 14 ] == 6'b0 ) && SPAREPAGE_int )
                   begin
                      BUSY_ER    = 1'b1; 
                      ERASE_SP0  = 1; 
                      ER_ACTIVE  = 1; 
                      NEXT_STATE = COPY_PAGE_CA; 
                   end
                   else
                   begin
                      ER_ADDR = MEM_ADDR; // latch unprotect page address
                      // erase to spare page  of sector 0 is not allowed
                      if ( PAGELOSSPROTECT_int && AB_MOD && ( ER_ADDR [ 19 : 8 ] != AB_ADDR [ 19 : 8 ] ) )
                      begin
                         STATUS_ER  = 2'b01; 
                         NEXT_STATE = SAMPLE_CMD; 
                      end
                      // if erase page address is not same as that in page buffer or if page buffer is not modified
                      // perform copy page to erase the page
                      else if ( ( ER_ADDR [ 19 : 8 ] != AB_ADDR [ 19 : 8 ] ) || !AB_VALID )
                      begin
                         BUSY_ER    = 1'b1; 
                         ER_ACTIVE  = 1; 
                         NEXT_STATE = COPY_PAGE_CA; 

                         if ( ( ER_ADDR [ 19 : 8 ] != AB_ADDR [ 19 : 8 ] ) && AB_MOD )
                         begin
                       if ( WARNING_MSGS_ON )
                            $display( " ** Warning: ERASE OPERATION: COPYING NEW PAGE, DATA IN PAGE BUFFER WILL BE LOST " );
                       if ( WARNING_MSGS_ON )
                            $display( "                                          ASSERT PAGELOSSPROTECT TO PROTECT DATA " );
                       if ( WARNING_MSGS_ON )
                            $display( " Time: %0.1f Instance: %m ", $realtime );
                         end
                      end
                      else if ( ( ER_ADDR [ 19 : 8 ] == AB_ADDR [ 19 : 8 ] ) && AB_VALID )
                      begin
                         AUX_BLK = ASM_BUF [ 8 ]; 
                         // erase operation returns status 01, if pagelossprotect is asserted and page buffer is modified
                         if (AUX_BLK [ 70 ] === 1'bx)
                         begin
                            // erase operation aborted, overwrite bit is set in AUX BLOCK
                            STATUS_ER  = 2'b01;
                            NEXT_STATE = SAMPLE_CMD; 
                         end
                         // erase page address is same address of page in page buffer && is modified
                         else if ( AUX_BLK[70] && !AB_UNPRTC )
                         begin
                            DR_VALID    = 1'b0; 
                            BUSY_ER     = 1'b1; 
                            TIMER_COUNT = 1; 
                            NEXT_STATE  = ER_AB_DLY; 
                         end
                         else
                         begin
                            BUSY_ER = 1'b1; 
                            // set aux_block properties stored locally, before writing page into cell array
                            if ( AB_UNPRTC )
                               AUX_BLK[70] = 1'b0; 

                            PR_ADDR    = ER_ADDR; 
                            NEXT_STATE = ER_CHK_OVWRPRTC1; 
                         end 
                      end // end if check for er_addr with ab_addr
                   end 
                end 
             end

             // execute program page, if erase page is not active
             else if ( !BUSY_zd && PROGRAM_int )
                     begin
                        if ( SPAREPAGE_int === 1'bx)
                        begin
                       if ( WARNING_MSGS_ON )
                           $display( " ** Warning: SPAREPAGE is unknown, ignoring PROGRAM "); 
                       if ( WARNING_MSGS_ON )
                           $display( " Time: %0.1f Instance: %m ", $realtime );
                        end
                        else if ( is_addr_x ( { 11'b0, MEM_ADDR [ 19 : 14 ], MEM_ADDR [ 12 : 8 ] } ) )
                        begin
                       if ( WARNING_MSGS_ON )
                           $display( " ** Warning: ADDR = %b has unknown bits, ignoring PROGRAM ", ADDR_int ); 
                       if ( WARNING_MSGS_ON )
                           $display( " Time: %0.1f Instance: %m ", $realtime );
                        end
                        else if ( PAGELOSSPROTECT_int === 1'bx )
                        begin
                       if ( WARNING_MSGS_ON )
                           $display( " ** Warning: PAGELOSSPROTECT is unknown, ignoring PROGRAM "); 
                       if ( WARNING_MSGS_ON )
                           $display( " Time: %0.1f Instance: %m ", $realtime );
                        end
                        else if ( OVERWRITEPAGE_int === 1'bx )
                        begin
                       if ( WARNING_MSGS_ON )
                           $display( " ** Warning: OVERWRITEPAGE is unknown, ignoring PROGRAM "); 
                       if ( WARNING_MSGS_ON )
                           $display( " Time: %0.1f Instance: %m ", $realtime );
                        end
                        else if ( OVERWRITEPROTECT_int === 1'bx )
                        begin
                       if ( WARNING_MSGS_ON )
                           $display( " ** Warning: OVERWRITEPROTECT is unknown, ignoring PROGRAM "); 
                       if ( WARNING_MSGS_ON )
                           $display( " Time: %0.1f Instance: %m ", $realtime );
                        end
                        else
                        begin
                           // latch interface signals for program spanning over multiple cycles
                           R_OVERWRITEPAGE    = OVERWRITEPAGE_int; 
                           R_PAGELOSSPROTECT  = PAGELOSSPROTECT_int; 
                           R_OVERWRITEPROTECT = OVERWRITEPROTECT_int; 
                           PR_ADDR            = MEM_ADDR; 
                           PG_ADDR            = MEM_ADDR; 

                           if ( ( MEM_ADDR [ 19 : 14 ] == 6'b0 ) && SPAREPAGE_int )
                           begin
                              // program of spare page of sector 0 returns status 01 (fail) 
                              if ( OVERWRITEPAGE_int )
                              begin
                                 BUSY_PRGM   = 1'b1; 
                                 NEXT_STATE  = WAIT_SP0_OVWR; 
                              end
                              else
                              begin
                                 DR_VALID    = 1'b0; 
                                 STATUS_PRGM = 2'b01; 
                                 NEXT_STATE  = SAMPLE_CMD; 
                              end 
                           end
                           else
                           begin
                              if ( PAGELOSSPROTECT_int && AB_MOD && !OVERWRITEPAGE_int && ( PR_ADDR [ 19 : 8 ] != AB_ADDR [ 19 : 8 ] ) ) 
                              begin
                                 STATUS_PRGM = 2'b01; 
                                 NEXT_STATE  = SAMPLE_CMD; 
                              end
                              // copy page, if program address is different from page buffer address and if overwrite page is not asserted and
                              // page buffer is not modified or pagelossprotect is not set
                              else if ( ( ( PR_ADDR [ 19 : 8 ] != AB_ADDR [ 19 : 8 ] ) || !AB_VALID ) && !OVERWRITEPAGE_int && 
                                        ( !AB_MOD || !PAGELOSSPROTECT_int ) )
                              begin
                                 BUSY_PRGM = 1'b1; 
                                 PR_ACTIVE = 1; 
                                 NEXT_STATE = COPY_PAGE_CA; 
                                 if ( ( PR_ADDR [ 19 : 8 ] != AB_ADDR [ 19 : 8 ] ) && AB_MOD )
                                 begin
                       if ( WARNING_MSGS_ON )
                                    $display( " ** Warning: PROGRAM OPERATION: COPYING NEW PAGE, DATA IN PAGE BUFFER WILL BE LOST " );
                       if ( WARNING_MSGS_ON )
                                    $display( "                                            ASSERT PAGELOSSPROTECT TO PROTECT DATA " );
                       if ( WARNING_MSGS_ON )
                                    $display( " Time: %0.1f Instance: %m ", $realtime );
                                 end
                              end
                              else if ( ( ( PR_ADDR [ 19 : 8 ] == AB_ADDR [ 19 : 8 ] ) && ( AB_MOD || OVERWRITEPROTECT_int ) ) ||
                                        ( OVERWRITEPAGE_int ) )
                              begin
                                 if ( ( PR_ADDR [ 19 : 8 ] == AB_ADDR [ 19 : 8 ] ) && ( AB_MOD || OVERWRITEPROTECT_int ) )
                                 begin
                                    // check overwrite protect property in aux block of page in page buffer
                                    AUX_BLK = ASM_BUF[8]; 
                                    // If page buffer is modified and pagelossprotect is set and overwritepage is not set,
                                    // cannot program a different page, returns status 01
                                    if ( AUX_BLK [ 70 ] === 1'bx )
                                    begin
                                       // program operation aborted
                                       STATUS_PRGM = 2'b01;
                                       BUSY_PRGM   = 1'b0;
                                       NEXT_STATE  = SAMPLE_CMD; 
                                    end
                                    // load page buffer to CA, if program address is same as address in page buffer  and if page buffer
                                    // is modified or 
                                    // overwrite page is asserted, data in page buffer will be copied to location in CA given by 
                                    // interface address
                                    else if ( AUX_BLK[70] && !OVERWRITEPAGE_int && !AB_UNPRTC )
                                    begin
                                       STATUS_PRGM = 2'b01; // program operation aborted
                                       BUSY_PRGM   = 1'b0; // deassert BUSY to assert status
                                       NEXT_STATE  = SAMPLE_CMD; 
                                    end
                                    else
                                    begin
                                       // set overwrite protect in aux_block
                                       if ( OVERWRITEPROTECT_int && !(AUX_BLK [ 70 ]) ) 
                                       begin
                                          AUX_BLK[70] = 1'b1; 
                                          AB_MOD = 1'b1; // page buffer is marked as modified, page protections changed
                                       end 
                                       // check write count in aux block with write threshold to continue programing
                                       if ( ( AUX_BLK [ 95 : 72 ] + 1 ) > WR_THR )
                                       begin
                                          STATUS_PRGM = 2'b11; // status when write count exceeds write threshold
                                       end 
                                       // if interface page address is same as that in page buffer and if page buffer is modified or 
                                       // ovwerwriteprotect
                                       // is asserted, then no copy page, check page protect property before programing the page
                                       if ( AB_UNPRTC  && !R_OVERWRITEPROTECT )
                                       begin
                                          AUX_BLK[70] = 1'b0; // reset overwrite protect only if interface overwrite protect is not set
                                       end 
                                       // program page buffer contents to cell array
                                       TIMER_COUNT    = 1; 
                                       BUSY_PRGM      = 1'b1; 
                                       PERIOD_SAMPLED = 1'b0;
                                       NEXT_STATE     = UPDATE_PG_CA; 
                                    end 
                                 end
                                 // if overwritepage is asserted and interface page address is different from page in page buffer, copy
                                 // the addressed page from cell array
                                 else if ( OVERWRITEPAGE_int )
                                 begin
                                    BUSY_PRGM = 1'b1; 
                                    RD_INIT = 1'b1; 
                                    NEXT_STATE = RD_WAIT_CA; 
                                 end 
                              end
                              else
                              begin
                                 STATUS_PRGM = 2'b01; 
                                 NEXT_STATE = SAMPLE_CMD; 
                              end 
                           end 
                        end 
                     end

                     // execute unprotect page if program is not active
                     else if ( !BUSY_zd && UNPROTECTPAGE_int )
                     begin
                        if ( SPAREPAGE_int === 1'bx )
                        begin
                       if ( WARNING_MSGS_ON )
                           $display( " ** Warning: UNPROTECTPAGE: SPAREPAGE is unknown, ignoring UNPROTECTPAGE " ); 
                       if ( WARNING_MSGS_ON )
                           $display( " Time: %0.1f Instance: %m ", $realtime );
                        end
                        else if ( is_addr_x ( { 11'b0, MEM_ADDR [ 19 : 14 ], MEM_ADDR [ 12 : 8 ] } ) )
                        begin
                       if ( WARNING_MSGS_ON )
                           $display( " ** Warning: UNPROTECTPAGE: ADDR = %b has unknown bits, ignoring UNPROTECTPAGE ", ADDR_int ); 
                       if ( WARNING_MSGS_ON )
                           $display( " Time: %0.1f Instance: %m ", $realtime );
                        end
                        else
                        begin
                           R_PAGELOSSPROTECT = PAGELOSSPROTECT_int; 
                           // unprotect page to spare page of sector 0 is not allowed, does not return error status,
                           // so, printing a message with severity note
                           if ( MEM_ADDR [ 19 : 14 ] == 6'b0 && SPAREPAGE_int )
                           begin
                       if ( WARNING_MSGS_ON )
                              $display( " Module %m: Note: UNPROTECTPAGE: Page addressed is spare page of sector 0, UNPROTECTPAGE will not be executed "); 
                       if ( WARNING_MSGS_ON )
                              $display( " Time: %0.1f Instance: %m ", $realtime );
                           end
                           else
                           begin
                              // if pagelossprotect is asserted and if interface page address is different from the page in page buffer 
                              // and if page buffer is modified cannot copy the new page into page buffer, returns status 11 (fail)
                              if ( PAGELOSSPROTECT_int && AB_MOD && ( MEM_ADDR [ 19 : 8 ] !== AB_ADDR [ 19 : 8 ] ) ) 
                              begin
                                 // unprotect operation aborted, pageloss protect is asserted
                                 STATUS_UNPR = 2'b11;
                                 NEXT_STATE  = SAMPLE_CMD; 
                              end
                              else
                              begin
                                 // mark the page in page buffer as unprotected, copy new page into page buffer if required
                                 UN_ADDR = MEM_ADDR; 
                                 PG_ADDR = MEM_ADDR;
                                 // if unprotect address is not same as address of contents in page buffer or 
                                 // if page buffer is not valid, copy page
                                 if ( ( UN_ADDR [ 19 : 8 ] != AB_ADDR [ 19 : 8 ] ) || !AB_VALID )
                                 begin
                                    BUSY_UNPR  = 1'b1; 
                                    UN_ACTIVE  = 1; 
                                    NEXT_STATE = COPY_PAGE_CA; 
                                    if ( ( UN_ADDR [ 19 : 8 ] != AB_ADDR [ 19 : 8 ] ) && AB_MOD ) 
                                    begin
                       if ( WARNING_MSGS_ON )
                                       $display( " ** Warning: UNPROTECTPAGE OPERATION: COPYING NEW PAGE, DATA IN PAGE BUFFER WILL BE LOST " );
                       if ( WARNING_MSGS_ON )
                                       $display( "                                            ASSERT PAGELOSSPROTECT TO PROTECT DATA " );
                       if ( WARNING_MSGS_ON )
                                       $display( " Time: %0.1f Instance: %m ", $realtime );
                                    end
                                 end
                                 else
                                 begin
                                    // locally, mark page buffer as unprotected, overwrite protect bit in aux block is NOT cleared 
                                    AB_UNPRTC = 1'b1; // page buffer is unprotected, but only locally, effective only when programed
                                    AB_MOD = 1'b1; // page buffer is marked as modified, page protections changed
                                    NEXT_STATE = SAMPLE_CMD; 
                                 end 
                              end 
                           end 
                        end 
                     end

                     // execute discard page operation, if unprotect page is not active 
                     else if ( !BUSY_zd && DISCARDPAGE_int ) 
                     begin
                       // discard page marks both the block buffer and page buffer as invalid
                       DR_VALID   = 1'b0; 
                       // assert BUSY for 1 clock
                       BUSY_DSCR  = 1'b1;
                       NEXT_STATE = DS_AB_INVALID; 
                     end 
                  end
         // end all NVM operations

         // end of SAMPLE_CMD state, where all NVM operations are checked

         // discard operation wait state for 1 clk, mark contents of page in page buffer as invalid
         DS_AB_INVALID :
                  begin
                     // mark page buffer unmodified, will not be programed
                     AB_MOD     = 1'b0;
                     // mark page buffer invalid, contents lost
                     AB_VALID   = 1'b0;
                     BUSY_DSCR  = 1'b0; 
                     NEXT_STATE = SAMPLE_CMD; 
                  end
         // unprotect operation wait state, mark page buffer as unprotected (locally)
         UN_AB_PROP :
                  begin
                     // page buffer is unprotected, but only locally, effective only when programed
                     AB_UNPRTC  = 1'b1;
                     // page buffer is marked as modified, page protections changed
                     AB_MOD     = 1'b1;
                     BUSY_UNPR  = 1'b0; 
                     NEXT_STATE = SAMPLE_CMD; 
                  end
         // read next wait state, waits on signal RD_COMPLETE and CA_VALID
         RD_NEXT_BUSY :
                  begin
                     if ( RD_COMPLETE  && CA_VALID )
                     begin
                        RD_COMPLETE = 1'b0; 
                        CA_VALID    = 1'b0; 
                        DR          = BH; 
                        DR_ADDR     = CA_ADDR; 
                        DR_VALID    = 1'b1; 

                        // mux data from BH onto RD based on read width, block address and pagestatus
                        RD_zd      = mux_rd_data( R_ADDR, RD_WIDTH, R_PAGESTATUS, R_AUXBLOCK, BH ); 
                        BUSY_REN   = 1'b0; 
                        NEXT_STATE = SAMPLE_CMD; 
                     end 
                  end
         // wait state for read operation, entered, if read is accessing data from page buffer and if 
         // in the last cycle, data was updated into block buffer (turn-around time for access)
         RD_LAST_WR :
                  begin
                     if ( LAST_CYCLE_WRITE  && PIPE_int && RD_AB )
                     begin
                        BUSY_REN   = 1'b1; 
                        RD_zd      = 32'b0; 
                        NEXT_STATE = RD_WR_PIPE; 
                     end
                     else
                     begin
                        // mux data from BH onto RD based on read width, block address and pagestatus
                        RD_zd      = mux_rd_data( R_ADDR, RD_WIDTH, R_PAGESTATUS, R_AUXBLOCK, DR );
                        BUSY_REN   = 1'b0; 
                        NEXT_STATE = SAMPLE_CMD; 
                     end 
                  end
         // wait state for read operation in PIPElined read mode, if block buffer was updated in the
         // last cycle
         RD_WR_PIPE :
                  begin
                     // mux data from BH onto RD based on read width, block address and pagestatus
                     RD_zd = mux_rd_data( R_ADDR, RD_WIDTH, R_PAGESTATUS, R_AUXBLOCK, BH);
                     BUSY_REN = 1'b0; 
                     NEXT_STATE = SAMPLE_CMD; 
                  end
         // wait stats for read operation, entered if read is accessing data from cell arrray
         // or if program operation initiated read of aux block from cell array
         RD_WAIT_CA :
                  begin
                     if ( RD_COMPLETE  && CA_VALID )
                     begin
                        RD_COMPLETE = 1'b0; 
                        CA_VALID    = 1'b0; 

                        DR       = BH; 
                        DR_ADDR  = CA_ADDR; 
                        DR_VALID = 1'b1; 

                        if ( RD_ACTIVE )
                        begin
                           RD_ACTIVE = 1'b0; 
                           RD_INIT   = 1'b0; 
                           //BH      = DR;

                           if ( LAST_CYCLE_WRITE )
                           begin
                              BUSY_REN   = 1'b1; 
                              RD_zd      = 32'b0; 
                              NEXT_STATE = RD_LAST_WR; 
                           end
                           else
                           begin
                              RD_zd      = mux_rd_data ( R_ADDR, RD_WIDTH, R_PAGESTATUS, R_AUXBLOCK, BH );
                              BUSY_REN   = 1'b0; 
                              NEXT_STATE = SAMPLE_CMD; 
                           end 
                        end
                        else
                        begin
                           NEXT_STATE = PR_OVWR_PROP; 
                        end 
                     end
                     else
                     begin
                        if ( RD_ACTIVE )
                        begin
                           BUSY_REN  = 1'b1; 
                           RD_zd     = 32'b0; 
                        end
                        else
                        begin
                           BUSY_PRGM = 1'b1; 
                        end 
                     end 
                  end
         // wait states for accessing data from cell array to compare protection properties during program
         // through RD_BLK_DLY and RD_BLK_DLY1, 4 clock latency is achieved
         RD_BLK_DLY :
                  begin
                     if ( TIMER_COUNT == `rd_latency )
                     begin
                        TIMER_COUNT = 0; 
                        // program operation aborted
                        STATUS_PRGM = 2'b01;
                        DR_VALID    = 1'b0; 
                        BUSY_PRGM   = 1'b0;
                        NEXT_STATE  = SAMPLE_CMD; 
                     end
                     else
                     begin
                        TIMER_COUNT = TIMER_COUNT + 3; 
                        NEXT_STATE  = RD_BLK_DLY1; 
                     end 
                  end
         // wait states for accessing data from cell array to compare protection properties during program
         // through RD_BLK_DLY and RD_BLK_DLY1, 4 clock latency is achieved
         RD_BLK_DLY1 :
                  begin
                     TIMER_COUNT = TIMER_COUNT + 1; 
                     NEXT_STATE  = RD_BLK_DLY; 
                  end
         // copy contents of aux block of page in page buffer before reading overwrite protection properties
         // of a new block, before overwriting a page into cell array
         PR_OVWR_PROP :
                  begin
                     // move contents of aux_block of page in page buffer to ovwr_block in AB
                     ASM_BUF [ 9 ] = ASM_BUF [ 8 ]; 
                     ASM_BUF [ 8 ] = MEM_64K_140 [ { PR_ADDR [ 19 : 8 ], 1'b1, 3'b0 } ];
                     // temporarily assign address of page in page buffer to overwrite register
                     OVWR_ADDR     = AB_ADDR; 
                     // assign interface address to page buffer (overwrite attempt)
                     AB_ADDR       = PR_ADDR; 
                     NEXT_STATE    = PR_CHK_PROP; 
                  end
         // compare overwrite protection status of page in page buffer with that of page read from
         // cell array, program+overwrite would succeed only if the properties match
         PR_CHK_PROP :
                  begin
                     AUX_BLK  = ASM_BUF [ 8 ]; 
                     AUX_BLK1 = ASM_BUF [ 9 ]; 
                     if (AUX_BLK [ 70 ] === 1'bx)
                     begin
                        // overwrite protect bit is "x" in program page aux block, program operation aborted
                        // revert aux block data and address of page buffer to the original contents
                        ASM_BUF [ 8 ] = AUX_BLK1;
                        AUX_BLK       = AUX_BLK1;
                        AB_ADDR       = OVWR_ADDR;
                        STATUS_PRGM = 2'b01;
                        BUSY_PRGM   = 1'b0;
                        NEXT_STATE  = SAMPLE_CMD; 
                     end
                     else if ( AUX_BLK [ 70 ] && R_OVERWRITEPAGE )
                     begin
                        // overwrite protect bit is set in program page aux block, program operation aborted
                        // revert aux block data and address of page buffer to the original contents
                        ASM_BUF [ 8 ] = AUX_BLK1; 
                        AUX_BLK       = AUX_BLK1; 
                        AB_ADDR       = OVWR_ADDR;
                        NEXT_STATE  = RD_BLK_DLY; 
                     end
                     else if ( R_OVERWRITEPAGE  && 
                               ( AUX_BLK [ 128 ] != AUX_BLK1 [ 128 ]  ||  AUX_BLK [ 71 ] != AUX_BLK1 [ 71 ] ) )
                     begin
                        // write and read protects donot match (program page and page buffer), program operation aborted
                        // revert aux block data and address of page buffer to the original contents
                        ASM_BUF [ 8 ] = AUX_BLK1; 
                        AUX_BLK       = AUX_BLK1; 
                        AB_ADDR       = OVWR_ADDR;
                        STATUS_PRGM = 2'b01;
                        BUSY_PRGM   = 1'b0;
                        NEXT_STATE  = SAMPLE_CMD; 
                     end
                     else if ( AUX_BLK [ 70 ] && !R_OVERWRITEPAGE && !AB_UNPRTC ) 
                     begin
                        // write and read protects donot match (program page and page buffer), program operation aborted
                        // revert aux block data and address of page buffer to the original contents
                        ASM_BUF [ 8 ] = AUX_BLK1;  
                        AUX_BLK       = AUX_BLK1; 
                        AB_ADDR       = OVWR_ADDR;
                        STATUS_PRGM = 2'b01;
                        BUSY_PRGM   = 1'b0;
                        NEXT_STATE  = SAMPLE_CMD; 
                     end
                     else
                     begin
                        if ( R_OVERWRITEPROTECT && !( AUX_BLK [ 70 ] ) )
                        begin
                           AUX_BLK [ 70 ] = 1'b1; 
                           // page buffer is marked as modified, page protections changed
                           AB_MOD      = 1'b1;
                        end 
                        // check write count in aux block with write threshold to continue programing
                        if ( ( AUX_BLK [ 95 : 72 ] + 1 ) > WR_THR )
                        begin
                           // status when write count exceeds write threshold
                           STATUS_PRGM = 2'b11;
                        end 
                        if ( AB_UNPRTC && !R_OVERWRITEPROTECT )
                        begin
                           // reset overwrite protect only if interface overwrite protect is not set
                           AUX_BLK [ 70 ] = 1'b0;
                        end 
                        // overwrite protection check is successful, copy user data of aux block from
                        // original page buffer to active aux block; protection properties match
                        AUX_BLK [ `USER_DATA ] = AUX_BLK1 [ `USER_DATA ]; 
                        TIMER_COUNT    = 1; 
                        PERIOD_SAMPLED = 1'b0;
                        NEXT_STATE     = UPDATE_PG_CA; 
                     end 
                  end
         // this state is generic, could be entered in write or program or erase or unprotect operations
         // operation flags will determine the next state transition
         COPY_PAGE_CA :
                  begin
                     if ( TIMER_COUNT == `cp_pg_latency )
                     begin
                        TIMER_COUNT = 0; 
			
`ifdef FUSION_DEBUG
	     		$display("Fusion_fm: retreiving page buffer, page index = %d", PG_ADDR [ 19 : 8 ]);
`endif
                        ASM_BUF[8]  = MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 1'b1, 1'b0, 1'b0, 1'b0 }    ];
                        ASM_BUF[7]  = MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 1'b0, 1'b0, 1'b0, 1'b0 } + 7];
                        ASM_BUF[6]  = MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 1'b0, 1'b0, 1'b0, 1'b0 } + 6];
                        ASM_BUF[5]  = MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 1'b0, 1'b0, 1'b0, 1'b0 } + 5];
                        ASM_BUF[4]  = MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 1'b0, 1'b0, 1'b0, 1'b0 } + 4];
                        ASM_BUF[3]  = MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 1'b0, 1'b0, 1'b0, 1'b0 } + 3]; 
                        ASM_BUF[2]  = MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 1'b0, 1'b0, 1'b0, 1'b0 } + 2];
                        ASM_BUF[1]  = MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 1'b0, 1'b0, 1'b0, 1'b0 } + 1];
                        ASM_BUF[0]  = MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 1'b0, 1'b0, 1'b0, 1'b0 }    ];
                        // aux_block addr into block buffer
                        AB_ADDR     = PG_ADDR; 
                        AB_UNPRTC   = 1'b0; 
                        AB_VALID    = 1'b1; 
                        DR          = ASM_BUF [ 8 ]; 
                        RD_CA       = 1'b1;
                        // load aux_block address in DR_ADDR 
                        DR_ADDR     = { PG_ADDR [ 19 : 8 ], 1'b1, PG_ADDR [ 6 : 0 ] };
                        DR_VALID    = 1'b1; 

                        if ( WR_ACTIVE )
                        begin
                           WR_ACTIVE     = 0; 
                           //update contents of page buffer with interface data, if AUXBLOCK is set, ignore WR_ADDR(6 downto 4)
                           //BUSY to be asserted if addressed block is different from previous write and its NOT a NEW WRITE
                           if ( diff_block ( WR_ADDR, DR_ADDR ) )
                           begin
                              BUSY_WEN   = 1'b1; 
                              NEXT_STATE = WR_DIFF_BLK; 
                           end
                           else
                           begin
                              NEXT_STATE = WR_UPDATE_DATA; 
                           end 
                        end
                        // if program operation triggered copy page
                        else if (PR_ACTIVE)
                        begin
                           PR_ACTIVE  = 0; 
                           NEXT_STATE = PR_CHK_OVWRPRTC; 
                        end
                        // if erase operation triggered copy page
                        else if (ER_ACTIVE)
                        begin
                           ER_ACTIVE = 0; 
                           // copy page state is enterted from multiple operations, next state is based on NVM operation
                           // if write operation triggered copy page
                           if ( ERASE_SP0 )
                           begin
                              ERASE_SP0  = 0; 
                              STATUS_ER  = 2'b01; 
                              BUSY_ER    = 1'b0; 
                              NEXT_STATE = SAMPLE_CMD; 
                           end
                           else
                           begin
                              NEXT_STATE = ER_CHK_OVWRPRTC; 
                           end 
                        end
                        // if unprotect operation triggered copy page
                        else if (UN_ACTIVE)
                        begin
                           UN_ACTIVE  = 0; 
                           // clear overwrite protect bit of aux block in AB
                           // page buffer is unprotected, but only locally, effective only when programed
                           AB_UNPRTC  = 1'b1;
                           // page buffer is marked as modified, page protections changed
                           AB_MOD     = 1'b1;
                           BUSY_UNPR  = 1'b0; 
                           NEXT_STATE = SAMPLE_CMD; 
                        end 
                     end
                     // wait state for copy page, increments timer count
                     else
                     begin
                        TIMER_COUNT = TIMER_COUNT + 1; 
                        NEXT_STATE  = COPY_PAGE_CA1; 
                     end 
                  end
         // transition state to increment TIMER_COUNT while performing COPY PAGE
         COPY_PAGE_CA1 :
                  begin
                     TIMER_COUNT = TIMER_COUNT + 1; 
                     NEXT_STATE  = COPY_PAGE_CA; 
                  end
         // wait states for introducing 3 clk latency associated with write to a different block in block buffer
         WR_DIFF_BLK :
                  begin
                     TIMER_COUNT = 1; 
                     NEXT_STATE  = WR_DIFF_BLK1; 
                  end
         // wait states for introducing 3 clk latency associated with write to a different block in block buffer
         WR_DIFF_BLK1 :
                  begin
                     TIMER_COUNT = TIMER_COUNT + 1; 
                     if ( TIMER_COUNT == `wr_blk_latency )
                     begin
                        TIMER_COUNT = 0; 
                        NEXT_STATE  = WR_UPDATE_DATA; 
                     end
                     else
                     begin
                        NEXT_STATE = WR_DIFF_BLK; 
                     end 
                  end
         // program to spare page of sector 0 will result in a busy assertion for 9 cycles, followed by status=01
         // WAIT_SP0_OVWR and WAIT_SP0_OVWR1 are the corresponding wait states
         WAIT_SP0_OVWR :
                  begin
                     TIMER_COUNT = TIMER_COUNT + 1; 
                     if ( TIMER_COUNT == `sp0_overwrite_latency )
                     begin
                        TIMER_COUNT = 0; 
                        BUSY_PRGM   = 1'b0; 
                        DR_VALID    = 1'b0; 
                        STATUS_PRGM = 2'b01; 
                        NEXT_STATE  = SAMPLE_CMD; 
                     end
                     else
                     begin
                        NEXT_STATE = WAIT_SP0_OVWR1; 
                     end 
                  end
         // program to spare page of sector 0 will result in a busy assertion for 9 cycles, followed by status=01
         // WAIT_SP0_OVWR and WAIT_SP0_OVWR1 are the corresponding wait states
         WAIT_SP0_OVWR1 :
                  begin
                     TIMER_COUNT = TIMER_COUNT + 1; 
                     NEXT_STATE  = WAIT_SP0_OVWR; 
                  end
         // update block buffer, page buffer with interface data based on address, data width and aux_block
         WR_UPDATE_DATA :
                  begin
                     BUSY_WEN = 1'b0; 
                     // load data from addressed block in page buffer into block buffer
                     // chose between auxblock or regular data block in page buffer to update
`ifdef FUSION_DEBUG
	     		$display("Fusion_fm: page buffer read ? ");
`endif
                     if ( R_AUXBLOCK )
                     begin
                        AUX_BLK = ASM_BUF [ 8 ]; 
                     end
                     else
                     begin
                        AUX_BLK = ASM_BUF [ WR_ADDR [ 6 : 4 ] ]; 
                     end 

                     // update write data, address to block buffer upon successful write
                     DR       = AUX_BLK; 
                     DR_ADDR  = WR_ADDR; 
                     DR_VALID = 1'b1; 

                     //check overwrite protect bit in Aux Block, before updating contents of AB
                     AUX_BLK = ASM_BUF[8]; 
                     if ( AUX_BLK [ 70 ] === 1'bx )
                     begin
                        STATUS_WEN = 2'b01; 
                        NEXT_STATE = SAMPLE_CMD; 
                     end
                     else if ( AUX_BLK [ 70 ] && !AB_UNPRTC )
                     begin
                        STATUS_WEN = 2'b01; 
                        NEXT_STATE = SAMPLE_CMD; 
                     end
                     else
                     begin
                        // if page is NOT overwrite protected, update contents of block buffer with inteface data
                        AUX_BLK = DR; 

                        // call function mux_wr_data to update write data into temp register, AUX_BLK
`ifdef FUSION_DEBUG
	     		$display("Fusion_fm: page buffer write ? ");
`endif
                        AUX_BLK = mux_wr_data ( WR_ADDR, WR_WIDTH, R_AUXBLOCK, AUX_BLK, WR_DATA );

                        // update block returned from function mux_wr_data into block buffer and page buffer
                        DR = AUX_BLK; 
                        if ( R_AUXBLOCK )
                        begin
                           ASM_BUF[8] = AUX_BLK; 
                        end
                        else
                        begin
                           ASM_BUF [ WR_ADDR [ 6 : 4 ] ] = AUX_BLK; 
                        end 

                        AB_MOD     = 1'b1; 
                        NEXT_STATE = SAMPLE_CMD; 
                     end 
                  end
         // UPDATE_PG_CA and UPDATE_PG_CA1 are the states in which data from page buffer is updated into nvm array
         // between these 2 states, the required latency is generated
         UPDATE_PG_CA :
                  begin
                     if ( (  FAST_SIM && TIMER_COUNT >= SIM_PRG_LATENCY  ) || 
                          ( !FAST_SIM && TIMER_COUNT >= REAL_PRG_LATENCY ) )
                     begin
                        TIMER_COUNT         = 0; 
                        // reset aux_block properties stored locally, before writing page into cell array
                        AB_UNPRTC           = 1'b0; 
                        // increment write count before programing the page into cell array
                        AUX_BLK [ 95 : 72 ] = AUX_BLK [ 95 : 72 ] + 1'b1; // increment write count in aux block of page
                        ASM_BUF[8]          = AUX_BLK; 
                        AB_MOD              = 1'b1; 
`ifdef FUSION_DEBUG
                       if ( WARNING_MSGS_ON )
			$display("Fusion_fm: Committing Page buffer, index = %d", PG_ADDR [ 19 : 8 ]);
`endif
                        MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 1'b1, 3'b0 } ] = ASM_BUF [ 8 ];
                        MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 4'b0 }   + 7 ] = ASM_BUF [ 7 ];
                        MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 4'b0 }   + 6 ] = ASM_BUF [ 6 ];
                        MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 4'b0 }   + 5 ] = ASM_BUF [ 5 ];
                        MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 4'b0 }   + 4 ] = ASM_BUF [ 4 ];
                        MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 4'b0 }   + 3 ] = ASM_BUF [ 3 ];
                        MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 4'b0 }   + 2 ] = ASM_BUF [ 2 ];
                        MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 4'b0 }   + 1 ] = ASM_BUF [ 1 ];
                        MEM_64K_140 [ { PG_ADDR [ 19 : 8 ], 4'b0 }       ] = ASM_BUF [ 0 ];

                        // load aux_block address in DR_ADDR
                        DR_ADDR    = { PG_ADDR [ 19 : 8 ], 1'b1, PG_ADDR [ 6 : 0 ] };
                        DR         = ASM_BUF[8]; 
                        DR_VALID   = 1'b1; 

                        // mark page buffer as unmodified, after a commiting page to cell array
                        AB_MOD     = 1'b0; 
                        BUSY_PRGM  = 1'b0; 
                        BUSY_ER    = 1'b0; 
                        NEXT_STATE = SAMPLE_CMD; 
                     end
                     else
                     begin
                        TIMER_COUNT = TIMER_COUNT + 1; 
                        // logic to detect clock period on-the-fly
                        if ( !PERIOD_SAMPLED )
                        begin
                           FIRST_EDGE = $time;
                        end 
                        NEXT_STATE  = UPDATE_PG_CA1; 
                     end 
                  end
         // UPDATE_PG_CA and UPDATE_PG_CA1 are the states in which data from page buffer is updated into nvm array
         // between these 2 states, the required latency is generated
         UPDATE_PG_CA1 :
                  begin
                     TIMER_COUNT = TIMER_COUNT + 1; 
                     // logic to detect clock period on-the-fly
                     if ( !PERIOD_SAMPLED )
                     begin
                        PERIOD_SAMPLED   = 1'b1;
                        if ( FAST_SIM  ) 
                        begin
                           // initialize
                           SIM_PRG_LATENCY    = 1;
                           if ( ( $time - FIRST_EDGE ) >= `sim_prg_delay ) 
                           begin
                              SIM_PRG_LATENCY = 3;
                           end
                           else
                           begin
                              SIM_PRG_LATENCY  = ( `sim_prg_delay  / ( $time - FIRST_EDGE ) );
                              SIM_PRG_LATENCY  = SIM_PRG_LATENCY + 1;
                           end
                        end
                        else
                        begin
                           REAL_PRG_LATENCY    = 1;
                           if ( ( $time - FIRST_EDGE ) >= `real_prg_delay ) 
                           begin
                              REAL_PRG_LATENCY = 3;
                           end
                           else
                           begin
                              REAL_PRG_LATENCY = ( `real_prg_delay / ( $time - FIRST_EDGE ) );
                           end
                        end
                     end
                     NEXT_STATE  = UPDATE_PG_CA; 
                  end
         // program operation, check for overwrite protect properties of the aux_block logic, update of page in page
         // buffer is conditional to overwrite protect being reset
         PR_CHK_OVWRPRTC :
                  begin
                     if ( R_OVERWRITEPROTECT )
                     begin
                        AUX_BLK        = ASM_BUF [ 8 ]; 
                        if ( AUX_BLK [ 70 ] === 1'bx)
                        begin
                           STATUS_PRGM = 2'b01; 
                           BUSY_PRGM   = 1'b0; 
                           NEXT_STATE  = SAMPLE_CMD; 
                        end
                        else if ( AUX_BLK [ 70 ] )
                        begin
                           STATUS_PRGM = 2'b01; 
                           DR_VALID    = 1'b0; 
                           BUSY_PRGM   = 1'b0; 
                           NEXT_STATE  = SAMPLE_CMD; 
                        end
                        else
                        begin
                           if ( R_OVERWRITEPROTECT  && !(AUX_BLK [ 70 ]) )
                           begin
                              AUX_BLK[70] = 1'b1; 
                              AB_MOD      = 1'b1; 
                              DR_VALID    = 1'b1; 
                           end 
                           // check write count in aux block with write threshold to continue programing
                           if ( AUX_BLK [ 95 : 72 ] + 1 > WR_THR )
                           begin
                              STATUS_PRGM = 2'b11; 
                           end 
                           //  program page buffer contents to cell array, call task write page
                           //  this task takes care of incrementing write count, reseting page buffer flags
                           TIMER_COUNT    = 1; 
                           PERIOD_SAMPLED = 1'b0;
                           NEXT_STATE     = UPDATE_PG_CA; 
                        end 
                     end
                     else
                     begin
                        STATUS_PRGM = 2'b01; 
                        BUSY_PRGM   = 1'b0; 
                        NEXT_STATE  = SAMPLE_CMD; 
                     end 
                  end
         // between the states ER_CHK_OVWRPRTC and ER_CHK_OVWRPRTC1, overwrite protect properties of page
         // in page buffer is checked and if reset, user data of page is reset and programed into NVM array.
         ER_CHK_OVWRPRTC :
                  begin
                     AUX_BLK = ASM_BUF [ 8 ]; 
                     if ( AUX_BLK [ 70 ] === 1'bx )
                     begin
                        STATUS_ER   = 2'b01; 
                        BUSY_ER     = 1'b0; 
                        NEXT_STATE  = SAMPLE_CMD; 
                     end
                     else if ( AUX_BLK [ 70 ] && !AB_UNPRTC )
                     begin
                        BUSY_ER     = 1'b1; 
                        TIMER_COUNT = 3; 
                        NEXT_STATE  = ER_AB_DLY; 
                     end
                     else
                     begin
                        NEXT_STATE  = ER_CHK_OVWRPRTC1; 
                     end 
                  end
         // between the states ER_CHK_OVWRPRTC and ER_CHK_OVWRPRTC1, overwrite protect properties of page
         // in page buffer is checked and if reset, user data of page is reset and programed into NVM array.
         ER_CHK_OVWRPRTC1 :
                  begin
                     // check write count in aux block with write threshold to continue programing
                     if ( ( AUX_BLK [ 95 : 72 ] + 1 ) > WR_THR )
                     begin
                        STATUS_ER = 2'b11; 
                     end 

                     // clear user data field in aux. block of addressed page
                     AUX_BLK [ 127 : 96 ] = 32'b0; 
                     // clear all data blocks in AB
                     begin
                        for ( i = 0; i <= 7; i = i + 1 )
                        begin
                           ASM_BUF [ i ] = 140'b0; 
                        end
                     end 
                     // program page buffer contents to cell array, call task write page
                     // this task takes care of incrementing write count, reseting page buffer flags
                     TIMER_COUNT    = 1; 
                     PERIOD_SAMPLED = 1'b0;
                     NEXT_STATE     = UPDATE_PG_CA; 
                  end
         ER_AB_DLY1 :
                  begin
                     if ( TIMER_COUNT == `erase_error_latency )
                     begin
                        TIMER_COUNT = 0; 
                        BUSY_ER     = 1'b0; 
                        STATUS_ER   = 2'b01; 
                        NEXT_STATE  = SAMPLE_CMD; 
                     end
                     else
                     begin
                        TIMER_COUNT = TIMER_COUNT + 1; 
                        NEXT_STATE  = ER_AB_DLY; 
                     end 
                  end
         ER_AB_DLY :
                  begin
                     TIMER_COUNT = TIMER_COUNT + 1; 
                     NEXT_STATE  = ER_AB_DLY1; 
                  end
         default :
                  begin
                       if ( WARNING_MSGS_ON )
                     $display( " Module %m: Error: MAIN STATE MACHINE ENTERED UNDEFINED STATE " ); 
                       if ( WARNING_MSGS_ON )
                     $display( " Time: %0.1f Instance: %m ", $realtime );
                  end

      endcase //end of case for CURR_STATE

    end

    //---------------------------------------------------------------------------
    // Combine signals driven from different states
    //---------------------------------------------------------------------------

    BUSY_zd   = ( BUSY_INIT | BUSY_REN | BUSY_WEN | BUSY_PRGM | BUSY_ER | BUSY_UNPR | BUSY_DSCR ); 
    STATUS_zd = ( STATUS_INIT | STATUS_REN | STATUS_WEN | STATUS_PRGM | STATUS_ER | STATUS_UNPR | 
                                                                                    STATUS_DSCR );

   end 


  specify

    specparam   LibName     = "fusion";

    // IOPATH delays for output pins

    // IOPATH delay from CLK to RD[31:0]

    ( posedge CLK   => (RD[31]+:RD[31]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[30]+:RD[30]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[29]+:RD[29]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[28]+:RD[28]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[27]+:RD[27]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[26]+:RD[26]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[25]+:RD[25]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[24]+:RD[24]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[23]+:RD[23]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[22]+:RD[22]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[21]+:RD[21]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[20]+:RD[20]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[19]+:RD[19]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[18]+:RD[18]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[17]+:RD[17]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[16]+:RD[16]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[15]+:RD[15]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[14]+:RD[14]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[13]+:RD[13]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[12]+:RD[12]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[11]+:RD[11]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[10]+:RD[10]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[9]+:RD[9]) )   = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[8]+:RD[8]) )   = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[7]+:RD[7]) )   = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[6]+:RD[6]) )   = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[5]+:RD[5]) )   = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[4]+:RD[4]) )   = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[3]+:RD[3]) )   = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[2]+:RD[2]) )   = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[1]+:RD[1]) )   = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (RD[0]+:RD[0]) )   = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );

    // IOPATH delay from RESET to RD[31:0]

    ( negedge RESET => (RD[31]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[30]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[29]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[28]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[27]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[26]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[25]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[24]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[23]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[22]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[21]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[20]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[19]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[18]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[17]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[16]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[15]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[14]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[13]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[12]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[11]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[10]+:1'b0) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[9]+:1'b0) )  = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[8]+:1'b0) )  = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[7]+:1'b0) )  = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[6]+:1'b0) )  = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[5]+:1'b0) )  = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[4]+:1'b0) )  = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[3]+:1'b0) )  = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[2]+:1'b0) )  = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[1]+:1'b0) )  = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (RD[0]+:1'b0) )  = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );

    // IOPATH delay from CLK/RESET to BUSY

    ( posedge CLK   => (BUSY+:BUSY) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge RESET => (BUSY+:BUSY) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (BUSY+:BUSY) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );

    // IOPATH delay from CLK/RESET to STATUS[1:0]

    ( posedge CLK   => (STATUS[1]+:STATUS[1]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( posedge CLK   => (STATUS[0]+:STATUS[0]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (STATUS[1]+:STATUS[1]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
    ( negedge RESET => (STATUS[0]+:STATUS[0]) ) = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );

    // Timing Checks on input signals conditional to the operation being executed

    // setup and hold checks on REN , when sample command is active

    $setup( posedge REN, posedge CLK &&& SAMPLE_REN, 0.0, NOTIFY_REG );
    $setup( negedge REN, posedge CLK &&& SAMPLE_REN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_REN, posedge REN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_REN, negedge REN, 0.0, NOTIFY_REG );

    // setup and hold checks on WEN , when REN command is not-active

    $setup( posedge WEN, posedge CLK &&& SAMPLE_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WEN, posedge CLK &&& SAMPLE_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_WEN, posedge WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_WEN, negedge WEN, 0.0, NOTIFY_REG );

    // setup and hold checks on ERASEPAGE , when REN, WEN not-active

    $setup( posedge ERASEPAGE, posedge CLK &&& SAMPLE_ERASEPAGE, 0.0, NOTIFY_REG );
    $setup( negedge ERASEPAGE, posedge CLK &&& SAMPLE_ERASEPAGE, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_ERASEPAGE, posedge ERASEPAGE, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_ERASEPAGE, negedge ERASEPAGE, 0.0, NOTIFY_REG );

    // setup and hold checks on PROGRAM , when REN, WEN, ERASEPAGE not-active

    $setup( posedge PROGRAM, posedge CLK &&& SAMPLE_PROGRAM, 0.0, NOTIFY_REG );
    $setup( negedge PROGRAM, posedge CLK &&& SAMPLE_PROGRAM, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_PROGRAM, posedge PROGRAM, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_PROGRAM, negedge PROGRAM, 0.0, NOTIFY_REG );

    // setup and hold checks on UNPROTECTPAGE, when REN, WEN, ERASEPAGE, PROGRAM not-active

    $setup( posedge UNPROTECTPAGE, posedge CLK &&& SAMPLE_UNPROTECT, 0.0, NOTIFY_REG );
    $setup( negedge UNPROTECTPAGE, posedge CLK &&& SAMPLE_UNPROTECT, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_UNPROTECT, posedge UNPROTECTPAGE, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_UNPROTECT, negedge UNPROTECTPAGE, 0.0, NOTIFY_REG );

    // setup and hold checks on DISCARDPAGE, when REN, WEN, ERASEPAGE, PROGRAM, UNPROTECTPAGE not-active

    $setup( posedge DISCARDPAGE, posedge CLK &&& SAMPLE_DISCARD, 0.0, NOTIFY_REG );
    $setup( negedge DISCARDPAGE, posedge CLK &&& SAMPLE_DISCARD, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_DISCARD, posedge DISCARDPAGE, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& SAMPLE_DISCARD, negedge DISCARDPAGE, 0.0, NOTIFY_REG );

    // ADDR, SPAREPAGE are common to all operations, should follow setup, hold requirements

    // Setup and Hold checks on ADDR[`PAGE] with clock when any operation is active
    // Setup and Hold checks on ADDR[7:0] with clock when REN or WEN is active 

    $setup( posedge ADDR[17], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[17], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge ADDR[17], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge ADDR[17], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[16], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[16], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge ADDR[16], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge ADDR[16], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[15], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[15], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge ADDR[15], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge ADDR[15], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[14], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[14], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge ADDR[14], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge ADDR[14], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[13], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[13], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge ADDR[13], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge ADDR[13], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[12], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[12], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge ADDR[12], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge ADDR[12], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[11], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[11], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge ADDR[11], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge ADDR[11], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[10], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[10], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge ADDR[10], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge ADDR[10], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[9], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[9], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge ADDR[9], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge ADDR[9], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[8], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[8], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge ADDR[8], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge ADDR[8], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[7], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[7], posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge ADDR[7], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge ADDR[7], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[6], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[6], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, posedge ADDR[6], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, negedge ADDR[6], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[5], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[5], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, posedge ADDR[5], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, negedge ADDR[5], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[4], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[4], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, posedge ADDR[4], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, negedge ADDR[4], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[3], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[3], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, posedge ADDR[3], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, negedge ADDR[3], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[2], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[2], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, posedge ADDR[2], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, negedge ADDR[2], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[1], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[1], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, posedge ADDR[1], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, negedge ADDR[1], 0.0, NOTIFY_REG );
    $setup( posedge ADDR[0], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge ADDR[0], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, posedge ADDR[0], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, negedge ADDR[0], 0.0, NOTIFY_REG );

    // setup and hold checks on SPAREPAGE with clock when any of the operations is active

    $setup( posedge SPAREPAGE, posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge SPAREPAGE, posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge SPAREPAGE, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge SPAREPAGE, 0.0, NOTIFY_REG );

    // setup and hold checks on AUXBLOCK with clock when REN or WEN is active 

    $setup( posedge AUXBLOCK, posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge AUXBLOCK, posedge CLK &&& TCHK_PAGE_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, posedge AUXBLOCK, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PAGE_ADDR, negedge AUXBLOCK, 0.0, NOTIFY_REG );

    // setup and hold checks on DATAWIDTH[1:0] with clock when REN or WEN is active 

    $setup( posedge DATAWIDTH[1], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge DATAWIDTH[1], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, posedge DATAWIDTH[1], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, negedge DATAWIDTH[1], 0.0, NOTIFY_REG );
    $setup( posedge DATAWIDTH[0], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $setup( negedge DATAWIDTH[0], posedge CLK &&& TCHK_BLK_ADDR, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, posedge DATAWIDTH[0], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_BLK_ADDR, negedge DATAWIDTH[0], 0.0, NOTIFY_REG );

    // setup and hold checks on WD[31:0] pins with clock, when WEN is active

    $setup( posedge WD[31], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[31], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[31], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[31], 0.0, NOTIFY_REG );
    $setup( posedge WD[30], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[30], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[30], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[30], 0.0, NOTIFY_REG );
    $setup( posedge WD[29], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[29], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[29], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[29], 0.0, NOTIFY_REG );
    $setup( posedge WD[28], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[28], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[28], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[28], 0.0, NOTIFY_REG );
    $setup( posedge WD[27], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[27], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[27], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[27], 0.0, NOTIFY_REG );
    $setup( posedge WD[26], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[26], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[26], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[26], 0.0, NOTIFY_REG );
    $setup( posedge WD[25], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[25], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[25], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[25], 0.0, NOTIFY_REG );
    $setup( posedge WD[24], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[24], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[24], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[24], 0.0, NOTIFY_REG );
    $setup( posedge WD[23], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[23], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[23], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[23], 0.0, NOTIFY_REG );
    $setup( posedge WD[22], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[22], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[22], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[22], 0.0, NOTIFY_REG );
    $setup( posedge WD[21], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[21], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[21], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[21], 0.0, NOTIFY_REG );
    $setup( posedge WD[20], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[20], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[20], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[20], 0.0, NOTIFY_REG );
    $setup( posedge WD[19], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[19], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[19], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[19], 0.0, NOTIFY_REG );
    $setup( posedge WD[18], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[18], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[18], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[18], 0.0, NOTIFY_REG );
    $setup( posedge WD[17], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[17], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[17], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[17], 0.0, NOTIFY_REG );
    $setup( posedge WD[16], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[16], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[16], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[16], 0.0, NOTIFY_REG );
    $setup( posedge WD[15], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[15], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[15], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[15], 0.0, NOTIFY_REG );
    $setup( posedge WD[14], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[14], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[14], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[14], 0.0, NOTIFY_REG );
    $setup( posedge WD[13], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[13], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[13], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[13], 0.0, NOTIFY_REG );
    $setup( posedge WD[12], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[12], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[12], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[12], 0.0, NOTIFY_REG );
    $setup( posedge WD[11], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[11], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[11], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[11], 0.0, NOTIFY_REG );
    $setup( posedge WD[10], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[10], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[10], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[10], 0.0, NOTIFY_REG );
    $setup( posedge WD[9], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[9], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[9], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[9], 0.0, NOTIFY_REG );
    $setup( posedge WD[8], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[8], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[8], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[8], 0.0, NOTIFY_REG );
    $setup( posedge WD[7], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[7], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[7], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[7], 0.0, NOTIFY_REG );
    $setup( posedge WD[6], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[6], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[6], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[6], 0.0, NOTIFY_REG );
    $setup( posedge WD[5], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[5], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[5], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[5], 0.0, NOTIFY_REG );
    $setup( posedge WD[4], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[4], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[4], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[4], 0.0, NOTIFY_REG );
    $setup( posedge WD[3], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[3], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[3], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[3], 0.0, NOTIFY_REG );
    $setup( posedge WD[2], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[2], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[2], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[2], 0.0, NOTIFY_REG );
    $setup( posedge WD[1], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[1], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[1], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[1], 0.0, NOTIFY_REG );
    $setup( posedge WD[0], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge WD[0], posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge WD[0], 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge WD[0], 0.0, NOTIFY_REG );

    // setup and hold checks on PAGELOSSPROTECT , when WEN is active

    $setup( posedge PAGELOSSPROTECT, posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $setup( negedge PAGELOSSPROTECT, posedge CLK &&& TCHK_WEN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, posedge PAGELOSSPROTECT, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_WEN, negedge PAGELOSSPROTECT, 0.0, NOTIFY_REG );

    // setup and hold checks for READNEXT, when REN is active

    $setup( posedge READNEXT, posedge CLK &&& TCHK_REN, 0.0, NOTIFY_REG );
    $setup( negedge READNEXT, posedge CLK &&& TCHK_REN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_REN, posedge READNEXT, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_REN, negedge READNEXT, 0.0, NOTIFY_REG );

    // setup and hold checks for PAGESTATUS, when REN is active

    $setup( posedge PAGESTATUS, posedge CLK &&& TCHK_REN, 0.0, NOTIFY_REG );
    $setup( negedge PAGESTATUS, posedge CLK &&& TCHK_REN, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_REN, posedge PAGESTATUS, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_REN, negedge PAGESTATUS, 0.0, NOTIFY_REG );

    // setup and hold checks for PIPE, when REN is active

    //$setup( posedge PIPE, posedge CLK &&& TCHK_REN, 0.0, NOTIFY_REG );
    //$setup( negedge PIPE, posedge CLK &&& TCHK_REN, 0.0, NOTIFY_REG );
    //$hold ( posedge CLK &&& TCHK_REN, posedge PIPE, 0.0, NOTIFY_REG );
    //$hold ( posedge CLK &&& TCHK_REN, negedge PIPE, 0.0, NOTIFY_REG );

    // setup and hold checks on PAGELOSSPROTECT , when ERASEPAGE is active

    $setup( posedge PAGELOSSPROTECT, posedge CLK &&& TCHK_ERASEPAGE, 0.0, NOTIFY_REG );
    $setup( negedge PAGELOSSPROTECT, posedge CLK &&& TCHK_ERASEPAGE, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_ERASEPAGE, posedge PAGELOSSPROTECT, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_ERASEPAGE, negedge PAGELOSSPROTECT, 0.0, NOTIFY_REG );

    // setup and hold checks on PAGELOSSPROTECT , when PROGRAM is active

    $setup( posedge PAGELOSSPROTECT, posedge CLK &&& TCHK_PROGRAM, 0.0, NOTIFY_REG );
    $setup( negedge PAGELOSSPROTECT, posedge CLK &&& TCHK_PROGRAM, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PROGRAM, posedge PAGELOSSPROTECT, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PROGRAM, negedge PAGELOSSPROTECT, 0.0, NOTIFY_REG );

    // setup and hold checks on OVERWRITEPAGE, when PROGRAM is active

    $setup( posedge OVERWRITEPAGE, posedge CLK &&& TCHK_PROGRAM, 0.0, NOTIFY_REG );
    $setup( negedge OVERWRITEPAGE, posedge CLK &&& TCHK_PROGRAM, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PROGRAM, posedge OVERWRITEPAGE, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PROGRAM, negedge OVERWRITEPAGE, 0.0, NOTIFY_REG );

    // setup and hold checks on OVERWRITEPROTECT, when PROGRAM is active

    $setup( posedge OVERWRITEPROTECT, posedge CLK &&& TCHK_PROGRAM, 0.0, NOTIFY_REG );
    $setup( negedge OVERWRITEPROTECT, posedge CLK &&& TCHK_PROGRAM, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PROGRAM, posedge OVERWRITEPROTECT, 0.0, NOTIFY_REG );
    $hold ( posedge CLK &&& TCHK_PROGRAM, negedge OVERWRITEPROTECT, 0.0, NOTIFY_REG );

    // setup and hold checks for LOCKREQUEST

    $setup( posedge LOCKREQUEST, posedge CLK, 0.0, NOTIFY_REG );
    $setup( negedge LOCKREQUEST, posedge CLK, 0.0, NOTIFY_REG );
    $hold ( posedge CLK, posedge LOCKREQUEST, 0.0, NOTIFY_REG );
    $hold ( posedge CLK, negedge LOCKREQUEST, 0.0, NOTIFY_REG );

    // timing checks on CLK, RESET
   
    $recovery( posedge RESET, posedge CLK, 0.0, NOTIFY_REG );
    $hold    ( posedge CLK, posedge RESET, 0.0, NOTIFY_REG );

    $width( negedge RESET, 0.0, 0, NOTIFY_REG );
    $width( posedge RESET, 0.0, 0, NOTIFY_REG );
    $width( posedge CLK,   0.0, 0, NOTIFY_REG );
    $width( negedge CLK,   0.0, 0, NOTIFY_REG );

    $period( posedge CLK, 10.0, NOTIFY_REG );
    $period( negedge CLK, 10.0, NOTIFY_REG );

  endspecify


endmodule
//---- END MODULE NVM ----

//---- MODULE ULSICC ----
/*--------------------------------------------------------------------
 CELL NAME : ULSICC
 CELL TYPE : comb
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module ULSICC(LSICC);
 input LSICC;

 wire  tmp;

 buf      U2(tmp, LSICC);

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE ULSICC ----
`endif
